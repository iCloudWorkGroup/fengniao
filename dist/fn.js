/*! fengniao 0.12.0 */


/**
 * @fileOverview 让内部各个部件的代码可以用[amd](https://github.com/amdjs/amdjs-api/wiki/AMD)模块定义方式组织起来。
 *
 * AMD API 内部的简单不完全实现，请忽略。只有当WebUploader被合并成一个文件的时候才会引入。
 */
(function( root, factory ) {
    var modules = {},

        // 内部require, 简单不完全实现。
        // https://github.com/amdjs/amdjs-api/wiki/require
        _require = function( deps, callback ) {
            var args, len, i;

            // 如果deps不是数组，则直接返回指定module
            if ( typeof deps === 'string' ) {
                return getModule( deps );
            } else {
                args = [];
                for( len = deps.length, i = 0; i < len; i++ ) {
                    args.push( getModule( deps[ i ] ) );
                }

                return callback.apply( null, args );
            }
        },

        // 内部define，暂时不支持不指定id.
        _define = function( id, deps, factory ) {
            if ( arguments.length === 2 ) {
                factory = deps;
                deps = null;
            }

            _require( deps || [], function() {
                setModule( id, factory, arguments );
            });
        },

        // 设置module, 兼容CommonJs写法。
        setModule = function( id, factory, args ) {
            var module = {
                    exports: factory
                },
                returned;

            if ( typeof factory === 'function' ) {
                args.length || (args = [ _require, module.exports, module ]);
                returned = factory.apply( null, args );
                returned !== undefined && (module.exports = returned);
            }

            modules[ id ] = module.exports;
        },

        // 根据id获取module
        getModule = function( id ) {
            var module = modules[ id ] || root[ id ];

            if ( !module ) {
                throw new Error( '`' + id + '` is undefined' );
            }

            return module;
        },

        // 将所有modules，将路径ids装换成对象。
        exportsTo = function( obj ) {
            var key, host, parts, part, last, ucFirst;

            // make the first character upper case.
            ucFirst = function( str ) {
                return str && (str.charAt( 0 ).toUpperCase() + str.substr( 1 ));
            };

            for ( key in modules ) {
                host = obj;

                if ( !modules.hasOwnProperty( key ) ) {
                    continue;
                }

                parts = key.split('/');
                last = ucFirst( parts.pop() );

                while( (part = ucFirst( parts.shift() )) ) {
                    host[ part ] = host[ part ] || {};
                    host = host[ part ];
                }

                host[ last ] = modules[ key ];
            }

            return obj;
        },

        makeExport = function( dollar ) {
            root.__dollar = dollar;

            // exports every module.
            return exportsTo( factory( root, _define, _require ) );
        },

        origin;

    if ( typeof module === 'object' && typeof module.exports === 'object' ) {

        // For CommonJS and CommonJS-like environments where a proper window is present,
        module.exports = makeExport();
    } else if ( typeof define === 'function' && define.amd ) {

        // Allow using this built library as an AMD module
        // in another project. That other project will only
        // see this AMD call, not the internal modules in
        // the closure below.
        define([ 'jquery' ], makeExport );
    } else {

        // Browser globals case. Just assign the
        // result to a property on the global.
        origin = root.SpreadSheet;
        root.SpreadSheet = makeExport();
        root.SpreadSheet.noConflict = function() {
            root.SpreadSheet = origin;
        };
    }
})( window, function( window, define, require ) {


    
    define('lib/jquery',function() {
    	return (function(window, noGlobal) {
    		// Support: Firefox 18+
    		// Can't be in strict mode, several libs including ASP.NET trace
    		// the stack via arguments.caller.callee and Firefox dies if
    		// you try to trace through "use strict" call chains. (#13335)
    		//
    
    		var arr = [];
    
    		var slice = arr.slice;
    
    		var concat = arr.concat;
    
    		var push = arr.push;
    
    		var indexOf = arr.indexOf;
    
    		var class2type = {};
    
    		var toString = class2type.toString;
    
    		var hasOwn = class2type.hasOwnProperty;
    
    		var support = {};
    
    
    
    		var
    		// Use the correct document accordingly with window argument (sandbox)
    			document = window.document,
    
    			version = "2.1.3",
    
    			// Define a local copy of jQuery
    			jQuery = function(selector, context) {
    				// The jQuery object is actually just the init constructor 'enhanced'
    				// Need init if jQuery is called (just allow error to be thrown if not included)
    				return new jQuery.fn.init(selector, context);
    			},
    
    			// Support: Android<4.1
    			// Make sure we trim BOM and NBSP
    			rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,
    
    			// Matches dashed string for camelizing
    			rmsPrefix = /^-ms-/,
    			rdashAlpha = /-([\da-z])/gi,
    
    			// Used by jQuery.camelCase as callback to replace()
    			fcamelCase = function(all, letter) {
    				return letter.toUpperCase();
    			};
    
    		jQuery.fn = jQuery.prototype = {
    			// The current version of jQuery being used
    			jquery: version,
    
    			constructor: jQuery,
    
    			// Start with an empty selector
    			selector: "",
    
    			// The default length of a jQuery object is 0
    			length: 0,
    
    			toArray: function() {
    				return slice.call(this);
    			},
    
    			// Get the Nth element in the matched element set OR
    			// Get the whole matched element set as a clean array
    			get: function(num) {
    				return num != null ?
    
    					// Return just the one element from the set
    					(num < 0 ? this[num + this.length] : this[num]) :
    
    					// Return all the elements in a clean array
    					slice.call(this);
    			},
    
    			// Take an array of elements and push it onto the stack
    			// (returning the new matched element set)
    			pushStack: function(elems) {
    
    				// Build a new jQuery matched element set
    				var ret = jQuery.merge(this.constructor(), elems);
    
    				// Add the old object onto the stack (as a reference)
    				ret.prevObject = this;
    				ret.context = this.context;
    
    				// Return the newly-formed element set
    				return ret;
    			},
    
    			// Execute a callback for every element in the matched set.
    			// (You can seed the arguments with an array of args, but this is
    			// only used internally.)
    			each: function(callback, args) {
    				return jQuery.each(this, callback, args);
    			},
    
    			map: function(callback) {
    				return this.pushStack(jQuery.map(this, function(elem, i) {
    					return callback.call(elem, i, elem);
    				}));
    			},
    
    			slice: function() {
    				return this.pushStack(slice.apply(this, arguments));
    			},
    
    			first: function() {
    				return this.eq(0);
    			},
    
    			last: function() {
    				return this.eq(-1);
    			},
    
    			eq: function(i) {
    				var len = this.length,
    					j = +i + (i < 0 ? len : 0);
    				return this.pushStack(j >= 0 && j < len ? [this[j]] : []);
    			},
    
    			end: function() {
    				return this.prevObject || this.constructor(null);
    			},
    
    			// For internal use only.
    			// Behaves like an Array's method, not like a jQuery method.
    			push: push,
    			sort: arr.sort,
    			splice: arr.splice
    		};
    
    		jQuery.extend = jQuery.fn.extend = function() {
    			var options, name, src, copy, copyIsArray, clone,
    				target = arguments[0] || {},
    				i = 1,
    				length = arguments.length,
    				deep = false;
    
    			// Handle a deep copy 
    			if (typeof target === "boolean") {
    				deep = target;
    
    				// Skip the boolean and the target
    				target = arguments[i] || {};
    				i++;
    			}
    
    			// Handle case when target is a string or something (possible in deep copy)
    			if (typeof target !== "object" && !jQuery.isFunction(target)) {
    				target = {};
    			}
    
    			// Extend jQuery itself if only one argument is passed
    			if (i === length) {
    				target = this;
    				i--;
    			}
    
    			for (; i < length; i++) {
    				// Only deal with non-null/undefined values
    				if ((options = arguments[i]) != null) {
    					// Extend the base object
    					for (name in options) {
    						src = target[name];
    						copy = options[name];
    
    						// Prevent never-ending loop
    						if (target === copy) {
    							continue;
    						}
    
    						// Recurse if we're merging plain objects or arrays
    						if (deep && copy && (jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)))) {
    							if (copyIsArray) {
    								copyIsArray = false;
    								clone = src && jQuery.isArray(src) ? src : [];
    							} else {
    								clone = src && jQuery.isPlainObject(src) ? src : {};
    							}
    
    							// Never move original objects, clone them
    							target[name] = jQuery.extend(deep, clone, copy);
    
    							// Don't bring in undefined values
    						} else if (copy !== undefined) {
    							target[name] = copy;
    						}
    					}
    				}
    			}
    
    			// Return the modified object
    			return target;
    		};
    
    		jQuery.extend({
    			// Unique for each copy of jQuery on the page
    			expando: "jQuery" + (version + Math.random()).replace(/\D/g, ""),
    
    			// Assume jQuery is ready without the ready module
    			isReady: true,
    
    			error: function(msg) {
    				throw new Error(msg);
    			},
    
    			noop: function() {},
    
    			isFunction: function(obj) {
    				return jQuery.type(obj) === "function";
    			},
    
    			isArray: Array.isArray,
    
    			isWindow: function(obj) {
    				return obj != null && obj === obj.window;
    			},
    
    			isNumeric: function(obj) {
    				// parseFloat NaNs numeric-cast false positives (null|true|false|"")
    				// ...but misinterprets leading-number strings, particularly hex literals ("0x...")
    				// subtraction forces infinities to NaN
    				// adding 1 corrects loss of precision from parseFloat (#15100)
    				return !jQuery.isArray(obj) && (obj - parseFloat(obj) + 1) >= 0;
    			},
    
    			isPlainObject: function(obj) {
    				// Not plain objects:
    				// - Any object or value whose internal [[Class]] property is not "[object Object]"
    				// - DOM nodes
    				// - window
    				if (jQuery.type(obj) !== "object" || obj.nodeType || jQuery.isWindow(obj)) {
    					return false;
    				}
    
    				if (obj.constructor &&
    					!hasOwn.call(obj.constructor.prototype, "isPrototypeOf")) {
    					return false;
    				}
    
    				// If the function hasn't returned already, we're confident that
    				// |obj| is a plain object, created by {} or constructed with new Object
    				return true;
    			},
    
    			isEmptyObject: function(obj) {
    				var name;
    				for (name in obj) {
    					return false;
    				}
    				return true;
    			},
    
    			type: function(obj) {
    				if (obj == null) {
    					return obj + "";
    				}
    				// Support: Android<4.0, iOS<6 (functionish RegExp)
    				return typeof obj === "object" || typeof obj === "function" ?
    					class2type[toString.call(obj)] || "object" :
    					typeof obj;
    			},
    
    			// Evaluates a script in a global context
    			globalEval: function(code) {
    				var script,
    					indirect = eval;
    
    				code = jQuery.trim(code);
    
    				if (code) {
    					// If the code includes a valid, prologue position
    					// strict mode pragma, execute code by injecting a
    					// script tag into the document.
    					if (code.indexOf("use strict") === 1) {
    						script = document.createElement("script");
    						script.text = code;
    						document.head.appendChild(script).parentNode.removeChild(script);
    					} else {
    						// Otherwise, avoid the DOM node creation, insertion
    						// and removal by using an indirect global eval
    						indirect(code);
    					}
    				}
    			},
    
    			// Convert dashed to camelCase; used by the css and data modules
    			// Support: IE9-11+
    			// Microsoft forgot to hump their vendor prefix (#9572)
    			camelCase: function(string) {
    				return string.replace(rmsPrefix, "ms-").replace(rdashAlpha, fcamelCase);
    			},
    
    			nodeName: function(elem, name) {
    				return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
    			},
    
    			// args is for internal usage only
    			each: function(obj, callback, args) {
    				var value,
    					i = 0,
    					length = obj.length,
    					isArray = isArraylike(obj);
    
    				if (args) {
    					if (isArray) {
    						for (; i < length; i++) {
    							value = callback.apply(obj[i], args);
    
    							if (value === false) {
    								break;
    							}
    						}
    					} else {
    						for (i in obj) {
    							value = callback.apply(obj[i], args);
    
    							if (value === false) {
    								break;
    							}
    						}
    					}
    
    					// A special, fast, case for the most common use of each
    				} else {
    					if (isArray) {
    						for (; i < length; i++) {
    							value = callback.call(obj[i], i, obj[i]);
    
    							if (value === false) {
    								break;
    							}
    						}
    					} else {
    						for (i in obj) {
    							value = callback.call(obj[i], i, obj[i]);
    
    							if (value === false) {
    								break;
    							}
    						}
    					}
    				}
    
    				return obj;
    			},
    
    			// Support: Android<4.1
    			trim: function(text) {
    				return text == null ?
    					"" :
    					(text + "").replace(rtrim, "");
    			},
    
    			// results is for internal usage only
    			makeArray: function(arr, results) {
    				var ret = results || [];
    
    				if (arr != null) {
    					if (isArraylike(Object(arr))) {
    						jQuery.merge(ret,
    							typeof arr === "string" ?
    							[arr] : arr
    						);
    					} else {
    						push.call(ret, arr);
    					}
    				}
    
    				return ret;
    			},
    
    			inArray: function(elem, arr, i) {
    				return arr == null ? -1 : indexOf.call(arr, elem, i);
    			},
    
    			merge: function(first, second) {
    				var len = +second.length,
    					j = 0,
    					i = first.length;
    
    				for (; j < len; j++) {
    					first[i++] = second[j];
    				}
    
    				first.length = i;
    
    				return first;
    			},
    
    			grep: function(elems, callback, invert) {
    				var callbackInverse,
    					matches = [],
    					i = 0,
    					length = elems.length,
    					callbackExpect = !invert;
    
    				// Go through the array, only saving the items
    				// that pass the validator function
    				for (; i < length; i++) {
    					callbackInverse = !callback(elems[i], i);
    					if (callbackInverse !== callbackExpect) {
    						matches.push(elems[i]);
    					}
    				}
    
    				return matches;
    			},
    
    			// arg is for internal usage only
    			map: function(elems, callback, arg) {
    				var value,
    					i = 0,
    					length = elems.length,
    					isArray = isArraylike(elems),
    					ret = [];
    
    				// Go through the array, translating each of the items to their new values
    				if (isArray) {
    					for (; i < length; i++) {
    						value = callback(elems[i], i, arg);
    
    						if (value != null) {
    							ret.push(value);
    						}
    					}
    
    					// Go through every key on the object,
    				} else {
    					for (i in elems) {
    						value = callback(elems[i], i, arg);
    
    						if (value != null) {
    							ret.push(value);
    						}
    					}
    				}
    
    				// Flatten any nested arrays
    				return concat.apply([], ret);
    			},
    
    			// A global GUID counter for objects
    			guid: 1,
    
    			// Bind a function to a context, optionally partially applying any
    			// arguments.
    			proxy: function(fn, context) {
    				var tmp, args, proxy;
    
    				if (typeof context === "string") {
    					tmp = fn[context];
    					context = fn;
    					fn = tmp;
    				}
    
    				// Quick check to determine if target is callable, in the spec
    				// this throws a TypeError, but we will just return undefined.
    				if (!jQuery.isFunction(fn)) {
    					return undefined;
    				}
    
    				// Simulated bind
    				args = slice.call(arguments, 2);
    				proxy = function() {
    					return fn.apply(context || this, args.concat(slice.call(arguments)));
    				};
    
    				// Set the guid of unique handler to the same of original handler, so it can be removed
    				proxy.guid = fn.guid = fn.guid || jQuery.guid++;
    
    				return proxy;
    			},
    
    			now: Date.now,
    
    			// jQuery.support is not used in Core but other projects attach their
    			// properties to it so it needs to exist.
    			support: support
    		});
    
    		// Populate the class2type map
    		jQuery.each("Boolean Number String Function Array Date RegExp Object Error".split(" "), function(i, name) {
    			class2type["[object " + name + "]"] = name.toLowerCase();
    		});
    
    		function isArraylike(obj) {
    			var length = obj.length,
    				type = jQuery.type(obj);
    
    			if (type === "function" || jQuery.isWindow(obj)) {
    				return false;
    			}
    
    			if (obj.nodeType === 1 && length) {
    				return true;
    			}
    
    			return type === "array" || length === 0 ||
    				typeof length === "number" && length > 0 && (length - 1) in obj;
    		}
    		var Sizzle =
    			
    			(function(window) {
    
    				var i,
    					support,
    					Expr,
    					getText,
    					isXML,
    					tokenize,
    					compile,
    					select,
    					outermostContext,
    					sortInput,
    					hasDuplicate,
    
    					// Local document vars
    					setDocument,
    					document,
    					docElem,
    					documentIsHTML,
    					rbuggyQSA,
    					rbuggyMatches,
    					matches,
    					contains,
    
    					// Instance-specific data
    					expando = "sizzle" + 1 * new Date(),
    					preferredDoc = window.document,
    					dirruns = 0,
    					done = 0,
    					classCache = createCache(),
    					tokenCache = createCache(),
    					compilerCache = createCache(),
    					sortOrder = function(a, b) {
    						if (a === b) {
    							hasDuplicate = true;
    						}
    						return 0;
    					},
    
    					// General-purpose constants
    					MAX_NEGATIVE = 1 << 31,
    
    					// Instance methods
    					hasOwn = ({}).hasOwnProperty,
    					arr = [],
    					pop = arr.pop,
    					push_native = arr.push,
    					push = arr.push,
    					slice = arr.slice,
    					// Use a stripped-down indexOf as it's faster than native
    					// http://jsperf.com/thor-indexof-vs-for/5
    					indexOf = function(list, elem) {
    						var i = 0,
    							len = list.length;
    						for (; i < len; i++) {
    							if (list[i] === elem) {
    								return i;
    							}
    						}
    						return -1;
    					},
    
    					booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",
    
    					// Regular expressions
    
    					// Whitespace characters http://www.w3.org/TR/css3-selectors/#whitespace
    					whitespace = "[\\x20\\t\\r\\n\\f]",
    					// http://www.w3.org/TR/css3-syntax/#characters
    					characterEncoding = "(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+",
    
    					// Loosely modeled on CSS identifier characters
    					// An unquoted value should be a CSS identifier http://www.w3.org/TR/css3-selectors/#attribute-selectors
    					// Proper syntax: http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier
    					identifier = characterEncoding.replace("w", "w#"),
    
    					// Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors
    					attributes = "\\[" + whitespace + "*(" + characterEncoding + ")(?:" + whitespace +
    					// Operator (capture 2)
    					"*([*^$|!~]?=)" + whitespace +
    					// "Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]"
    					"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" + whitespace +
    					"*\\]",
    
    					pseudos = ":(" + characterEncoding + ")(?:\\((" +
    					// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
    					// 1. quoted (capture 3; capture 4 or capture 5)
    					"('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" +
    					// 2. simple (capture 6)
    					"((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" +
    					// 3. anything else (capture 2)
    					".*" +
    					")\\)|)",
    
    					// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
    					rwhitespace = new RegExp(whitespace + "+", "g"),
    					rtrim = new RegExp("^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g"),
    
    					rcomma = new RegExp("^" + whitespace + "*," + whitespace + "*"),
    					rcombinators = new RegExp("^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*"),
    
    					rattributeQuotes = new RegExp("=" + whitespace + "*([^\\]'\"]*?)" + whitespace + "*\\]", "g"),
    
    					rpseudo = new RegExp(pseudos),
    					ridentifier = new RegExp("^" + identifier + "$"),
    
    					matchExpr = {
    						"ID": new RegExp("^#(" + characterEncoding + ")"),
    						"CLASS": new RegExp("^\\.(" + characterEncoding + ")"),
    						"TAG": new RegExp("^(" + characterEncoding.replace("w", "w*") + ")"),
    						"ATTR": new RegExp("^" + attributes),
    						"PSEUDO": new RegExp("^" + pseudos),
    						"CHILD": new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace +
    							"*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace +
    							"*(\\d+)|))" + whitespace + "*\\)|)", "i"),
    						"bool": new RegExp("^(?:" + booleans + ")$", "i"),
    						// For use in libraries implementing .is()
    						// We use this for POS matching in `select`
    						"needsContext": new RegExp("^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" +
    							whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i")
    					},
    
    					rinputs = /^(?:input|select|textarea|button)$/i,
    					rheader = /^h\d$/i,
    
    					rnative = /^[^{]+\{\s*\[native \w/,
    
    					// Easily-parseable/retrievable ID or TAG or CLASS selectors
    					rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,
    
    					rsibling = /[+~]/,
    					rescape = /'|\\/g,
    
    					// CSS escapes http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
    					runescape = new RegExp("\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig"),
    					funescape = function(_, escaped, escapedWhitespace) {
    						var high = "0x" + escaped - 0x10000;
    						// NaN means non-codepoint
    						// Support: Firefox<24
    						// Workaround erroneous numeric interpretation of +"0x"
    						return high !== high || escapedWhitespace ?
    							escaped :
    							high < 0 ?
    							// BMP codepoint
    							String.fromCharCode(high + 0x10000) :
    							// Supplemental Plane codepoint (surrogate pair)
    							String.fromCharCode(high >> 10 | 0xD800, high & 0x3FF | 0xDC00);
    					},
    
    					// Used for iframes
    					// See setDocument()
    					// Removing the function wrapper causes a "Permission Denied"
    					// error in IE
    					unloadHandler = function() {
    						setDocument();
    					};
    
    				// Optimize for push.apply( _, NodeList )
    				try {
    					push.apply(
    						(arr = slice.call(preferredDoc.childNodes)),
    						preferredDoc.childNodes
    					);
    					// Support: Android<4.0
    					// Detect silently failing push.apply
    					arr[preferredDoc.childNodes.length].nodeType;
    				} catch (e) {
    					push = {
    						apply: arr.length ?
    
    							// Leverage slice if possible
    							function(target, els) {
    								push_native.apply(target, slice.call(els));
    							} :
    
    							// Support: IE<9
    							// Otherwise append directly
    							function(target, els) {
    								var j = target.length,
    									i = 0;
    								// Can't trust NodeList.length
    								while ((target[j++] = els[i++])) {}
    								target.length = j - 1;
    							}
    					};
    				}
    
    				function Sizzle(selector, context, results, seed) {
    					var match, elem, m, nodeType,
    						// QSA vars
    						i, groups, old, nid, newContext, newSelector;
    
    					if ((context ? context.ownerDocument || context : preferredDoc) !== document) {
    						setDocument(context);
    					}
    
    					context = context || document;
    					results = results || [];
    					nodeType = context.nodeType;
    
    					if (typeof selector !== "string" || !selector ||
    						nodeType !== 1 && nodeType !== 9 && nodeType !== 11) {
    
    						return results;
    					}
    
    					if (!seed && documentIsHTML) {
    
    						// Try to shortcut find operations when possible (e.g., not under DocumentFragment)
    						if (nodeType !== 11 && (match = rquickExpr.exec(selector))) {
    							// Speed-up: Sizzle("#ID")
    							if ((m = match[1])) {
    								if (nodeType === 9) {
    									elem = context.getElementById(m);
    									// Check parentNode to catch when Blackberry 4.6 returns
    									// nodes that are no longer in the document (jQuery #6963)
    									if (elem && elem.parentNode) {
    										// Handle the case where IE, Opera, and Webkit return items
    										// by name instead of ID
    										if (elem.id === m) {
    											results.push(elem);
    											return results;
    										}
    									} else {
    										return results;
    									}
    								} else {
    									// Context is not a document
    									if (context.ownerDocument && (elem = context.ownerDocument.getElementById(m)) &&
    										contains(context, elem) && elem.id === m) {
    										results.push(elem);
    										return results;
    									}
    								}
    
    								// Speed-up: Sizzle("TAG")
    							} else if (match[2]) {
    								push.apply(results, context.getElementsByTagName(selector));
    								return results;
    
    								// Speed-up: Sizzle(".CLASS")
    							} else if ((m = match[3]) && support.getElementsByClassName) {
    								push.apply(results, context.getElementsByClassName(m));
    								return results;
    							}
    						}
    
    						// QSA path
    						if (support.qsa && (!rbuggyQSA || !rbuggyQSA.test(selector))) {
    							nid = old = expando;
    							newContext = context;
    							newSelector = nodeType !== 1 && selector;
    
    							// qSA works strangely on Element-rooted queries
    							// We can work around this by specifying an extra ID on the root
    							// and working up from there (Thanks to Andrew Dupont for the technique)
    							// IE 8 doesn't work on object elements
    							if (nodeType === 1 && context.nodeName.toLowerCase() !== "object") {
    								groups = tokenize(selector);
    
    								if ((old = context.getAttribute("id"))) {
    									nid = old.replace(rescape, "\\$&");
    								} else {
    									context.setAttribute("id", nid);
    								}
    								nid = "[id='" + nid + "'] ";
    
    								i = groups.length;
    								while (i--) {
    									groups[i] = nid + toSelector(groups[i]);
    								}
    								newContext = rsibling.test(selector) && testContext(context.parentNode) || context;
    								newSelector = groups.join(",");
    							}
    
    							if (newSelector) {
    								try {
    									push.apply(results,
    										newContext.querySelectorAll(newSelector)
    									);
    									return results;
    								} catch (qsaError) {} finally {
    									if (!old) {
    										context.removeAttribute("id");
    									}
    								}
    							}
    						}
    					}
    
    					// All others
    					return select(selector.replace(rtrim, "$1"), context, results, seed);
    				}
    
    				
    				function createCache() {
    					var keys = [];
    
    					function cache(key, value) {
    						// Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
    						if (keys.push(key + " ") > Expr.cacheLength) {
    							// Only keep the most recent entries
    							delete cache[keys.shift()];
    						}
    						return (cache[key + " "] = value);
    					}
    					return cache;
    				}
    
    				
    				function markFunction(fn) {
    					fn[expando] = true;
    					return fn;
    				}
    
    				
    				function assert(fn) {
    					var div = document.createElement("div");
    
    					try {
    						return !!fn(div);
    					} catch (e) {
    						return false;
    					} finally {
    						// Remove from its parent by default
    						if (div.parentNode) {
    							div.parentNode.removeChild(div);
    						}
    						// release memory in IE
    						div = null;
    					}
    				}
    
    				
    				function addHandle(attrs, handler) {
    					var arr = attrs.split("|"),
    						i = attrs.length;
    
    					while (i--) {
    						Expr.attrHandle[arr[i]] = handler;
    					}
    				}
    
    				
    				function siblingCheck(a, b) {
    					var cur = b && a,
    						diff = cur && a.nodeType === 1 && b.nodeType === 1 &&
    						(~b.sourceIndex || MAX_NEGATIVE) -
    						(~a.sourceIndex || MAX_NEGATIVE);
    
    					// Use IE sourceIndex if available on both nodes
    					if (diff) {
    						return diff;
    					}
    
    					// Check if b follows a
    					if (cur) {
    						while ((cur = cur.nextSibling)) {
    							if (cur === b) {
    								return -1;
    							}
    						}
    					}
    
    					return a ? 1 : -1;
    				}
    
    				
    				function createInputPseudo(type) {
    					return function(elem) {
    						var name = elem.nodeName.toLowerCase();
    						return name === "input" && elem.type === type;
    					};
    				}
    
    				
    				function createButtonPseudo(type) {
    					return function(elem) {
    						var name = elem.nodeName.toLowerCase();
    						return (name === "input" || name === "button") && elem.type === type;
    					};
    				}
    
    				
    				function createPositionalPseudo(fn) {
    					return markFunction(function(argument) {
    						argument = +argument;
    						return markFunction(function(seed, matches) {
    							var j,
    								matchIndexes = fn([], seed.length, argument),
    								i = matchIndexes.length;
    
    							// Match elements found at the specified indexes
    							while (i--) {
    								if (seed[(j = matchIndexes[i])]) {
    									seed[j] = !(matches[j] = seed[j]);
    								}
    							}
    						});
    					});
    				}
    
    				
    				function testContext(context) {
    					return context && typeof context.getElementsByTagName !== "undefined" && context;
    				}
    
    				// Expose support vars for convenience
    				support = Sizzle.support = {};
    
    				
    				isXML = Sizzle.isXML = function(elem) {
    					// documentElement is verified for cases where it doesn't yet exist
    					// (such as loading iframes in IE - #4833)
    					var documentElement = elem && (elem.ownerDocument || elem).documentElement;
    					return documentElement ? documentElement.nodeName !== "HTML" : false;
    				};
    
    				
    				setDocument = Sizzle.setDocument = function(node) {
    					var hasCompare, parent,
    						doc = node ? node.ownerDocument || node : preferredDoc;
    
    					// If no document and documentElement is available, return
    					if (doc === document || doc.nodeType !== 9 || !doc.documentElement) {
    						return document;
    					}
    
    					// Set our document
    					document = doc;
    					docElem = doc.documentElement;
    					parent = doc.defaultView;
    
    					// Support: IE>8
    					// If iframe document is assigned to "document" variable and if iframe has been reloaded,
    					// IE will throw "permission denied" error when accessing "document" variable, see jQuery #13936
    					// IE6-8 do not support the defaultView property so parent will be undefined
    					if (parent && parent !== parent.top) {
    						// IE11 does not have attachEvent, so all must suffer
    						if (parent.addEventListener) {
    							parent.addEventListener("unload", unloadHandler, false);
    						} else if (parent.attachEvent) {
    							parent.attachEvent("onunload", unloadHandler);
    						}
    					}
    
    					
    					documentIsHTML = !isXML(doc);
    
    					
    
    					// Support: IE<8
    					// Verify that getAttribute really returns attributes and not properties
    					// (excepting IE8 booleans)
    					support.attributes = assert(function(div) {
    						div.className = "i";
    						return !div.getAttribute("className");
    					});
    
    					
    
    					// Check if getElementsByTagName("*") returns only elements
    					support.getElementsByTagName = assert(function(div) {
    						div.appendChild(doc.createComment(""));
    						return !div.getElementsByTagName("*").length;
    					});
    
    					// Support: IE<9
    					support.getElementsByClassName = rnative.test(doc.getElementsByClassName);
    
    					// Support: IE<10
    					// Check if getElementById returns elements by name
    					// The broken getElementById methods don't pick up programatically-set names,
    					// so use a roundabout getElementsByName test
    					support.getById = assert(function(div) {
    						docElem.appendChild(div).id = expando;
    						return !doc.getElementsByName || !doc.getElementsByName(expando).length;
    					});
    
    					// ID find and filter
    					if (support.getById) {
    						Expr.find["ID"] = function(id, context) {
    							if (typeof context.getElementById !== "undefined" && documentIsHTML) {
    								var m = context.getElementById(id);
    								// Check parentNode to catch when Blackberry 4.6 returns
    								// nodes that are no longer in the document #6963
    								return m && m.parentNode ? [m] : [];
    							}
    						};
    						Expr.filter["ID"] = function(id) {
    							var attrId = id.replace(runescape, funescape);
    							return function(elem) {
    								return elem.getAttribute("id") === attrId;
    							};
    						};
    					} else {
    						// Support: IE6/7
    						// getElementById is not reliable as a find shortcut
    						delete Expr.find["ID"];
    
    						Expr.filter["ID"] = function(id) {
    							var attrId = id.replace(runescape, funescape);
    							return function(elem) {
    								var node = typeof elem.getAttributeNode !== "undefined" && elem.getAttributeNode("id");
    								return node && node.value === attrId;
    							};
    						};
    					}
    
    					// Tag
    					Expr.find["TAG"] = support.getElementsByTagName ?
    						function(tag, context) {
    							if (typeof context.getElementsByTagName !== "undefined") {
    								return context.getElementsByTagName(tag);
    
    								// DocumentFragment nodes don't have gEBTN
    							} else if (support.qsa) {
    								return context.querySelectorAll(tag);
    							}
    						} :
    
    						function(tag, context) {
    							var elem,
    								tmp = [],
    								i = 0,
    								// By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too
    								results = context.getElementsByTagName(tag);
    
    							// Filter out possible comments
    							if (tag === "*") {
    								while ((elem = results[i++])) {
    									if (elem.nodeType === 1) {
    										tmp.push(elem);
    									}
    								}
    
    								return tmp;
    							}
    							return results;
    						};
    
    					// Class
    					Expr.find["CLASS"] = support.getElementsByClassName && function(className, context) {
    						if (documentIsHTML) {
    							return context.getElementsByClassName(className);
    						}
    					};
    
    					
    
    					// QSA and matchesSelector support
    
    					// matchesSelector(:active) reports false when true (IE9/Opera 11.5)
    					rbuggyMatches = [];
    
    					// qSa(:focus) reports false when true (Chrome 21)
    					// We allow this because of a bug in IE8/9 that throws an error
    					// whenever `document.activeElement` is accessed on an iframe
    					// So, we allow :focus to pass through QSA all the time to avoid the IE error
    					// See http://bugs.jquery.com/ticket/13378
    					rbuggyQSA = [];
    
    					if ((support.qsa = rnative.test(doc.querySelectorAll))) {
    						// Build QSA regex
    						// Regex strategy adopted from Diego Perini
    						assert(function(div) {
    							// Select is set to empty string on purpose
    							// This is to test IE's treatment of not explicitly
    							// setting a boolean content attribute,
    							// since its presence should be enough
    							// http://bugs.jquery.com/ticket/12359
    							docElem.appendChild(div).innerHTML = "<a id='" + expando + "'></a>" +
    								"<select id='" + expando + "-\f]' msallowcapture=''>" +
    								"<option selected=''></option></select>";
    
    							// Support: IE8, Opera 11-12.16
    							// Nothing should be selected when empty strings follow ^= or $= or *=
    							// The test attribute must be unknown in Opera but "safe" for WinRT
    							// http://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section
    							if (div.querySelectorAll("[msallowcapture^='']").length) {
    								rbuggyQSA.push("[*^$]=" + whitespace + "*(?:''|\"\")");
    							}
    
    							// Support: IE8
    							// Boolean attributes and "value" are not treated correctly
    							if (!div.querySelectorAll("[selected]").length) {
    								rbuggyQSA.push("\\[" + whitespace + "*(?:value|" + booleans + ")");
    							}
    
    							// Support: Chrome<29, Android<4.2+, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.7+
    							if (!div.querySelectorAll("[id~=" + expando + "-]").length) {
    								rbuggyQSA.push("~=");
    							}
    
    							// Webkit/Opera - :checked should return selected option elements
    							// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
    							// IE8 throws error here and will not see later tests
    							if (!div.querySelectorAll(":checked").length) {
    								rbuggyQSA.push(":checked");
    							}
    
    							// Support: Safari 8+, iOS 8+
    							// https://bugs.webkit.org/show_bug.cgi?id=136851
    							// In-page `selector#id sibing-combinator selector` fails
    							if (!div.querySelectorAll("a#" + expando + "+*").length) {
    								rbuggyQSA.push(".#.+[+~]");
    							}
    						});
    
    						assert(function(div) {
    							// Support: Windows 8 Native Apps
    							// The type and name attributes are restricted during .innerHTML assignment
    							var input = doc.createElement("input");
    							input.setAttribute("type", "hidden");
    							div.appendChild(input).setAttribute("name", "D");
    
    							// Support: IE8
    							// Enforce case-sensitivity of name attribute
    							if (div.querySelectorAll("[name=d]").length) {
    								rbuggyQSA.push("name" + whitespace + "*[*^$|!~]?=");
    							}
    
    							// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
    							// IE8 throws error here and will not see later tests
    							if (!div.querySelectorAll(":enabled").length) {
    								rbuggyQSA.push(":enabled", ":disabled");
    							}
    
    							// Opera 10-11 does not throw on post-comma invalid pseudos
    							div.querySelectorAll("*,:x");
    							rbuggyQSA.push(",.*:");
    						});
    					}
    
    					if ((support.matchesSelector = rnative.test((matches = docElem.matches ||
    							docElem.webkitMatchesSelector ||
    							docElem.mozMatchesSelector ||
    							docElem.oMatchesSelector ||
    							docElem.msMatchesSelector)))) {
    
    						assert(function(div) {
    							// Check to see if it's possible to do matchesSelector
    							// on a disconnected node (IE 9)
    							support.disconnectedMatch = matches.call(div, "div");
    
    							// This should fail with an exception
    							// Gecko does not error, returns false instead
    							matches.call(div, "[s!='']:x");
    							rbuggyMatches.push("!=", pseudos);
    						});
    					}
    
    					rbuggyQSA = rbuggyQSA.length && new RegExp(rbuggyQSA.join("|"));
    					rbuggyMatches = rbuggyMatches.length && new RegExp(rbuggyMatches.join("|"));
    
    					
    					hasCompare = rnative.test(docElem.compareDocumentPosition);
    
    					// Element contains another
    					// Purposefully does not implement inclusive descendent
    					// As in, an element does not contain itself
    					contains = hasCompare || rnative.test(docElem.contains) ?
    						function(a, b) {
    							var adown = a.nodeType === 9 ? a.documentElement : a,
    								bup = b && b.parentNode;
    							return a === bup || !!(bup && bup.nodeType === 1 && (
    								adown.contains ?
    								adown.contains(bup) :
    								a.compareDocumentPosition && a.compareDocumentPosition(bup) & 16
    							));
    						} :
    						function(a, b) {
    							if (b) {
    								while ((b = b.parentNode)) {
    									if (b === a) {
    										return true;
    									}
    								}
    							}
    							return false;
    						};
    
    					
    
    					// Document order sorting
    					sortOrder = hasCompare ?
    						function(a, b) {
    
    							// Flag for duplicate removal
    							if (a === b) {
    								hasDuplicate = true;
    								return 0;
    							}
    
    							// Sort on method existence if only one input has compareDocumentPosition
    							var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
    							if (compare) {
    								return compare;
    							}
    
    							// Calculate position if both inputs belong to the same document
    							compare = (a.ownerDocument || a) === (b.ownerDocument || b) ?
    								a.compareDocumentPosition(b) :
    
    								// Otherwise we know they are disconnected
    								1;
    
    							// Disconnected nodes
    							if (compare & 1 ||
    								(!support.sortDetached && b.compareDocumentPosition(a) === compare)) {
    
    								// Choose the first element that is related to our preferred document
    								if (a === doc || a.ownerDocument === preferredDoc && contains(preferredDoc, a)) {
    									return -1;
    								}
    								if (b === doc || b.ownerDocument === preferredDoc && contains(preferredDoc, b)) {
    									return 1;
    								}
    
    								// Maintain original order
    								return sortInput ?
    									(indexOf(sortInput, a) - indexOf(sortInput, b)) :
    									0;
    							}
    
    							return compare & 4 ? -1 : 1;
    						} :
    						function(a, b) {
    							// Exit early if the nodes are identical
    							if (a === b) {
    								hasDuplicate = true;
    								return 0;
    							}
    
    							var cur,
    								i = 0,
    								aup = a.parentNode,
    								bup = b.parentNode,
    								ap = [a],
    								bp = [b];
    
    							// Parentless nodes are either documents or disconnected
    							if (!aup || !bup) {
    								return a === doc ? -1 :
    									b === doc ? 1 :
    									aup ? -1 :
    									bup ? 1 :
    									sortInput ?
    									(indexOf(sortInput, a) - indexOf(sortInput, b)) :
    									0;
    
    								// If the nodes are siblings, we can do a quick check
    							} else if (aup === bup) {
    								return siblingCheck(a, b);
    							}
    
    							// Otherwise we need full lists of their ancestors for comparison
    							cur = a;
    							while ((cur = cur.parentNode)) {
    								ap.unshift(cur);
    							}
    							cur = b;
    							while ((cur = cur.parentNode)) {
    								bp.unshift(cur);
    							}
    
    							// Walk down the tree looking for a discrepancy
    							while (ap[i] === bp[i]) {
    								i++;
    							}
    
    							return i ?
    								// Do a sibling check if the nodes have a common ancestor
    								siblingCheck(ap[i], bp[i]) :
    
    								// Otherwise nodes in our document sort first
    								ap[i] === preferredDoc ? -1 :
    								bp[i] === preferredDoc ? 1 :
    								0;
    						};
    
    					return doc;
    				};
    
    				Sizzle.matches = function(expr, elements) {
    					return Sizzle(expr, null, null, elements);
    				};
    
    				Sizzle.matchesSelector = function(elem, expr) {
    					// Set document vars if needed
    					if ((elem.ownerDocument || elem) !== document) {
    						setDocument(elem);
    					}
    
    					// Make sure that attribute selectors are quoted
    					expr = expr.replace(rattributeQuotes, "='$1']");
    
    					if (support.matchesSelector && documentIsHTML &&
    						(!rbuggyMatches || !rbuggyMatches.test(expr)) &&
    						(!rbuggyQSA || !rbuggyQSA.test(expr))) {
    
    						try {
    							var ret = matches.call(elem, expr);
    
    							// IE 9's matchesSelector returns false on disconnected nodes
    							if (ret || support.disconnectedMatch ||
    								// As well, disconnected nodes are said to be in a document
    								// fragment in IE 9
    								elem.document && elem.document.nodeType !== 11) {
    								return ret;
    							}
    						} catch (e) {}
    					}
    
    					return Sizzle(expr, document, null, [elem]).length > 0;
    				};
    
    				Sizzle.contains = function(context, elem) {
    					// Set document vars if needed
    					if ((context.ownerDocument || context) !== document) {
    						setDocument(context);
    					}
    					return contains(context, elem);
    				};
    
    				Sizzle.attr = function(elem, name) {
    					// Set document vars if needed
    					if ((elem.ownerDocument || elem) !== document) {
    						setDocument(elem);
    					}
    
    					var fn = Expr.attrHandle[name.toLowerCase()],
    						// Don't get fooled by Object.prototype properties (jQuery #13807)
    						val = fn && hasOwn.call(Expr.attrHandle, name.toLowerCase()) ?
    						fn(elem, name, !documentIsHTML) :
    						undefined;
    
    					return val !== undefined ?
    						val :
    						support.attributes || !documentIsHTML ?
    						elem.getAttribute(name) :
    						(val = elem.getAttributeNode(name)) && val.specified ?
    						val.value :
    						null;
    				};
    
    				Sizzle.error = function(msg) {
    					throw new Error("Syntax error, unrecognized expression: " + msg);
    				};
    
    				
    				Sizzle.uniqueSort = function(results) {
    					var elem,
    						duplicates = [],
    						j = 0,
    						i = 0;
    
    					// Unless we *know* we can detect duplicates, assume their presence
    					hasDuplicate = !support.detectDuplicates;
    					sortInput = !support.sortStable && results.slice(0);
    					results.sort(sortOrder);
    
    					if (hasDuplicate) {
    						while ((elem = results[i++])) {
    							if (elem === results[i]) {
    								j = duplicates.push(i);
    							}
    						}
    						while (j--) {
    							results.splice(duplicates[j], 1);
    						}
    					}
    
    					// Clear input after sorting to release objects
    					// See https://github.com/jquery/sizzle/pull/225
    					sortInput = null;
    
    					return results;
    				};
    
    				
    				getText = Sizzle.getText = function(elem) {
    					var node,
    						ret = "",
    						i = 0,
    						nodeType = elem.nodeType;
    
    					if (!nodeType) {
    						// If no nodeType, this is expected to be an array
    						while ((node = elem[i++])) {
    							// Do not traverse comment nodes
    							ret += getText(node);
    						}
    					} else if (nodeType === 1 || nodeType === 9 || nodeType === 11) {
    						// Use textContent for elements
    						// innerText usage removed for consistency of new lines (jQuery #11153)
    						if (typeof elem.textContent === "string") {
    							return elem.textContent;
    						} else {
    							// Traverse its children
    							for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
    								ret += getText(elem);
    							}
    						}
    					} else if (nodeType === 3 || nodeType === 4) {
    						return elem.nodeValue;
    					}
    					// Do not include comment or processing instruction nodes
    
    					return ret;
    				};
    
    				Expr = Sizzle.selectors = {
    
    					// Can be adjusted by the user
    					cacheLength: 50,
    
    					createPseudo: markFunction,
    
    					match: matchExpr,
    
    					attrHandle: {},
    
    					find: {},
    
    					relative: {
    						">": {
    							dir: "parentNode",
    							first: true
    						},
    						" ": {
    							dir: "parentNode"
    						},
    						"+": {
    							dir: "previousSibling",
    							first: true
    						},
    						"~": {
    							dir: "previousSibling"
    						}
    					},
    
    					preFilter: {
    						"ATTR": function(match) {
    							match[1] = match[1].replace(runescape, funescape);
    
    							// Move the given value to match[3] whether quoted or unquoted
    							match[3] = (match[3] || match[4] || match[5] || "").replace(runescape, funescape);
    
    							if (match[2] === "~=") {
    								match[3] = " " + match[3] + " ";
    							}
    
    							return match.slice(0, 4);
    						},
    
    						"CHILD": function(match) {
    							
    							match[1] = match[1].toLowerCase();
    
    							if (match[1].slice(0, 3) === "nth") {
    								// nth-* requires argument
    								if (!match[3]) {
    									Sizzle.error(match[0]);
    								}
    
    								// numeric x and y parameters for Expr.filter.CHILD
    								// remember that false/true cast respectively to 0/1
    								match[4] = +(match[4] ? match[5] + (match[6] || 1) : 2 * (match[3] === "even" || match[3] === "odd"));
    								match[5] = +((match[7] + match[8]) || match[3] === "odd");
    
    								// other types prohibit arguments
    							} else if (match[3]) {
    								Sizzle.error(match[0]);
    							}
    
    							return match;
    						},
    
    						"PSEUDO": function(match) {
    							var excess,
    								unquoted = !match[6] && match[2];
    
    							if (matchExpr["CHILD"].test(match[0])) {
    								return null;
    							}
    
    							// Accept quoted arguments as-is
    							if (match[3]) {
    								match[2] = match[4] || match[5] || "";
    
    								// Strip excess characters from unquoted arguments
    							} else if (unquoted && rpseudo.test(unquoted) &&
    								// Get excess from tokenize (recursively)
    								(excess = tokenize(unquoted, true)) &&
    								// advance to the next closing parenthesis
    								(excess = unquoted.indexOf(")", unquoted.length - excess) - unquoted.length)) {
    
    								// excess is a negative index
    								match[0] = match[0].slice(0, excess);
    								match[2] = unquoted.slice(0, excess);
    							}
    
    							// Return only captures needed by the pseudo filter method (type and argument)
    							return match.slice(0, 3);
    						}
    					},
    
    					filter: {
    
    						"TAG": function(nodeNameSelector) {
    							var nodeName = nodeNameSelector.replace(runescape, funescape).toLowerCase();
    							return nodeNameSelector === "*" ?
    								function() {
    									return true;
    								} :
    								function(elem) {
    									return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
    								};
    						},
    
    						"CLASS": function(className) {
    							var pattern = classCache[className + " "];
    
    							return pattern ||
    								(pattern = new RegExp("(^|" + whitespace + ")" + className + "(" + whitespace + "|$)")) &&
    								classCache(className, function(elem) {
    									return pattern.test(typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== "undefined" && elem.getAttribute("class") || "");
    								});
    						},
    
    						"ATTR": function(name, operator, check) {
    							return function(elem) {
    								var result = Sizzle.attr(elem, name);
    
    								if (result == null) {
    									return operator === "!=";
    								}
    								if (!operator) {
    									return true;
    								}
    
    								result += "";
    
    								return operator === "=" ? result === check :
    									operator === "!=" ? result !== check :
    									operator === "^=" ? check && result.indexOf(check) === 0 :
    									operator === "*=" ? check && result.indexOf(check) > -1 :
    									operator === "$=" ? check && result.slice(-check.length) === check :
    									operator === "~=" ? (" " + result.replace(rwhitespace, " ") + " ").indexOf(check) > -1 :
    									operator === "|=" ? result === check || result.slice(0, check.length + 1) === check + "-" :
    									false;
    							};
    						},
    
    						"CHILD": function(type, what, argument, first, last) {
    							var simple = type.slice(0, 3) !== "nth",
    								forward = type.slice(-4) !== "last",
    								ofType = what === "of-type";
    
    							return first === 1 && last === 0 ?
    
    								// Shortcut for :nth-*(n)
    								function(elem) {
    									return !!elem.parentNode;
    								} :
    
    								function(elem, context, xml) {
    									var cache, outerCache, node, diff, nodeIndex, start,
    										dir = simple !== forward ? "nextSibling" : "previousSibling",
    										parent = elem.parentNode,
    										name = ofType && elem.nodeName.toLowerCase(),
    										useCache = !xml && !ofType;
    
    									if (parent) {
    
    										// :(first|last|only)-(child|of-type)
    										if (simple) {
    											while (dir) {
    												node = elem;
    												while ((node = node[dir])) {
    													if (ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) {
    														return false;
    													}
    												}
    												// Reverse direction for :only-* (if we haven't yet done so)
    												start = dir = type === "only" && !start && "nextSibling";
    											}
    											return true;
    										}
    
    										start = [forward ? parent.firstChild : parent.lastChild];
    
    										// non-xml :nth-child(...) stores cache data on `parent`
    										if (forward && useCache) {
    											// Seek `elem` from a previously-cached index
    											outerCache = parent[expando] || (parent[expando] = {});
    											cache = outerCache[type] || [];
    											nodeIndex = cache[0] === dirruns && cache[1];
    											diff = cache[0] === dirruns && cache[2];
    											node = nodeIndex && parent.childNodes[nodeIndex];
    
    											while ((node = ++nodeIndex && node && node[dir] ||
    
    													// Fallback to seeking `elem` from the start
    													(diff = nodeIndex = 0) || start.pop())) {
    
    												// When found, cache indexes on `parent` and break
    												if (node.nodeType === 1 && ++diff && node === elem) {
    													outerCache[type] = [dirruns, nodeIndex, diff];
    													break;
    												}
    											}
    
    											// Use previously-cached element index if available
    										} else if (useCache && (cache = (elem[expando] || (elem[expando] = {}))[type]) && cache[0] === dirruns) {
    											diff = cache[1];
    
    											// xml :nth-child(...) or :nth-last-child(...) or :nth(-last)?-of-type(...)
    										} else {
    											// Use the same loop as above to seek `elem` from the start
    											while ((node = ++nodeIndex && node && node[dir] ||
    													(diff = nodeIndex = 0) || start.pop())) {
    
    												if ((ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) && ++diff) {
    													// Cache the index of each encountered element
    													if (useCache) {
    														(node[expando] || (node[expando] = {}))[type] = [dirruns, diff];
    													}
    
    													if (node === elem) {
    														break;
    													}
    												}
    											}
    										}
    
    										// Incorporate the offset, then check against cycle size
    										diff -= last;
    										return diff === first || (diff % first === 0 && diff / first >= 0);
    									}
    								};
    						},
    
    						"PSEUDO": function(pseudo, argument) {
    							// pseudo-class names are case-insensitive
    							// http://www.w3.org/TR/selectors/#pseudo-classes
    							// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
    							// Remember that setFilters inherits from pseudos
    							var args,
    								fn = Expr.pseudos[pseudo] || Expr.setFilters[pseudo.toLowerCase()] ||
    								Sizzle.error("unsupported pseudo: " + pseudo);
    
    							// The user may use createPseudo to indicate that
    							// arguments are needed to create the filter function
    							// just as Sizzle does
    							if (fn[expando]) {
    								return fn(argument);
    							}
    
    							// But maintain support for old signatures
    							if (fn.length > 1) {
    								args = [pseudo, pseudo, "", argument];
    								return Expr.setFilters.hasOwnProperty(pseudo.toLowerCase()) ?
    									markFunction(function(seed, matches) {
    										var idx,
    											matched = fn(seed, argument),
    											i = matched.length;
    										while (i--) {
    											idx = indexOf(seed, matched[i]);
    											seed[idx] = !(matches[idx] = matched[i]);
    										}
    									}) :
    									function(elem) {
    										return fn(elem, 0, args);
    									};
    							}
    
    							return fn;
    						}
    					},
    
    					pseudos: {
    						// Potentially complex pseudos
    						"not": markFunction(function(selector) {
    							// Trim the selector passed to compile
    							// to avoid treating leading and trailing
    							// spaces as combinators
    							var input = [],
    								results = [],
    								matcher = compile(selector.replace(rtrim, "$1"));
    
    							return matcher[expando] ?
    								markFunction(function(seed, matches, context, xml) {
    									var elem,
    										unmatched = matcher(seed, null, xml, []),
    										i = seed.length;
    
    									// Match elements unmatched by `matcher`
    									while (i--) {
    										if ((elem = unmatched[i])) {
    											seed[i] = !(matches[i] = elem);
    										}
    									}
    								}) :
    								function(elem, context, xml) {
    									input[0] = elem;
    									matcher(input, null, xml, results);
    									// Don't keep the element (issue #299)
    									input[0] = null;
    									return !results.pop();
    								};
    						}),
    
    						"has": markFunction(function(selector) {
    							return function(elem) {
    								return Sizzle(selector, elem).length > 0;
    							};
    						}),
    
    						"contains": markFunction(function(text) {
    							text = text.replace(runescape, funescape);
    							return function(elem) {
    								return (elem.textContent || elem.innerText || getText(elem)).indexOf(text) > -1;
    							};
    						}),
    
    						// "Whether an element is represented by a :lang() selector
    						// is based solely on the element's language value
    						// being equal to the identifier C,
    						// or beginning with the identifier C immediately followed by "-".
    						// The matching of C against the element's language value is performed case-insensitively.
    						// The identifier C does not have to be a valid language name."
    						// http://www.w3.org/TR/selectors/#lang-pseudo
    						"lang": markFunction(function(lang) {
    							// lang value must be a valid identifier
    							if (!ridentifier.test(lang || "")) {
    								Sizzle.error("unsupported lang: " + lang);
    							}
    							lang = lang.replace(runescape, funescape).toLowerCase();
    							return function(elem) {
    								var elemLang;
    								do {
    									if ((elemLang = documentIsHTML ?
    											elem.lang :
    											elem.getAttribute("xml:lang") || elem.getAttribute("lang"))) {
    
    										elemLang = elemLang.toLowerCase();
    										return elemLang === lang || elemLang.indexOf(lang + "-") === 0;
    									}
    								} while ((elem = elem.parentNode) && elem.nodeType === 1);
    								return false;
    							};
    						}),
    
    						// Miscellaneous
    						"target": function(elem) {
    							var hash = window.location && window.location.hash;
    							return hash && hash.slice(1) === elem.id;
    						},
    
    						"root": function(elem) {
    							return elem === docElem;
    						},
    
    						"focus": function(elem) {
    							return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
    						},
    
    						// Boolean properties
    						"enabled": function(elem) {
    							return elem.disabled === false;
    						},
    
    						"disabled": function(elem) {
    							return elem.disabled === true;
    						},
    
    						"checked": function(elem) {
    							// In CSS3, :checked should return both checked and selected elements
    							// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
    							var nodeName = elem.nodeName.toLowerCase();
    							return (nodeName === "input" && !!elem.checked) || (nodeName === "option" && !!elem.selected);
    						},
    
    						"selected": function(elem) {
    							// Accessing this property makes selected-by-default
    							// options in Safari work properly
    							if (elem.parentNode) {
    								elem.parentNode.selectedIndex;
    							}
    
    							return elem.selected === true;
    						},
    
    						// Contents
    						"empty": function(elem) {
    							// http://www.w3.org/TR/selectors/#empty-pseudo
    							// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
    							//   but not by others (comment: 8; processing instruction: 7; etc.)
    							// nodeType < 6 works because attributes (2) do not appear as children
    							for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
    								if (elem.nodeType < 6) {
    									return false;
    								}
    							}
    							return true;
    						},
    
    						"parent": function(elem) {
    							return !Expr.pseudos["empty"](elem);
    						},
    
    						// Element/input types
    						"header": function(elem) {
    							return rheader.test(elem.nodeName);
    						},
    
    						"input": function(elem) {
    							return rinputs.test(elem.nodeName);
    						},
    
    						"button": function(elem) {
    							var name = elem.nodeName.toLowerCase();
    							return name === "input" && elem.type === "button" || name === "button";
    						},
    
    						"text": function(elem) {
    							var attr;
    							return elem.nodeName.toLowerCase() === "input" &&
    								elem.type === "text" &&
    
    								// Support: IE<8
    								// New HTML5 attribute values (e.g., "search") appear with elem.type === "text"
    								((attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text");
    						},
    
    						// Position-in-collection
    						"first": createPositionalPseudo(function() {
    							return [0];
    						}),
    
    						"last": createPositionalPseudo(function(matchIndexes, length) {
    							return [length - 1];
    						}),
    
    						"eq": createPositionalPseudo(function(matchIndexes, length, argument) {
    							return [argument < 0 ? argument + length : argument];
    						}),
    
    						"even": createPositionalPseudo(function(matchIndexes, length) {
    							var i = 0;
    							for (; i < length; i += 2) {
    								matchIndexes.push(i);
    							}
    							return matchIndexes;
    						}),
    
    						"odd": createPositionalPseudo(function(matchIndexes, length) {
    							var i = 1;
    							for (; i < length; i += 2) {
    								matchIndexes.push(i);
    							}
    							return matchIndexes;
    						}),
    
    						"lt": createPositionalPseudo(function(matchIndexes, length, argument) {
    							var i = argument < 0 ? argument + length : argument;
    							for (; --i >= 0;) {
    								matchIndexes.push(i);
    							}
    							return matchIndexes;
    						}),
    
    						"gt": createPositionalPseudo(function(matchIndexes, length, argument) {
    							var i = argument < 0 ? argument + length : argument;
    							for (; ++i < length;) {
    								matchIndexes.push(i);
    							}
    							return matchIndexes;
    						})
    					}
    				};
    
    				Expr.pseudos["nth"] = Expr.pseudos["eq"];
    
    				// Add button/input type pseudos
    				for (i in {
    						radio: true,
    						checkbox: true,
    						file: true,
    						password: true,
    						image: true
    					}) {
    					Expr.pseudos[i] = createInputPseudo(i);
    				}
    				for (i in {
    						submit: true,
    						reset: true
    					}) {
    					Expr.pseudos[i] = createButtonPseudo(i);
    				}
    
    				// Easy API for creating new setFilters
    				function setFilters() {}
    				setFilters.prototype = Expr.filters = Expr.pseudos;
    				Expr.setFilters = new setFilters();
    
    				tokenize = Sizzle.tokenize = function(selector, parseOnly) {
    					var matched, match, tokens, type,
    						soFar, groups, preFilters,
    						cached = tokenCache[selector + " "];
    
    					if (cached) {
    						return parseOnly ? 0 : cached.slice(0);
    					}
    
    					soFar = selector;
    					groups = [];
    					preFilters = Expr.preFilter;
    
    					while (soFar) {
    
    						// Comma and first run
    						if (!matched || (match = rcomma.exec(soFar))) {
    							if (match) {
    								// Don't consume trailing commas as valid
    								soFar = soFar.slice(match[0].length) || soFar;
    							}
    							groups.push((tokens = []));
    						}
    
    						matched = false;
    
    						// Combinators
    						if ((match = rcombinators.exec(soFar))) {
    							matched = match.shift();
    							tokens.push({
    								value: matched,
    								// Cast descendant combinators to space
    								type: match[0].replace(rtrim, " ")
    							});
    							soFar = soFar.slice(matched.length);
    						}
    
    						// Filters
    						for (type in Expr.filter) {
    							if ((match = matchExpr[type].exec(soFar)) && (!preFilters[type] ||
    									(match = preFilters[type](match)))) {
    								matched = match.shift();
    								tokens.push({
    									value: matched,
    									type: type,
    									matches: match
    								});
    								soFar = soFar.slice(matched.length);
    							}
    						}
    
    						if (!matched) {
    							break;
    						}
    					}
    
    					// Return the length of the invalid excess
    					// if we're just parsing
    					// Otherwise, throw an error or return tokens
    					return parseOnly ?
    						soFar.length :
    						soFar ?
    						Sizzle.error(selector) :
    						// Cache the tokens
    						tokenCache(selector, groups).slice(0);
    				};
    
    				function toSelector(tokens) {
    					var i = 0,
    						len = tokens.length,
    						selector = "";
    					for (; i < len; i++) {
    						selector += tokens[i].value;
    					}
    					return selector;
    				}
    
    				function addCombinator(matcher, combinator, base) {
    					var dir = combinator.dir,
    						checkNonElements = base && dir === "parentNode",
    						doneName = done++;
    
    					return combinator.first ?
    						// Check against closest ancestor/preceding element
    						function(elem, context, xml) {
    							while ((elem = elem[dir])) {
    								if (elem.nodeType === 1 || checkNonElements) {
    									return matcher(elem, context, xml);
    								}
    							}
    						} :
    
    						// Check against all ancestor/preceding elements
    						function(elem, context, xml) {
    							var oldCache, outerCache,
    								newCache = [dirruns, doneName];
    
    							// We can't set arbitrary data on XML nodes, so they don't benefit from dir caching
    							if (xml) {
    								while ((elem = elem[dir])) {
    									if (elem.nodeType === 1 || checkNonElements) {
    										if (matcher(elem, context, xml)) {
    											return true;
    										}
    									}
    								}
    							} else {
    								while ((elem = elem[dir])) {
    									if (elem.nodeType === 1 || checkNonElements) {
    										outerCache = elem[expando] || (elem[expando] = {});
    										if ((oldCache = outerCache[dir]) &&
    											oldCache[0] === dirruns && oldCache[1] === doneName) {
    
    											// Assign to newCache so results back-propagate to previous elements
    											return (newCache[2] = oldCache[2]);
    										} else {
    											// Reuse newcache so results back-propagate to previous elements
    											outerCache[dir] = newCache;
    
    											// A match means we're done; a fail means we have to keep checking
    											if ((newCache[2] = matcher(elem, context, xml))) {
    												return true;
    											}
    										}
    									}
    								}
    							}
    						};
    				}
    
    				function elementMatcher(matchers) {
    					return matchers.length > 1 ?
    						function(elem, context, xml) {
    							var i = matchers.length;
    							while (i--) {
    								if (!matchers[i](elem, context, xml)) {
    									return false;
    								}
    							}
    							return true;
    						} :
    						matchers[0];
    				}
    
    				function multipleContexts(selector, contexts, results) {
    					var i = 0,
    						len = contexts.length;
    					for (; i < len; i++) {
    						Sizzle(selector, contexts[i], results);
    					}
    					return results;
    				}
    
    				function condense(unmatched, map, filter, context, xml) {
    					var elem,
    						newUnmatched = [],
    						i = 0,
    						len = unmatched.length,
    						mapped = map != null;
    
    					for (; i < len; i++) {
    						if ((elem = unmatched[i])) {
    							if (!filter || filter(elem, context, xml)) {
    								newUnmatched.push(elem);
    								if (mapped) {
    									map.push(i);
    								}
    							}
    						}
    					}
    
    					return newUnmatched;
    				}
    
    				function setMatcher(preFilter, selector, matcher, postFilter, postFinder, postSelector) {
    					if (postFilter && !postFilter[expando]) {
    						postFilter = setMatcher(postFilter);
    					}
    					if (postFinder && !postFinder[expando]) {
    						postFinder = setMatcher(postFinder, postSelector);
    					}
    					return markFunction(function(seed, results, context, xml) {
    						var temp, i, elem,
    							preMap = [],
    							postMap = [],
    							preexisting = results.length,
    
    							// Get initial elements from seed or context
    							elems = seed || multipleContexts(selector || "*", context.nodeType ? [context] : context, []),
    
    							// Prefilter to get matcher input, preserving a map for seed-results synchronization
    							matcherIn = preFilter && (seed || !selector) ?
    							condense(elems, preMap, preFilter, context, xml) :
    							elems,
    
    							matcherOut = matcher ?
    							// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
    							postFinder || (seed ? preFilter : preexisting || postFilter) ?
    
    							// ...intermediate processing is necessary
    							[] :
    
    							// ...otherwise use results directly
    							results :
    							matcherIn;
    
    						// Find primary matches
    						if (matcher) {
    							matcher(matcherIn, matcherOut, context, xml);
    						}
    
    						// Apply postFilter
    						if (postFilter) {
    							temp = condense(matcherOut, postMap);
    							postFilter(temp, [], context, xml);
    
    							// Un-match failing elements by moving them back to matcherIn
    							i = temp.length;
    							while (i--) {
    								if ((elem = temp[i])) {
    									matcherOut[postMap[i]] = !(matcherIn[postMap[i]] = elem);
    								}
    							}
    						}
    
    						if (seed) {
    							if (postFinder || preFilter) {
    								if (postFinder) {
    									// Get the final matcherOut by condensing this intermediate into postFinder contexts
    									temp = [];
    									i = matcherOut.length;
    									while (i--) {
    										if ((elem = matcherOut[i])) {
    											// Restore matcherIn since elem is not yet a final match
    											temp.push((matcherIn[i] = elem));
    										}
    									}
    									postFinder(null, (matcherOut = []), temp, xml);
    								}
    
    								// Move matched elements from seed to results to keep them synchronized
    								i = matcherOut.length;
    								while (i--) {
    									if ((elem = matcherOut[i]) &&
    										(temp = postFinder ? indexOf(seed, elem) : preMap[i]) > -1) {
    
    										seed[temp] = !(results[temp] = elem);
    									}
    								}
    							}
    
    							// Add elements to results, through postFinder if defined
    						} else {
    							matcherOut = condense(
    								matcherOut === results ?
    								matcherOut.splice(preexisting, matcherOut.length) :
    								matcherOut
    							);
    							if (postFinder) {
    								postFinder(null, results, matcherOut, xml);
    							} else {
    								push.apply(results, matcherOut);
    							}
    						}
    					});
    				}
    
    				function matcherFromTokens(tokens) {
    					var checkContext, matcher, j,
    						len = tokens.length,
    						leadingRelative = Expr.relative[tokens[0].type],
    						implicitRelative = leadingRelative || Expr.relative[" "],
    						i = leadingRelative ? 1 : 0,
    
    						// The foundational matcher ensures that elements are reachable from top-level context(s)
    						matchContext = addCombinator(function(elem) {
    							return elem === checkContext;
    						}, implicitRelative, true),
    						matchAnyContext = addCombinator(function(elem) {
    							return indexOf(checkContext, elem) > -1;
    						}, implicitRelative, true),
    						matchers = [function(elem, context, xml) {
    							var ret = (!leadingRelative && (xml || context !== outermostContext)) || (
    								(checkContext = context).nodeType ?
    								matchContext(elem, context, xml) :
    								matchAnyContext(elem, context, xml));
    							// Avoid hanging onto element (issue #299)
    							checkContext = null;
    							return ret;
    						}];
    
    					for (; i < len; i++) {
    						if ((matcher = Expr.relative[tokens[i].type])) {
    							matchers = [addCombinator(elementMatcher(matchers), matcher)];
    						} else {
    							matcher = Expr.filter[tokens[i].type].apply(null, tokens[i].matches);
    
    							// Return special upon seeing a positional matcher
    							if (matcher[expando]) {
    								// Find the next relative operator (if any) for proper handling
    								j = ++i;
    								for (; j < len; j++) {
    									if (Expr.relative[tokens[j].type]) {
    										break;
    									}
    								}
    								return setMatcher(
    									i > 1 && elementMatcher(matchers),
    									i > 1 && toSelector(
    										// If the preceding token was a descendant combinator, insert an implicit any-element `*`
    										tokens.slice(0, i - 1).concat({
    											value: tokens[i - 2].type === " " ? "*" : ""
    										})
    									).replace(rtrim, "$1"),
    									matcher,
    									i < j && matcherFromTokens(tokens.slice(i, j)),
    									j < len && matcherFromTokens((tokens = tokens.slice(j))),
    									j < len && toSelector(tokens)
    								);
    							}
    							matchers.push(matcher);
    						}
    					}
    
    					return elementMatcher(matchers);
    				}
    
    				function matcherFromGroupMatchers(elementMatchers, setMatchers) {
    					var bySet = setMatchers.length > 0,
    						byElement = elementMatchers.length > 0,
    						superMatcher = function(seed, context, xml, results, outermost) {
    							var elem, j, matcher,
    								matchedCount = 0,
    								i = "0",
    								unmatched = seed && [],
    								setMatched = [],
    								contextBackup = outermostContext,
    								// We must always have either seed elements or outermost context
    								elems = seed || byElement && Expr.find["TAG"]("*", outermost),
    								// Use integer dirruns iff this is the outermost matcher
    								dirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),
    								len = elems.length;
    
    							if (outermost) {
    								outermostContext = context !== document && context;
    							}
    
    							// Add elements passing elementMatchers directly to results
    							// Keep `i` a string if there are no elements so `matchedCount` will be "00" below
    							// Support: IE<9, Safari
    							// Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id
    							for (; i !== len && (elem = elems[i]) != null; i++) {
    								if (byElement && elem) {
    									j = 0;
    									while ((matcher = elementMatchers[j++])) {
    										if (matcher(elem, context, xml)) {
    											results.push(elem);
    											break;
    										}
    									}
    									if (outermost) {
    										dirruns = dirrunsUnique;
    									}
    								}
    
    								// Track unmatched elements for set filters
    								if (bySet) {
    									// They will have gone through all possible matchers
    									if ((elem = !matcher && elem)) {
    										matchedCount--;
    									}
    
    									// Lengthen the array for every element, matched or not
    									if (seed) {
    										unmatched.push(elem);
    									}
    								}
    							}
    
    							// Apply set filters to unmatched elements
    							matchedCount += i;
    							if (bySet && i !== matchedCount) {
    								j = 0;
    								while ((matcher = setMatchers[j++])) {
    									matcher(unmatched, setMatched, context, xml);
    								}
    
    								if (seed) {
    									// Reintegrate element matches to eliminate the need for sorting
    									if (matchedCount > 0) {
    										while (i--) {
    											if (!(unmatched[i] || setMatched[i])) {
    												setMatched[i] = pop.call(results);
    											}
    										}
    									}
    
    									// Discard index placeholder values to get only actual matches
    									setMatched = condense(setMatched);
    								}
    
    								// Add matches to results
    								push.apply(results, setMatched);
    
    								// Seedless set matches succeeding multiple successful matchers stipulate sorting
    								if (outermost && !seed && setMatched.length > 0 &&
    									(matchedCount + setMatchers.length) > 1) {
    
    									Sizzle.uniqueSort(results);
    								}
    							}
    
    							// Override manipulation of globals by nested matchers
    							if (outermost) {
    								dirruns = dirrunsUnique;
    								outermostContext = contextBackup;
    							}
    
    							return unmatched;
    						};
    
    					return bySet ?
    						markFunction(superMatcher) :
    						superMatcher;
    				}
    
    				compile = Sizzle.compile = function(selector, match  ) {
    					var i,
    						setMatchers = [],
    						elementMatchers = [],
    						cached = compilerCache[selector + " "];
    
    					if (!cached) {
    						// Generate a function of recursive functions that can be used to check each element
    						if (!match) {
    							match = tokenize(selector);
    						}
    						i = match.length;
    						while (i--) {
    							cached = matcherFromTokens(match[i]);
    							if (cached[expando]) {
    								setMatchers.push(cached);
    							} else {
    								elementMatchers.push(cached);
    							}
    						}
    
    						// Cache the compiled function
    						cached = compilerCache(selector, matcherFromGroupMatchers(elementMatchers, setMatchers));
    
    						// Save selector and tokenization
    						cached.selector = selector;
    					}
    					return cached;
    				};
    
    				
    				select = Sizzle.select = function(selector, context, results, seed) {
    					var i, tokens, token, type, find,
    						compiled = typeof selector === "function" && selector,
    						match = !seed && tokenize((selector = compiled.selector || selector));
    
    					results = results || [];
    
    					// Try to minimize operations if there is no seed and only one group
    					if (match.length === 1) {
    
    						// Take a shortcut and set the context if the root selector is an ID
    						tokens = match[0] = match[0].slice(0);
    						if (tokens.length > 2 && (token = tokens[0]).type === "ID" &&
    							support.getById && context.nodeType === 9 && documentIsHTML &&
    							Expr.relative[tokens[1].type]) {
    
    							context = (Expr.find["ID"](token.matches[0].replace(runescape, funescape), context) || [])[0];
    							if (!context) {
    								return results;
    
    								// Precompiled matchers will still verify ancestry, so step up a level
    							} else if (compiled) {
    								context = context.parentNode;
    							}
    
    							selector = selector.slice(tokens.shift().value.length);
    						}
    
    						// Fetch a seed set for right-to-left matching
    						i = matchExpr["needsContext"].test(selector) ? 0 : tokens.length;
    						while (i--) {
    							token = tokens[i];
    
    							// Abort if we hit a combinator
    							if (Expr.relative[(type = token.type)]) {
    								break;
    							}
    							if ((find = Expr.find[type])) {
    								// Search, expanding context for leading sibling combinators
    								if ((seed = find(
    										token.matches[0].replace(runescape, funescape),
    										rsibling.test(tokens[0].type) && testContext(context.parentNode) || context
    									))) {
    
    									// If seed is empty or no tokens remain, we can return early
    									tokens.splice(i, 1);
    									selector = seed.length && toSelector(tokens);
    									if (!selector) {
    										push.apply(results, seed);
    										return results;
    									}
    
    									break;
    								}
    							}
    						}
    					}
    
    					// Compile and execute a filtering function if one is not provided
    					// Provide `match` to avoid retokenization if we modified the selector above
    					(compiled || compile(selector, match))(
    						seed,
    						context, !documentIsHTML,
    						results,
    						rsibling.test(selector) && testContext(context.parentNode) || context
    					);
    					return results;
    				};
    
    				// One-time assignments
    
    				// Sort stability
    				support.sortStable = expando.split("").sort(sortOrder).join("") === expando;
    
    				// Support: Chrome 14-35+
    				// Always assume duplicates if they aren't passed to the comparison function
    				support.detectDuplicates = !!hasDuplicate;
    
    				// Initialize against the default document
    				setDocument();
    
    				// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
    				// Detached nodes confoundingly follow *each other*
    				support.sortDetached = assert(function(div1) {
    					// Should return 1, but returns 4 (following)
    					return div1.compareDocumentPosition(document.createElement("div")) & 1;
    				});
    
    				// Support: IE<8
    				// Prevent attribute/property "interpolation"
    				// http://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
    				if (!assert(function(div) {
    						div.innerHTML = "<a href='#'></a>";
    						return div.firstChild.getAttribute("href") === "#";
    					})) {
    					addHandle("type|href|height|width", function(elem, name, isXML) {
    						if (!isXML) {
    							return elem.getAttribute(name, name.toLowerCase() === "type" ? 1 : 2);
    						}
    					});
    				}
    
    				// Support: IE<9
    				// Use defaultValue in place of getAttribute("value")
    				if (!support.attributes || !assert(function(div) {
    						div.innerHTML = "<input/>";
    						div.firstChild.setAttribute("value", "");
    						return div.firstChild.getAttribute("value") === "";
    					})) {
    					addHandle("value", function(elem, name, isXML) {
    						if (!isXML && elem.nodeName.toLowerCase() === "input") {
    							return elem.defaultValue;
    						}
    					});
    				}
    
    				// Support: IE<9
    				// Use getAttributeNode to fetch booleans when getAttribute lies
    				if (!assert(function(div) {
    						return div.getAttribute("disabled") == null;
    					})) {
    					addHandle(booleans, function(elem, name, isXML) {
    						var val;
    						if (!isXML) {
    							return elem[name] === true ? name.toLowerCase() :
    								(val = elem.getAttributeNode(name)) && val.specified ?
    								val.value :
    								null;
    						}
    					});
    				}
    
    				return Sizzle;
    
    			})(window);
    
    
    
    		jQuery.find = Sizzle;
    		jQuery.expr = Sizzle.selectors;
    		jQuery.expr[":"] = jQuery.expr.pseudos;
    		jQuery.unique = Sizzle.uniqueSort;
    		jQuery.text = Sizzle.getText;
    		jQuery.isXMLDoc = Sizzle.isXML;
    		jQuery.contains = Sizzle.contains;
    
    
    
    		var rneedsContext = jQuery.expr.match.needsContext;
    
    		var rsingleTag = (/^<(\w+)\s*\/?>(?:<\/\1>|)$/);
    
    
    
    		var risSimple = /^.[^:#\[\.,]*$/;
    
    		// Implement the identical functionality for filter and not
    		function winnow(elements, qualifier, not) {
    			if (jQuery.isFunction(qualifier)) {
    				return jQuery.grep(elements, function(elem, i) {
    					
    					return !!qualifier.call(elem, i, elem) !== not;
    				});
    
    			}
    
    			if (qualifier.nodeType) {
    				return jQuery.grep(elements, function(elem) {
    					return (elem === qualifier) !== not;
    				});
    
    			}
    
    			if (typeof qualifier === "string") {
    				if (risSimple.test(qualifier)) {
    					return jQuery.filter(qualifier, elements, not);
    				}
    
    				qualifier = jQuery.filter(qualifier, elements);
    			}
    
    			return jQuery.grep(elements, function(elem) {
    				return (indexOf.call(qualifier, elem) >= 0) !== not;
    			});
    		}
    
    		jQuery.filter = function(expr, elems, not) {
    			var elem = elems[0];
    
    			if (not) {
    				expr = ":not(" + expr + ")";
    			}
    
    			return elems.length === 1 && elem.nodeType === 1 ?
    				jQuery.find.matchesSelector(elem, expr) ? [elem] : [] :
    				jQuery.find.matches(expr, jQuery.grep(elems, function(elem) {
    					return elem.nodeType === 1;
    				}));
    		};
    
    		jQuery.fn.extend({
    			find: function(selector) {
    				var i,
    					len = this.length,
    					ret = [],
    					self = this;
    
    				if (typeof selector !== "string") {
    					return this.pushStack(jQuery(selector).filter(function() {
    						for (i = 0; i < len; i++) {
    							if (jQuery.contains(self[i], this)) {
    								return true;
    							}
    						}
    					}));
    				}
    
    				for (i = 0; i < len; i++) {
    					jQuery.find(selector, self[i], ret);
    				}
    
    				// Needed because $( selector, context ) becomes $( context ).find( selector )
    				ret = this.pushStack(len > 1 ? jQuery.unique(ret) : ret);
    				ret.selector = this.selector ? this.selector + " " + selector : selector;
    				return ret;
    			},
    			filter: function(selector) {
    				return this.pushStack(winnow(this, selector || [], false));
    			},
    			not: function(selector) {
    				return this.pushStack(winnow(this, selector || [], true));
    			},
    			is: function(selector) {
    				return !!winnow(
    					this,
    
    					// If this is a positional/relative selector, check membership in the returned set
    					// so $("p:first").is("p:last") won't return true for a doc with two "p".
    					typeof selector === "string" && rneedsContext.test(selector) ?
    					jQuery(selector) :
    					selector || [],
    					false
    				).length;
    			}
    		});
    
    
    		// Initialize a jQuery object
    
    
    		// A central reference to the root jQuery(document)
    		var rootjQuery,
    
    			// A simple way to check for HTML strings
    			// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
    			// Strict HTML recognition (#11290: must start with <)
    			rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]*))$/,
    
    			init = jQuery.fn.init = function(selector, context) {
    				var match, elem;
    
    				// HANDLE: $(""), $(null), $(undefined), $(false)
    				if (!selector) {
    					return this;
    				}
    
    				// Handle HTML strings
    				if (typeof selector === "string") {
    					if (selector[0] === "<" && selector[selector.length - 1] === ">" && selector.length >= 3) {
    						// Assume that strings that start and end with <> are HTML and skip the regex check
    						match = [null, selector, null];
    
    					} else {
    						match = rquickExpr.exec(selector);
    					}
    
    					// Match html or make sure no context is specified for #id
    					if (match && (match[1] || !context)) {
    
    						// HANDLE: $(html) -> $(array)
    						if (match[1]) {
    							context = context instanceof jQuery ? context[0] : context;
    
    							// Option to run scripts is true for back-compat
    							// Intentionally let the error be thrown if parseHTML is not present
    							jQuery.merge(this, jQuery.parseHTML(
    								match[1],
    								context && context.nodeType ? context.ownerDocument || context : document,
    								true
    							));
    
    							// HANDLE: $(html, props)
    							if (rsingleTag.test(match[1]) && jQuery.isPlainObject(context)) {
    								for (match in context) {
    									// Properties of context are called as methods if possible
    									if (jQuery.isFunction(this[match])) {
    										this[match](context[match]);
    
    										// ...and otherwise set as attributes
    									} else {
    										this.attr(match, context[match]);
    									}
    								}
    							}
    
    							return this;
    
    							// HANDLE: $(#id)
    						} else {
    							elem = document.getElementById(match[2]);
    
    							// Support: Blackberry 4.6
    							// gEBID returns nodes no longer in the document (#6963)
    							if (elem && elem.parentNode) {
    								// Inject the element directly into the jQuery object
    								this.length = 1;
    								this[0] = elem;
    							}
    
    							this.context = document;
    							this.selector = selector;
    							return this;
    						}
    
    						// HANDLE: $(expr, $(...))
    					} else if (!context || context.jquery) {
    						return (context || rootjQuery).find(selector);
    
    						// HANDLE: $(expr, context)
    						// (which is just equivalent to: $(context).find(expr)
    					} else {
    						return this.constructor(context).find(selector);
    					}
    
    					// HANDLE: $(DOMElement)
    				} else if (selector.nodeType) {
    					this.context = this[0] = selector;
    					this.length = 1;
    					return this;
    
    					// HANDLE: $(function)
    					// Shortcut for document ready
    				} else if (jQuery.isFunction(selector)) {
    					return typeof rootjQuery.ready !== "undefined" ?
    						rootjQuery.ready(selector) :
    						// Execute immediately if ready is not present
    						selector(jQuery);
    				}
    
    				if (selector.selector !== undefined) {
    					this.selector = selector.selector;
    					this.context = selector.context;
    				}
    
    				return jQuery.makeArray(selector, this);
    			};
    
    		// Give the init function the jQuery prototype for later instantiation
    		init.prototype = jQuery.fn;
    
    		// Initialize central reference
    		rootjQuery = jQuery(document);
    
    
    		var rparentsprev = /^(?:parents|prev(?:Until|All))/,
    			// Methods guaranteed to produce a unique set when starting from a unique set
    			guaranteedUnique = {
    				children: true,
    				contents: true,
    				next: true,
    				prev: true
    			};
    
    		jQuery.extend({
    			dir: function(elem, dir, until) {
    				var matched = [],
    					truncate = until !== undefined;
    
    				while ((elem = elem[dir]) && elem.nodeType !== 9) {
    					if (elem.nodeType === 1) {
    						if (truncate && jQuery(elem).is(until)) {
    							break;
    						}
    						matched.push(elem);
    					}
    				}
    				return matched;
    			},
    
    			sibling: function(n, elem) {
    				var matched = [];
    
    				for (; n; n = n.nextSibling) {
    					if (n.nodeType === 1 && n !== elem) {
    						matched.push(n);
    					}
    				}
    
    				return matched;
    			}
    		});
    
    		jQuery.fn.extend({
    			has: function(target) {
    				var targets = jQuery(target, this),
    					l = targets.length;
    
    				return this.filter(function() {
    					var i = 0;
    					for (; i < l; i++) {
    						if (jQuery.contains(this, targets[i])) {
    							return true;
    						}
    					}
    				});
    			},
    
    			closest: function(selectors, context) {
    				var cur,
    					i = 0,
    					l = this.length,
    					matched = [],
    					pos = rneedsContext.test(selectors) || typeof selectors !== "string" ?
    					jQuery(selectors, context || this.context) :
    					0;
    
    				for (; i < l; i++) {
    					for (cur = this[i]; cur && cur !== context; cur = cur.parentNode) {
    						// Always skip document fragments
    						if (cur.nodeType < 11 && (pos ?
    								pos.index(cur) > -1 :
    
    								// Don't pass non-elements to Sizzle
    								cur.nodeType === 1 &&
    								jQuery.find.matchesSelector(cur, selectors))) {
    
    							matched.push(cur);
    							break;
    						}
    					}
    				}
    
    				return this.pushStack(matched.length > 1 ? jQuery.unique(matched) : matched);
    			},
    
    			// Determine the position of an element within the set
    			index: function(elem) {
    
    				// No argument, return index in parent
    				if (!elem) {
    					return (this[0] && this[0].parentNode) ? this.first().prevAll().length : -1;
    				}
    
    				// Index in selector
    				if (typeof elem === "string") {
    					return indexOf.call(jQuery(elem), this[0]);
    				}
    
    				// Locate the position of the desired element
    				return indexOf.call(this,
    
    					// If it receives a jQuery object, the first element is used
    					elem.jquery ? elem[0] : elem
    				);
    			},
    
    			add: function(selector, context) {
    				return this.pushStack(
    					jQuery.unique(
    						jQuery.merge(this.get(), jQuery(selector, context))
    					)
    				);
    			},
    
    			addBack: function(selector) {
    				return this.add(selector == null ?
    					this.prevObject : this.prevObject.filter(selector)
    				);
    			}
    		});
    
    		function sibling(cur, dir) {
    			while ((cur = cur[dir]) && cur.nodeType !== 1) {}
    			return cur;
    		}
    
    		jQuery.each({
    			parent: function(elem) {
    				var parent = elem.parentNode;
    				return parent && parent.nodeType !== 11 ? parent : null;
    			},
    			parents: function(elem) {
    				return jQuery.dir(elem, "parentNode");
    			},
    			parentsUntil: function(elem, i, until) {
    				return jQuery.dir(elem, "parentNode", until);
    			},
    			next: function(elem) {
    				return sibling(elem, "nextSibling");
    			},
    			prev: function(elem) {
    				return sibling(elem, "previousSibling");
    			},
    			nextAll: function(elem) {
    				return jQuery.dir(elem, "nextSibling");
    			},
    			prevAll: function(elem) {
    				return jQuery.dir(elem, "previousSibling");
    			},
    			nextUntil: function(elem, i, until) {
    				return jQuery.dir(elem, "nextSibling", until);
    			},
    			prevUntil: function(elem, i, until) {
    				return jQuery.dir(elem, "previousSibling", until);
    			},
    			siblings: function(elem) {
    				return jQuery.sibling((elem.parentNode || {}).firstChild, elem);
    			},
    			children: function(elem) {
    				return jQuery.sibling(elem.firstChild);
    			},
    			contents: function(elem) {
    				return elem.contentDocument || jQuery.merge([], elem.childNodes);
    			}
    		}, function(name, fn) {
    			jQuery.fn[name] = function(until, selector) {
    				var matched = jQuery.map(this, fn, until);
    
    				if (name.slice(-5) !== "Until") {
    					selector = until;
    				}
    
    				if (selector && typeof selector === "string") {
    					matched = jQuery.filter(selector, matched);
    				}
    
    				if (this.length > 1) {
    					// Remove duplicates
    					if (!guaranteedUnique[name]) {
    						jQuery.unique(matched);
    					}
    
    					// Reverse order for parents* and prev-derivatives
    					if (rparentsprev.test(name)) {
    						matched.reverse();
    					}
    				}
    
    				return this.pushStack(matched);
    			};
    		});
    		var rnotwhite = (/\S+/g);
    
    
    
    		// String to Object options format cache
    		var optionsCache = {};
    
    		// Convert String-formatted options into Object-formatted ones and store in cache
    		function createOptions(options) {
    			var object = optionsCache[options] = {};
    			jQuery.each(options.match(rnotwhite) || [], function(_, flag) {
    				object[flag] = true;
    			});
    			return object;
    		}
    
    		
    		jQuery.Callbacks = function(options) {
    
    			// Convert options from String-formatted to Object-formatted if needed
    			// (we check in cache first)
    			options = typeof options === "string" ?
    				(optionsCache[options] || createOptions(options)) :
    				jQuery.extend({}, options);
    
    			var // Last fire value (for non-forgettable lists)
    				memory,
    				// Flag to know if list was already fired
    				fired,
    				// Flag to know if list is currently firing
    				firing,
    				// First callback to fire (used internally by add and fireWith)
    				firingStart,
    				// End of the loop when firing
    				firingLength,
    				// Index of currently firing callback (modified by remove if needed)
    				firingIndex,
    				// Actual callback list
    				list = [],
    				// Stack of fire calls for repeatable lists
    				stack = !options.once && [],
    				// Fire callbacks
    				fire = function(data) {
    					memory = options.memory && data;
    					fired = true;
    					firingIndex = firingStart || 0;
    					firingStart = 0;
    					firingLength = list.length;
    					firing = true;
    					for (; list && firingIndex < firingLength; firingIndex++) {
    						if (list[firingIndex].apply(data[0], data[1]) === false && options.stopOnFalse) {
    							memory = false; // To prevent further calls using add
    							break;
    						}
    					}
    					firing = false;
    					if (list) {
    						if (stack) {
    							if (stack.length) {
    								fire(stack.shift());
    							}
    						} else if (memory) {
    							list = [];
    						} else {
    							self.disable();
    						}
    					}
    				},
    				// Actual Callbacks object
    				self = {
    					// Add a callback or a collection of callbacks to the list
    					add: function() {
    						if (list) {
    							// First, we save the current length
    							var start = list.length;
    							(function add(args) {
    								jQuery.each(args, function(_, arg) {
    									var type = jQuery.type(arg);
    									if (type === "function") {
    										if (!options.unique || !self.has(arg)) {
    											list.push(arg);
    										}
    									} else if (arg && arg.length && type !== "string") {
    										// Inspect recursively
    										add(arg);
    									}
    								});
    							})(arguments);
    							// Do we need to add the callbacks to the
    							// current firing batch?
    							if (firing) {
    								firingLength = list.length;
    								// With memory, if we're not firing then
    								// we should call right away
    							} else if (memory) {
    								firingStart = start;
    								fire(memory);
    							}
    						}
    						return this;
    					},
    					// Remove a callback from the list
    					remove: function() {
    						if (list) {
    							jQuery.each(arguments, function(_, arg) {
    								var index;
    								while ((index = jQuery.inArray(arg, list, index)) > -1) {
    									list.splice(index, 1);
    									// Handle firing indexes
    									if (firing) {
    										if (index <= firingLength) {
    											firingLength--;
    										}
    										if (index <= firingIndex) {
    											firingIndex--;
    										}
    									}
    								}
    							});
    						}
    						return this;
    					},
    					// Check if a given callback is in the list.
    					// If no argument is given, return whether or not list has callbacks attached.
    					has: function(fn) {
    						return fn ? jQuery.inArray(fn, list) > -1 : !!(list && list.length);
    					},
    					// Remove all callbacks from the list
    					empty: function() {
    						list = [];
    						firingLength = 0;
    						return this;
    					},
    					// Have the list do nothing anymore
    					disable: function() {
    						list = stack = memory = undefined;
    						return this;
    					},
    					// Is it disabled?
    					disabled: function() {
    						return !list;
    					},
    					// Lock the list in its current state
    					lock: function() {
    						stack = undefined;
    						if (!memory) {
    							self.disable();
    						}
    						return this;
    					},
    					// Is it locked?
    					locked: function() {
    						return !stack;
    					},
    					// Call all callbacks with the given context and arguments
    					fireWith: function(context, args) {
    						if (list && (!fired || stack)) {
    							args = args || [];
    							args = [context, args.slice ? args.slice() : args];
    							if (firing) {
    								stack.push(args);
    							} else {
    								fire(args);
    							}
    						}
    						return this;
    					},
    					// Call all the callbacks with the given arguments
    					fire: function() {
    						self.fireWith(this, arguments);
    						return this;
    					},
    					// To know if the callbacks have already been called at least once
    					fired: function() {
    						return !!fired;
    					}
    				};
    
    			return self;
    		};
    
    
    		jQuery.extend({
    
    			Deferred: function(func) {
    				var tuples = [
    						// action, add listener, listener list, final state
    						["resolve", "done", jQuery.Callbacks("once memory"), "resolved"],
    						["reject", "fail", jQuery.Callbacks("once memory"), "rejected"],
    						["notify", "progress", jQuery.Callbacks("memory")]
    					],
    					state = "pending",
    					promise = {
    						state: function() {
    							return state;
    						},
    						always: function() {
    							deferred.done(arguments).fail(arguments);
    							return this;
    						},
    						then: function(  ) {
    							var fns = arguments;
    							return jQuery.Deferred(function(newDefer) {
    								jQuery.each(tuples, function(i, tuple) {
    									var fn = jQuery.isFunction(fns[i]) && fns[i];
    									// deferred[ done | fail | progress ] for forwarding actions to newDefer
    									deferred[tuple[1]](function() {
    										var returned = fn && fn.apply(this, arguments);
    										if (returned && jQuery.isFunction(returned.promise)) {
    											returned.promise()
    												.done(newDefer.resolve)
    												.fail(newDefer.reject)
    												.progress(newDefer.notify);
    										} else {
    											newDefer[tuple[0] + "With"](this === promise ? newDefer.promise() : this, fn ? [returned] : arguments);
    										}
    									});
    								});
    								fns = null;
    							}).promise();
    						},
    						// Get a promise for this deferred
    						// If obj is provided, the promise aspect is added to the object
    						promise: function(obj) {
    							return obj != null ? jQuery.extend(obj, promise) : promise;
    						}
    					},
    					deferred = {};
    
    				// Keep pipe for back-compat
    				promise.pipe = promise.then;
    
    				// Add list-specific methods
    				jQuery.each(tuples, function(i, tuple) {
    					var list = tuple[2],
    						stateString = tuple[3];
    
    					// promise[ done | fail | progress ] = list.add
    					promise[tuple[1]] = list.add;
    
    					// Handle state
    					if (stateString) {
    						list.add(function() {
    							// state = [ resolved | rejected ]
    							state = stateString;
    
    							// [ reject_list | resolve_list ].disable; progress_list.lock
    						}, tuples[i ^ 1][2].disable, tuples[2][2].lock);
    					}
    
    					// deferred[ resolve | reject | notify ]
    					deferred[tuple[0]] = function() {
    						deferred[tuple[0] + "With"](this === deferred ? promise : this, arguments);
    						return this;
    					};
    					deferred[tuple[0] + "With"] = list.fireWith;
    				});
    
    				// Make the deferred a promise
    				promise.promise(deferred);
    
    				// Call given func if any
    				if (func) {
    					func.call(deferred, deferred);
    				}
    
    				// All done!
    				return deferred;
    			},
    
    			// Deferred helper
    			when: function(subordinate  ) {
    				var i = 0,
    					resolveValues = slice.call(arguments),
    					length = resolveValues.length,
    
    					// the count of uncompleted subordinates
    					remaining = length !== 1 || (subordinate && jQuery.isFunction(subordinate.promise)) ? length : 0,
    
    					// the master Deferred. If resolveValues consist of only a single Deferred, just use that.
    					deferred = remaining === 1 ? subordinate : jQuery.Deferred(),
    
    					// Update function for both resolve and progress values
    					updateFunc = function(i, contexts, values) {
    						return function(value) {
    							contexts[i] = this;
    							values[i] = arguments.length > 1 ? slice.call(arguments) : value;
    							if (values === progressValues) {
    								deferred.notifyWith(contexts, values);
    							} else if (!(--remaining)) {
    								deferred.resolveWith(contexts, values);
    							}
    						};
    					},
    
    					progressValues, progressContexts, resolveContexts;
    
    				// Add listeners to Deferred subordinates; treat others as resolved
    				if (length > 1) {
    					progressValues = new Array(length);
    					progressContexts = new Array(length);
    					resolveContexts = new Array(length);
    					for (; i < length; i++) {
    						if (resolveValues[i] && jQuery.isFunction(resolveValues[i].promise)) {
    							resolveValues[i].promise()
    								.done(updateFunc(i, resolveContexts, resolveValues))
    								.fail(deferred.reject)
    								.progress(updateFunc(i, progressContexts, progressValues));
    						} else {
    							--remaining;
    						}
    					}
    				}
    
    				// If we're not waiting on anything, resolve the master
    				if (!remaining) {
    					deferred.resolveWith(resolveContexts, resolveValues);
    				}
    
    				return deferred.promise();
    			}
    		});
    
    
    		// The deferred used on DOM ready
    		var readyList;
    
    		jQuery.fn.ready = function(fn) {
    			// Add the callback
    			jQuery.ready.promise().done(fn);
    
    			return this;
    		};
    
    		jQuery.extend({
    			// Is the DOM ready to be used? Set to true once it occurs.
    			isReady: false,
    
    			// A counter to track how many items to wait for before
    			// the ready event fires. See #6781
    			readyWait: 1,
    
    			// Hold (or release) the ready event
    			holdReady: function(hold) {
    				if (hold) {
    					jQuery.readyWait++;
    				} else {
    					jQuery.ready(true);
    				}
    			},
    
    			// Handle when the DOM is ready
    			ready: function(wait) {
    
    				// Abort if there are pending holds or we're already ready
    				if (wait === true ? --jQuery.readyWait : jQuery.isReady) {
    					return;
    				}
    
    				// Remember that the DOM is ready
    				jQuery.isReady = true;
    
    				// If a normal DOM Ready event fired, decrement, and wait if need be
    				if (wait !== true && --jQuery.readyWait > 0) {
    					return;
    				}
    
    				// If there are functions bound, to execute
    				readyList.resolveWith(document, [jQuery]);
    
    				// Trigger any bound ready events
    				if (jQuery.fn.triggerHandler) {
    					jQuery(document).triggerHandler("ready");
    					jQuery(document).off("ready");
    				}
    			}
    		});
    
    		
    		function completed() {
    			document.removeEventListener("DOMContentLoaded", completed, false);
    			window.removeEventListener("load", completed, false);
    			jQuery.ready();
    		}
    
    		jQuery.ready.promise = function(obj) {
    			if (!readyList) {
    
    				readyList = jQuery.Deferred();
    
    				// Catch cases where $(document).ready() is called after the browser event has already occurred.
    				// We once tried to use readyState "interactive" here, but it caused issues like the one
    				// discovered by ChrisS here: http://bugs.jquery.com/ticket/12282#comment:15
    				if (document.readyState === "complete") {
    					// Handle it asynchronously to allow scripts the opportunity to delay ready
    					setTimeout(jQuery.ready);
    
    				} else {
    
    					// Use the handy event callback
    					document.addEventListener("DOMContentLoaded", completed, false);
    
    					// A fallback to window.onload, that will always work
    					window.addEventListener("load", completed, false);
    				}
    			}
    			return readyList.promise(obj);
    		};
    
    		// Kick off the DOM ready check even if the user does not
    		jQuery.ready.promise();
    
    
    
    		// Multifunctional method to get and set values of a collection
    		// The value/s can optionally be executed if it's a function
    		var access = jQuery.access = function(elems, fn, key, value, chainable, emptyGet, raw) {
    			var i = 0,
    				len = elems.length,
    				bulk = key == null;
    
    			// Sets many values
    			if (jQuery.type(key) === "object") {
    				chainable = true;
    				for (i in key) {
    					jQuery.access(elems, fn, i, key[i], true, emptyGet, raw);
    				}
    
    				// Sets one value
    			} else if (value !== undefined) {
    				chainable = true;
    
    				if (!jQuery.isFunction(value)) {
    					raw = true;
    				}
    
    				if (bulk) {
    					// Bulk operations run against the entire set
    					if (raw) {
    						fn.call(elems, value);
    						fn = null;
    
    						// ...except when executing function values
    					} else {
    						bulk = fn;
    						fn = function(elem, key, value) {
    							return bulk.call(jQuery(elem), value);
    						};
    					}
    				}
    
    				if (fn) {
    					for (; i < len; i++) {
    						fn(elems[i], key, raw ? value : value.call(elems[i], i, fn(elems[i], key)));
    					}
    				}
    			}
    
    			return chainable ?
    				elems :
    
    				// Gets
    				bulk ?
    				fn.call(elems) :
    				len ? fn(elems[0], key) : emptyGet;
    		};
    
    
    		
    		jQuery.acceptData = function(owner) {
    			// Accepts only:
    			//  - Node
    			//    - Node.ELEMENT_NODE
    			//    - Node.DOCUMENT_NODE
    			//  - Object
    			//    - Any
    			
    			return owner.nodeType === 1 || owner.nodeType === 9 || !(+owner.nodeType);
    		};
    
    
    		function Data() {
    			// Support: Android<4,
    			// Old WebKit does not have Object.preventExtensions/freeze method,
    			// return new empty object instead with no [[set]] accessor
    			Object.defineProperty(this.cache = {}, 0, {
    				get: function() {
    					return {};
    				}
    			});
    
    			this.expando = jQuery.expando + Data.uid++;
    		}
    
    		Data.uid = 1;
    		Data.accepts = jQuery.acceptData;
    
    		Data.prototype = {
    			key: function(owner) {
    				// We can accept data for non-element nodes in modern browsers,
    				// but we should not, see #8335.
    				// Always return the key for a frozen object.
    				if (!Data.accepts(owner)) {
    					return 0;
    				}
    
    				var descriptor = {},
    					// Check if the owner object already has a cache key
    					unlock = owner[this.expando];
    
    				// If not, create one
    				if (!unlock) {
    					unlock = Data.uid++;
    
    					// Secure it in a non-enumerable, non-writable property
    					try {
    						descriptor[this.expando] = {
    							value: unlock
    						};
    						Object.defineProperties(owner, descriptor);
    
    						// Support: Android<4
    						// Fallback to a less secure definition
    					} catch (e) {
    						descriptor[this.expando] = unlock;
    						jQuery.extend(owner, descriptor);
    					}
    				}
    
    				// Ensure the cache object
    				if (!this.cache[unlock]) {
    					this.cache[unlock] = {};
    				}
    
    				return unlock;
    			},
    			set: function(owner, data, value) {
    				var prop,
    					// There may be an unlock assigned to this node,
    					// if there is no entry for this "owner", create one inline
    					// and set the unlock as though an owner entry had always existed
    					unlock = this.key(owner),
    					cache = this.cache[unlock];
    
    				// Handle: [ owner, key, value ] args
    				if (typeof data === "string") {
    					cache[data] = value;
    
    					// Handle: [ owner, { properties } ] args
    				} else {
    					// Fresh assignments by object are shallow copied
    					if (jQuery.isEmptyObject(cache)) {
    						f(this.cache[unlock], data);
    						// Otherwise, copy the properties one-by-one to the cache object
    					} else {
    						for (prop in data) {
    							cache[prop] = data[prop];
    						}
    					}
    				}
    				return cache;
    			},
    			get: function(owner, key) {
    				// Either a valid cache is found, or will be created.
    				// New caches will be created and the unlock returned,
    				// allowing direct access to the newly created
    				// empty data object. A valid owner object must be provided.
    				var cache = this.cache[this.key(owner)];
    
    				return key === undefined ?
    					cache : cache[key];
    			},
    			access: function(owner, key, value) {
    				var stored;
    				// In cases where either:
    				//
    				//   1. No key was specified
    				//   2. A string key was specified, but no value provided
    				//
    				// Take the "read" path and allow the get method to determine
    				// which value to return, respectively either:
    				//
    				//   1. The entire cache object
    				//   2. The data stored at the key
    				//
    				if (key === undefined ||
    					((key && typeof key === "string") && value === undefined)) {
    
    					stored = this.get(owner, key);
    
    					return stored !== undefined ?
    						stored : this.get(owner, jQuery.camelCase(key));
    				}
    
    				// [*]When the key is not a string, or both a key and value
    				// are specified, set or extend (existing objects) with either:
    				//
    				//   1. An object of properties
    				//   2. A key and value
    				//
    				this.set(owner, key, value);
    
    				// Since the "set" path can have two possible entry points
    				// return the expected data based on which path was taken[*]
    				return value !== undefined ? value : key;
    			},
    			remove: function(owner, key) {
    				var i, name, camel,
    					unlock = this.key(owner),
    					cache = this.cache[unlock];
    
    				if (key === undefined) {
    					this.cache[unlock] = {};
    
    				} else {
    					// Support array or space separated string of keys
    					if (jQuery.isArray(key)) {
    						// If "name" is an array of keys...
    						// When data is initially created, via ("key", "val") signature,
    						// keys will be converted to camelCase.
    						// Since there is no way to tell _how_ a key was added, remove
    						// both plain key and camelCase key. #12786
    						// This will only penalize the array argument path.
    						name = key.concat(key.map(jQuery.camelCase));
    					} else {
    						camel = jQuery.camelCase(key);
    						// Try the string as a key before any manipulation
    						if (key in cache) {
    							name = [key, camel];
    						} else {
    							// If a key with the spaces exists, use it.
    							// Otherwise, create an array by matching non-whitespace
    							name = camel;
    							name = name in cache ?
    								[name] : (name.match(rnotwhite) || []);
    						}
    					}
    
    					i = name.length;
    					while (i--) {
    						delete cache[name[i]];
    					}
    				}
    			},
    			hasData: function(owner) {
    				return !jQuery.isEmptyObject(
    					this.cache[owner[this.expando]] || {}
    				);
    			},
    			discard: function(owner) {
    				if (owner[this.expando]) {
    					delete this.cache[owner[this.expando]];
    				}
    			}
    		};
    		var data_priv = new Data();
    
    		var data_user = new Data();
    
    
    
    		//	Implementation Summary
    		//
    		//	1. Enforce API surface and semantic compatibility with 1.9.x branch
    		//	2. Improve the module's maintainability by reducing the storage
    		//		paths to a single mechanism.
    		//	3. Use the same single mechanism to support "private" and "user" data.
    		//	4. _Never_ expose "private" data to user code (TODO: Drop _data, _removeData)
    		//	5. Avoid exposing implementation details on user objects (eg. expando properties)
    		//	6. Provide a clear path for implementation upgrade to WeakMap in 2014
    
    		var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
    			rmultiDash = /([A-Z])/g;
    
    		function dataAttr(elem, key, data) {
    			var name;
    
    			// If nothing was found internally, try to fetch any
    			// data from the HTML5 data-* attribute
    			if (data === undefined && elem.nodeType === 1) {
    				name = "data-" + key.replace(rmultiDash, "-$1").toLowerCase();
    				data = elem.getAttribute(name);
    
    				if (typeof data === "string") {
    					try {
    						data = data === "true" ? true :
    							data === "false" ? false :
    							data === "null" ? null :
    							// Only convert to a number if it doesn't change the string
    							+data + "" === data ? +data :
    							rbrace.test(data) ? jQuery.parseJSON(data) :
    							data;
    					} catch (e) {}
    
    					// Make sure we set the data so it isn't changed later
    					data_user.set(elem, key, data);
    				} else {
    					data = undefined;
    				}
    			}
    			return data;
    		}
    
    		jQuery.extend({
    			hasData: function(elem) {
    				return data_user.hasData(elem) || data_priv.hasData(elem);
    			},
    
    			data: function(elem, name, data) {
    				return data_user.access(elem, name, data);
    			},
    
    			removeData: function(elem, name) {
    				data_user.remove(elem, name);
    			},
    
    			// TODO: Now that all calls to _data and _removeData have been replaced
    			// with direct calls to data_priv methods, these can be deprecated.
    			_data: function(elem, name, data) {
    				return data_priv.access(elem, name, data);
    			},
    
    			_removeData: function(elem, name) {
    				data_priv.remove(elem, name);
    			}
    		});
    
    		jQuery.fn.extend({
    			data: function(key, value) {
    				var i, name, data,
    					elem = this[0],
    					attrs = elem && elem.attributes;
    
    				// Gets all values
    				if (key === undefined) {
    					if (this.length) {
    						data = data_user.get(elem);
    
    						if (elem.nodeType === 1 && !data_priv.get(elem, "hasDataAttrs")) {
    							i = attrs.length;
    							while (i--) {
    
    								// Support: IE11+
    								// The attrs elements can be null (#14894)
    								if (attrs[i]) {
    									name = attrs[i].name;
    									if (name.indexOf("data-") === 0) {
    										name = jQuery.camelCase(name.slice(5));
    										dataAttr(elem, name, data[name]);
    									}
    								}
    							}
    							data_priv.set(elem, "hasDataAttrs", true);
    						}
    					}
    
    					return data;
    				}
    
    				// Sets multiple values
    				if (typeof key === "object") {
    					return this.each(function() {
    						data_user.set(this, key);
    					});
    				}
    
    				return access(this, function(value) {
    					var data,
    						camelKey = jQuery.camelCase(key);
    
    					// The calling jQuery object (element matches) is not empty
    					// (and therefore has an element appears at this[ 0 ]) and the
    					// `value` parameter was not undefined. An empty jQuery object
    					// will result in `undefined` for elem = this[ 0 ] which will
    					// throw an exception if an attempt to read a data cache is made.
    					if (elem && value === undefined) {
    						// Attempt to get data from the cache
    						// with the key as-is
    						data = data_user.get(elem, key);
    						if (data !== undefined) {
    							return data;
    						}
    
    						// Attempt to get data from the cache
    						// with the key camelized
    						data = data_user.get(elem, camelKey);
    						if (data !== undefined) {
    							return data;
    						}
    
    						// Attempt to "discover" the data in
    						// HTML5 custom data-* attrs
    						data = dataAttr(elem, camelKey, undefined);
    						if (data !== undefined) {
    							return data;
    						}
    
    						// We tried really hard, but the data doesn't exist.
    						return;
    					}
    
    					// Set the data...
    					this.each(function() {
    						// First, attempt to store a copy or reference of any
    						// data that might've been store with a camelCased key.
    						var data = data_user.get(this, camelKey);
    
    						// For HTML5 data-* attribute interop, we have to
    						// store property names with dashes in a camelCase form.
    						// This might not apply to all properties...*
    						data_user.set(this, camelKey, value);
    
    						// *... In the case of properties that might _actually_
    						// have dashes, we need to also store a copy of that
    						// unchanged property.
    						if (key.indexOf("-") !== -1 && data !== undefined) {
    							data_user.set(this, key, value);
    						}
    					});
    				}, null, value, arguments.length > 1, null, true);
    			},
    
    			removeData: function(key) {
    				return this.each(function() {
    					data_user.remove(this, key);
    				});
    			}
    		});
    
    
    		jQuery.extend({
    			queue: function(elem, type, data) {
    				var queue;
    
    				if (elem) {
    					type = (type || "fx") + "queue";
    					queue = data_priv.get(elem, type);
    
    					// Speed up dequeue by getting out quickly if this is just a lookup
    					if (data) {
    						if (!queue || jQuery.isArray(data)) {
    							queue = data_priv.access(elem, type, jQuery.makeArray(data));
    						} else {
    							queue.push(data);
    						}
    					}
    					return queue || [];
    				}
    			},
    
    			dequeue: function(elem, type) {
    				type = type || "fx";
    
    				var queue = jQuery.queue(elem, type),
    					startLength = queue.length,
    					fn = queue.shift(),
    					hooks = jQuery._queueHooks(elem, type),
    					next = function() {
    						jQuery.dequeue(elem, type);
    					};
    
    				// If the fx queue is dequeued, always remove the progress sentinel
    				if (fn === "inprogress") {
    					fn = queue.shift();
    					startLength--;
    				}
    
    				if (fn) {
    
    					// Add a progress sentinel to prevent the fx queue from being
    					// automatically dequeued
    					if (type === "fx") {
    						queue.unshift("inprogress");
    					}
    
    					// Clear up the last queue stop function
    					delete hooks.stop;
    					fn.call(elem, next, hooks);
    				}
    
    				if (!startLength && hooks) {
    					hooks.empty.fire();
    				}
    			},
    
    			// Not public - generate a queueHooks object, or return the current one
    			_queueHooks: function(elem, type) {
    				var key = type + "queueHooks";
    				return data_priv.get(elem, key) || data_priv.access(elem, key, {
    					empty: jQuery.Callbacks("once memory").add(function() {
    						data_priv.remove(elem, [type + "queue", key]);
    					})
    				});
    			}
    		});
    
    		jQuery.fn.extend({
    			queue: function(type, data) {
    				var setter = 2;
    
    				if (typeof type !== "string") {
    					data = type;
    					type = "fx";
    					setter--;
    				}
    
    				if (arguments.length < setter) {
    					return jQuery.queue(this[0], type);
    				}
    
    				return data === undefined ?
    					this :
    					this.each(function() {
    						var queue = jQuery.queue(this, type, data);
    
    						// Ensure a hooks for this queue
    						jQuery._queueHooks(this, type);
    
    						if (type === "fx" && queue[0] !== "inprogress") {
    							jQuery.dequeue(this, type);
    						}
    					});
    			},
    			dequeue: function(type) {
    				return this.each(function() {
    					jQuery.dequeue(this, type);
    				});
    			},
    			clearQueue: function(type) {
    				return this.queue(type || "fx", []);
    			},
    			// Get a promise resolved when queues of a certain type
    			// are emptied (fx is the type by default)
    			promise: function(type, obj) {
    				var tmp,
    					count = 1,
    					defer = jQuery.Deferred(),
    					elements = this,
    					i = this.length,
    					resolve = function() {
    						if (!(--count)) {
    							defer.resolveWith(elements, [elements]);
    						}
    					};
    
    				if (typeof type !== "string") {
    					obj = type;
    					type = undefined;
    				}
    				type = type || "fx";
    
    				while (i--) {
    					tmp = data_priv.get(elements[i], type + "queueHooks");
    					if (tmp && tmp.empty) {
    						count++;
    						tmp.empty.add(resolve);
    					}
    				}
    				resolve();
    				return defer.promise(obj);
    			}
    		});
    		var pnum = (/[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/).source;
    
    		var cssExpand = ["Top", "Right", "Bottom", "Left"];
    
    		var isHidden = function(elem, el) {
    			// isHidden might be called from jQuery#filter function;
    			// in that case, element will be second argument
    			elem = el || elem;
    			return jQuery.css(elem, "display") === "none" || !jQuery.contains(elem.ownerDocument, elem);
    		};
    
    		var rcheckableType = (/^(?:checkbox|radio)$/i);
    
    
    
    		(function() {
    			var fragment = document.createDocumentFragment(),
    				div = fragment.appendChild(document.createElement("div")),
    				input = document.createElement("input");
    
    			// Support: Safari<=5.1
    			// Check state lost if the name is set (#11217)
    			// Support: Windows Web Apps (WWA)
    			// `name` and `type` must use .setAttribute for WWA (#14901)
    			input.setAttribute("type", "radio");
    			input.setAttribute("checked", "checked");
    			input.setAttribute("name", "t");
    
    			div.appendChild(input);
    
    			// Support: Safari<=5.1, Android<4.2
    			// Older WebKit doesn't clone checked state correctly in fragments
    			support.checkClone = div.cloneNode(true).cloneNode(true).lastChild.checked;
    
    			// Support: IE<=11+
    			// Make sure textarea (and checkbox) defaultValue is properly cloned
    			div.innerHTML = "<textarea>x</textarea>";
    			support.noCloneChecked = !!div.cloneNode(true).lastChild.defaultValue;
    		})();
    		var strundefined = typeof undefined;
    
    
    
    		support.focusinBubbles = "onfocusin" in window;
    
    
    		var
    			rkeyEvent = /^key/,
    			rmouseEvent = /^(?:mouse|pointer|contextmenu)|click/,
    			rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
    			rtypenamespace = /^([^.]*)(?:\.(.+)|)$/;
    
    		function returnTrue() {
    			return true;
    		}
    
    		function returnFalse() {
    			return false;
    		}
    
    		function safeActiveElement() {
    			try {
    				return document.activeElement;
    			} catch (err) {}
    		}
    
    		
    		jQuery.event = {
    
    			global: {},
    
    			add: function(elem, types, handler, data, selector) {
    
    				var handleObjIn, eventHandle, tmp,
    					events, t, handleObj,
    					special, handlers, type, namespaces, origType,
    					elemData = data_priv.get(elem);
    
    				// Don't attach events to noData or text/comment nodes (but allow plain objects)
    				if (!elemData) {
    					return;
    				}
    
    				// Caller can pass in an object of custom data in lieu of the handler
    				if (handler.handler) {
    					handleObjIn = handler;
    					handler = handleObjIn.handler;
    					selector = handleObjIn.selector;
    				}
    
    				// Make sure that the handler has a unique ID, used to find/remove it later
    				if (!handler.guid) {
    					handler.guid = jQuery.guid++;
    				}
    
    				// Init the element's event structure and main handler, if this is the first
    				if (!(events = elemData.events)) {
    					events = elemData.events = {};
    				}
    				if (!(eventHandle = elemData.handle)) {
    					eventHandle = elemData.handle = function(e) {
    						// Discard the second event of a jQuery.event.trigger() and
    						// when an event is called after a page has unloaded
    						return typeof jQuery !== strundefined && jQuery.event.triggered !== e.type ?
    							jQuery.event.dispatch.apply(elem, arguments) : undefined;
    					};
    				}
    
    				// Handle multiple events separated by a space
    				types = (types || "").match(rnotwhite) || [""];
    				t = types.length;
    				while (t--) {
    					tmp = rtypenamespace.exec(types[t]) || [];
    					type = origType = tmp[1];
    					namespaces = (tmp[2] || "").split(".").sort();
    
    					// There *must* be a type, no attaching namespace-only handlers
    					if (!type) {
    						continue;
    					}
    
    					// If event changes its type, use the special event handlers for the changed type
    					special = jQuery.event.special[type] || {};
    
    					// If selector defined, determine special event api type, otherwise given type
    					type = (selector ? special.delegateType : special.bindType) || type;
    
    					// Update special based on newly reset type
    					special = jQuery.event.special[type] || {};
    
    					// handleObj is passed to all event handlers
    					handleObj = jQuery.extend({
    						type: type,
    						origType: origType,
    						data: data,
    						handler: handler,
    						guid: handler.guid,
    						selector: selector,
    						needsContext: selector && jQuery.expr.match.needsContext.test(selector),
    						namespace: namespaces.join(".")
    					}, handleObjIn);
    
    					// Init the event handler queue if we're the first
    					if (!(handlers = events[type])) {
    						handlers = events[type] = [];
    						handlers.delegateCount = 0;
    
    						// Only use addEventListener if the special events handler returns false
    						if (!special.setup || special.setup.call(elem, data, namespaces, eventHandle) === false) {
    							if (elem.addEventListener) {
    								elem.addEventListener(type, eventHandle, false);
    							}
    						}
    					}
    
    					if (special.add) {
    						special.add.call(elem, handleObj);
    
    						if (!handleObj.handler.guid) {
    							handleObj.handler.guid = handler.guid;
    						}
    					}
    
    					// Add to the element's handler list, delegates in front
    					if (selector) {
    						handlers.splice(handlers.delegateCount++, 0, handleObj);
    					} else {
    						handlers.push(handleObj);
    					}
    
    					// Keep track of which events have ever been used, for event optimization
    					jQuery.event.global[type] = true;
    				}
    
    			},
    
    			// Detach an event or set of events from an element
    			remove: function(elem, types, handler, selector, mappedTypes) {
    
    				var j, origCount, tmp,
    					events, t, handleObj,
    					special, handlers, type, namespaces, origType,
    					elemData = data_priv.hasData(elem) && data_priv.get(elem);
    
    				if (!elemData || !(events = elemData.events)) {
    					return;
    				}
    
    				// Once for each type.namespace in types; type may be omitted
    				types = (types || "").match(rnotwhite) || [""];
    				t = types.length;
    				while (t--) {
    					tmp = rtypenamespace.exec(types[t]) || [];
    					type = origType = tmp[1];
    					namespaces = (tmp[2] || "").split(".").sort();
    
    					// Unbind all events (on this namespace, if provided) for the element
    					if (!type) {
    						for (type in events) {
    							jQuery.event.remove(elem, type + types[t], handler, selector, true);
    						}
    						continue;
    					}
    
    					special = jQuery.event.special[type] || {};
    					type = (selector ? special.delegateType : special.bindType) || type;
    					handlers = events[type] || [];
    					tmp = tmp[2] && new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)");
    
    					// Remove matching events
    					origCount = j = handlers.length;
    					while (j--) {
    						handleObj = handlers[j];
    
    						if ((mappedTypes || origType === handleObj.origType) &&
    							(!handler || handler.guid === handleObj.guid) &&
    							(!tmp || tmp.test(handleObj.namespace)) &&
    							(!selector || selector === handleObj.selector || selector === "**" && handleObj.selector)) {
    							handlers.splice(j, 1);
    
    							if (handleObj.selector) {
    								handlers.delegateCount--;
    							}
    							if (special.remove) {
    								special.remove.call(elem, handleObj);
    							}
    						}
    					}
    
    					// Remove generic event handler if we removed something and no more handlers exist
    					// (avoids potential for endless recursion during removal of special event handlers)
    					if (origCount && !handlers.length) {
    						if (!special.teardown || special.teardown.call(elem, namespaces, elemData.handle) === false) {
    							jQuery.removeEvent(elem, type, elemData.handle);
    						}
    
    						delete events[type];
    					}
    				}
    
    				// Remove the expando if it's no longer used
    				if (jQuery.isEmptyObject(events)) {
    					delete elemData.handle;
    					data_priv.remove(elem, "events");
    				}
    			},
    
    			trigger: function(event, data, elem, onlyHandlers) {
    
    				var i, cur, tmp, bubbleType, ontype, handle, special,
    					eventPath = [elem || document],
    					type = hasOwn.call(event, "type") ? event.type : event,
    					namespaces = hasOwn.call(event, "namespace") ? event.namespace.split(".") : [];
    
    				cur = tmp = elem = elem || document;
    
    				// Don't do events on text and comment nodes
    				if (elem.nodeType === 3 || elem.nodeType === 8) {
    					return;
    				}
    
    				// focus/blur morphs to focusin/out; ensure we're not firing them right now
    				if (rfocusMorph.test(type + jQuery.event.triggered)) {
    					return;
    				}
    
    				if (type.indexOf(".") >= 0) {
    					// Namespaced trigger; create a regexp to match event type in handle()
    					namespaces = type.split(".");
    					type = namespaces.shift();
    					namespaces.sort();
    				}
    				ontype = type.indexOf(":") < 0 && "on" + type;
    
    				// Caller can pass in a jQuery.Event object, Object, or just an event type string
    				event = event[jQuery.expando] ?
    					event :
    					new jQuery.Event(type, typeof event === "object" && event);
    
    				// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)
    				event.isTrigger = onlyHandlers ? 2 : 3;
    				event.namespace = namespaces.join(".");
    				event.namespace_re = event.namespace ?
    					new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)") :
    					null;
    
    				// Clean up the event in case it is being reused
    				event.result = undefined;
    				if (!event.target) {
    					event.target = elem;
    				}
    
    				// Clone any incoming data and prepend the event, creating the handler arg list
    				data = data == null ?
    					[event] :
    					jQuery.makeArray(data, [event]);
    
    				// Allow special events to draw outside the lines
    				special = jQuery.event.special[type] || {};
    				if (!onlyHandlers && special.trigger && special.trigger.apply(elem, data) === false) {
    					return;
    				}
    
    				// Determine event propagation path in advance, per W3C events spec (#9951)
    				// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
    				if (!onlyHandlers && !special.noBubble && !jQuery.isWindow(elem)) {
    
    					bubbleType = special.delegateType || type;
    					if (!rfocusMorph.test(bubbleType + type)) {
    						cur = cur.parentNode;
    					}
    					for (; cur; cur = cur.parentNode) {
    						eventPath.push(cur);
    						tmp = cur;
    					}
    
    					// Only add window if we got to document (e.g., not plain obj or detached DOM)
    					if (tmp === (elem.ownerDocument || document)) {
    						eventPath.push(tmp.defaultView || tmp.parentWindow || window);
    					}
    				}
    
    				// Fire handlers on the event path
    				i = 0;
    				while ((cur = eventPath[i++]) && !event.isPropagationStopped()) {
    
    					event.type = i > 1 ?
    						bubbleType :
    						special.bindType || type;
    
    					// jQuery handler
    					handle = (data_priv.get(cur, "events") || {})[event.type] && data_priv.get(cur, "handle");
    					if (handle) {
    						handle.apply(cur, data);
    					}
    
    					// Native handler
    					handle = ontype && cur[ontype];
    					if (handle && handle.apply && jQuery.acceptData(cur)) {
    						event.result = handle.apply(cur, data);
    						if (event.result === false) {
    							event.preventDefault();
    						}
    					}
    				}
    				event.type = type;
    
    				// If nobody prevented the default action, do it now
    				if (!onlyHandlers && !event.isDefaultPrevented()) {
    
    					if ((!special._default || special._default.apply(eventPath.pop(), data) === false) &&
    						jQuery.acceptData(elem)) {
    
    						// Call a native DOM method on the target with the same name name as the event.
    						// Don't do default actions on window, that's where global variables be (#6170)
    						if (ontype && jQuery.isFunction(elem[type]) && !jQuery.isWindow(elem)) {
    
    							// Don't re-trigger an onFOO event when we call its FOO() method
    							tmp = elem[ontype];
    
    							if (tmp) {
    								elem[ontype] = null;
    							}
    
    							// Prevent re-triggering of the same event, since we already bubbled it above
    							jQuery.event.triggered = type;
    							elem[type]();
    							jQuery.event.triggered = undefined;
    
    							if (tmp) {
    								elem[ontype] = tmp;
    							}
    						}
    					}
    				}
    
    				return event.result;
    			},
    
    			dispatch: function(event) {
    
    				// Make a writable jQuery.Event from the native event object
    				event = jQuery.event.fix(event);
    
    				var i, j, ret, matched, handleObj,
    					handlerQueue = [],
    					args = slice.call(arguments),
    					handlers = (data_priv.get(this, "events") || {})[event.type] || [],
    					special = jQuery.event.special[event.type] || {};
    
    				// Use the fix-ed jQuery.Event rather than the (read-only) native event
    				args[0] = event;
    				event.delegateTarget = this;
    
    				// Call the preDispatch hook for the mapped type, and let it bail if desired
    				if (special.preDispatch && special.preDispatch.call(this, event) === false) {
    					return;
    				}
    
    				// Determine handlers
    				handlerQueue = jQuery.event.handlers.call(this, event, handlers);
    
    				// Run delegates first; they may want to stop propagation beneath us
    				i = 0;
    				while ((matched = handlerQueue[i++]) && !event.isPropagationStopped()) {
    					event.currentTarget = matched.elem;
    
    					j = 0;
    					while ((handleObj = matched.handlers[j++]) && !event.isImmediatePropagationStopped()) {
    
    						// Triggered event must either 1) have no namespace, or 2) have namespace(s)
    						// a subset or equal to those in the bound event (both can have no namespace).
    						if (!event.namespace_re || event.namespace_re.test(handleObj.namespace)) {
    
    							event.handleObj = handleObj;
    							event.data = handleObj.data;
    
    							ret = ((jQuery.event.special[handleObj.origType] || {}).handle || handleObj.handler)
    								.apply(matched.elem, args);
    
    							if (ret !== undefined) {
    								if ((event.result = ret) === false) {
    									event.preventDefault();
    									event.stopPropagation();
    								}
    							}
    						}
    					}
    				}
    
    				// Call the postDispatch hook for the mapped type
    				if (special.postDispatch) {
    					special.postDispatch.call(this, event);
    				}
    
    				return event.result;
    			},
    
    			handlers: function(event, handlers) {
    				var i, matches, sel, handleObj,
    					handlerQueue = [],
    					delegateCount = handlers.delegateCount,
    					cur = event.target;
    
    				// Find delegate handlers
    				// Black-hole SVG <use> instance trees (#13180)
    				// Avoid non-left-click bubbling in Firefox (#3861)
    				if (delegateCount && cur.nodeType && (!event.button || event.type !== "click")) {
    
    					for (; cur !== this; cur = cur.parentNode || this) {
    
    						// Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)
    						if (cur.disabled !== true || event.type !== "click") {
    							matches = [];
    							for (i = 0; i < delegateCount; i++) {
    								handleObj = handlers[i];
    
    								// Don't conflict with Object.prototype properties (#13203)
    								sel = handleObj.selector + " ";
    
    								if (matches[sel] === undefined) {
    									matches[sel] = handleObj.needsContext ?
    										jQuery(sel, this).index(cur) >= 0 :
    										jQuery.find(sel, this, null, [cur]).length;
    								}
    								if (matches[sel]) {
    									matches.push(handleObj);
    								}
    							}
    							if (matches.length) {
    								handlerQueue.push({
    									elem: cur,
    									handlers: matches
    								});
    							}
    						}
    					}
    				}
    
    				// Add the remaining (directly-bound) handlers
    				if (delegateCount < handlers.length) {
    					handlerQueue.push({
    						elem: this,
    						handlers: handlers.slice(delegateCount)
    					});
    				}
    
    				return handlerQueue;
    			},
    
    			// Includes some event props shared by KeyEvent and MouseEvent
    			props: "altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "),
    
    			fixHooks: {},
    
    			keyHooks: {
    				props: "char charCode key keyCode".split(" "),
    				filter: function(event, original) {
    
    					// Add which for key events
    					if (event.which == null) {
    						event.which = original.charCode != null ? original.charCode : original.keyCode;
    					}
    
    					return event;
    				}
    			},
    
    			mouseHooks: {
    				props: "button buttons clientX clientY offsetX offsetY pageX pageY screenX screenY toElement".split(" "),
    				filter: function(event, original) {
    					var eventDoc, doc, body,
    						button = original.button;
    
    					// Calculate pageX/Y if missing and clientX/Y available
    					if (event.pageX == null && original.clientX != null) {
    						eventDoc = event.target.ownerDocument || document;
    						doc = eventDoc.documentElement;
    						body = eventDoc.body;
    
    						event.pageX = original.clientX + (doc && doc.scrollLeft || body && body.scrollLeft || 0) - (doc && doc.clientLeft || body && body.clientLeft || 0);
    						event.pageY = original.clientY + (doc && doc.scrollTop || body && body.scrollTop || 0) - (doc && doc.clientTop || body && body.clientTop || 0);
    					}
    
    					// Add which for click: 1 === left; 2 === middle; 3 === right
    					// Note: button is not normalized, so don't use it
    					if (!event.which && button !== undefined) {
    						event.which = (button & 1 ? 1 : (button & 2 ? 3 : (button & 4 ? 2 : 0)));
    					}
    
    					return event;
    				}
    			},
    
    			fix: function(event) {
    				if (event[jQuery.expando]) {
    					return event;
    				}
    
    				// Create a writable copy of the event object and normalize some properties
    				var i, prop, copy,
    					type = event.type,
    					originalEvent = event,
    					fixHook = this.fixHooks[type];
    
    				if (!fixHook) {
    					this.fixHooks[type] = fixHook =
    						rmouseEvent.test(type) ? this.mouseHooks :
    						rkeyEvent.test(type) ? this.keyHooks : {};
    				}
    				copy = fixHook.props ? this.props.concat(fixHook.props) : this.props;
    
    				event = new jQuery.Event(originalEvent);
    
    				i = copy.length;
    				while (i--) {
    					prop = copy[i];
    					event[prop] = originalEvent[prop];
    				}
    
    				// Support: Cordova 2.5 (WebKit) (#13255)
    				// All events should have a target; Cordova deviceready doesn't
    				if (!event.target) {
    					event.target = document;
    				}
    
    				// Support: Safari 6.0+, Chrome<28
    				// Target should not be a text node (#504, #13143)
    				if (event.target.nodeType === 3) {
    					event.target = event.target.parentNode;
    				}
    
    				return fixHook.filter ? fixHook.filter(event, originalEvent) : event;
    			},
    
    			special: {
    				load: {
    					// Prevent triggered image.load events from bubbling to window.load
    					noBubble: true
    				},
    				focus: {
    					// Fire native event if possible so blur/focus sequence is correct
    					trigger: function() {
    						if (this !== safeActiveElement() && this.focus) {
    							this.focus();
    							return false;
    						}
    					},
    					delegateType: "focusin"
    				},
    				blur: {
    					trigger: function() {
    						if (this === safeActiveElement() && this.blur) {
    							this.blur();
    							return false;
    						}
    					},
    					delegateType: "focusout"
    				},
    				click: {
    					// For checkbox, fire native event so checked state will be right
    					trigger: function() {
    						if (this.type === "checkbox" && this.click && jQuery.nodeName(this, "input")) {
    							this.click();
    							return false;
    						}
    					},
    
    					// For cross-browser consistency, don't fire native .click() on links
    					_default: function(event) {
    						return jQuery.nodeName(event.target, "a");
    					}
    				},
    
    				beforeunload: {
    					postDispatch: function(event) {
    
    						// Support: Firefox 20+
    						// Firefox doesn't alert if the returnValue field is not set.
    						if (event.result !== undefined && event.originalEvent) {
    							event.originalEvent.returnValue = event.result;
    						}
    					}
    				}
    			},
    
    			simulate: function(type, elem, event, bubble) {
    				// Piggyback on a donor event to simulate a different one.
    				// Fake originalEvent to avoid donor's stopPropagation, but if the
    				// simulated event prevents default then we do the same on the donor.
    				var e = jQuery.extend(
    					new jQuery.Event(),
    					event, {
    						type: type,
    						isSimulated: true,
    						originalEvent: {}
    					}
    				);
    				if (bubble) {
    					jQuery.event.trigger(e, null, elem);
    				} else {
    					jQuery.event.dispatch.call(elem, e);
    				}
    				if (e.isDefaultPrevented()) {
    					event.preventDefault();
    				}
    			}
    		};
    
    		jQuery.removeEvent = function(elem, type, handle) {
    			if (elem.removeEventListener) {
    				elem.removeEventListener(type, handle, false);
    			}
    		};
    
    		jQuery.Event = function(src, props) {
    			// Allow instantiation without the 'new' keyword
    			if (!(this instanceof jQuery.Event)) {
    				return new jQuery.Event(src, props);
    			}
    
    			// Event object
    			if (src && src.type) {
    				this.originalEvent = src;
    				this.type = src.type;
    
    				// Events bubbling up the document may have been marked as prevented
    				// by a handler lower down the tree; reflect the correct value.
    				this.isDefaultPrevented = src.defaultPrevented ||
    					src.defaultPrevented === undefined &&
    					// Support: Android<4.0
    					src.returnValue === false ?
    					returnTrue :
    					returnFalse;
    
    				// Event type
    			} else {
    				this.type = src;
    			}
    
    			// Put explicitly provided properties onto the event object
    			if (props) {
    				jQuery.extend(this, props);
    			}
    
    			// Create a timestamp if incoming event doesn't have one
    			this.timeStamp = src && src.timeStamp || jQuery.now();
    
    			// Mark it as fixed
    			this[jQuery.expando] = true;
    		};
    
    		// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
    		// http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
    		jQuery.Event.prototype = {
    			isDefaultPrevented: returnFalse,
    			isPropagationStopped: returnFalse,
    			isImmediatePropagationStopped: returnFalse,
    
    			preventDefault: function() {
    				var e = this.originalEvent;
    
    				this.isDefaultPrevented = returnTrue;
    
    				if (e && e.preventDefault) {
    					e.preventDefault();
    				}
    			},
    			stopPropagation: function() {
    				var e = this.originalEvent;
    
    				this.isPropagationStopped = returnTrue;
    
    				if (e && e.stopPropagation) {
    					e.stopPropagation();
    				}
    			},
    			stopImmediatePropagation: function() {
    				var e = this.originalEvent;
    
    				this.isImmediatePropagationStopped = returnTrue;
    
    				if (e && e.stopImmediatePropagation) {
    					e.stopImmediatePropagation();
    				}
    
    				this.stopPropagation();
    			}
    		};
    
    		// Create mouseenter/leave events using mouseover/out and event-time checks
    		// Support: Chrome 15+
    		jQuery.each({
    			mouseenter: "mouseover",
    			mouseleave: "mouseout",
    			pointerenter: "pointerover",
    			pointerleave: "pointerout"
    		}, function(orig, fix) {
    			jQuery.event.special[orig] = {
    				delegateType: fix,
    				bindType: fix,
    
    				handle: function(event) {
    					var ret,
    						target = this,
    						related = event.relatedTarget,
    						handleObj = event.handleObj;
    
    					// For mousenter/leave call the handler if related is outside the target.
    					// NB: No relatedTarget if the mouse left/entered the browser window
    					if (!related || (related !== target && !jQuery.contains(target, related))) {
    						event.type = handleObj.origType;
    						ret = handleObj.handler.apply(this, arguments);
    						event.type = fix;
    					}
    					return ret;
    				}
    			};
    		});
    
    		// Support: Firefox, Chrome, Safari
    		// Create "bubbling" focus and blur events
    		if (!support.focusinBubbles) {
    			jQuery.each({
    				focus: "focusin",
    				blur: "focusout"
    			}, function(orig, fix) {
    
    				// Attach a single capturing handler on the document while someone wants focusin/focusout
    				var handler = function(event) {
    					jQuery.event.simulate(fix, event.target, jQuery.event.fix(event), true);
    				};
    
    				jQuery.event.special[fix] = {
    					setup: function() {
    						var doc = this.ownerDocument || this,
    							attaches = data_priv.access(doc, fix);
    
    						if (!attaches) {
    							doc.addEventListener(orig, handler, true);
    						}
    						data_priv.access(doc, fix, (attaches || 0) + 1);
    					},
    					teardown: function() {
    						var doc = this.ownerDocument || this,
    							attaches = data_priv.access(doc, fix) - 1;
    
    						if (!attaches) {
    							doc.removeEventListener(orig, handler, true);
    							data_priv.remove(doc, fix);
    
    						} else {
    							data_priv.access(doc, fix, attaches);
    						}
    					}
    				};
    			});
    		}
    
    		jQuery.fn.extend({
    
    			on: function(types, selector, data, fn,  one) {
    				var origFn, type;
    
    				// Types can be a map of types/handlers
    				if (typeof types === "object") {
    					// ( types-Object, selector, data )
    					if (typeof selector !== "string") {
    						// ( types-Object, data )
    						data = data || selector;
    						selector = undefined;
    					}
    					for (type in types) {
    						this.on(type, selector, data, types[type], one);
    					}
    					return this;
    				}
    
    				if (data == null && fn == null) {
    					// ( types, fn )
    					fn = selector;
    					data = selector = undefined;
    				} else if (fn == null) {
    					if (typeof selector === "string") {
    						// ( types, selector, fn )
    						fn = data;
    						data = undefined;
    					} else {
    						// ( types, data, fn )
    						fn = data;
    						data = selector;
    						selector = undefined;
    					}
    				}
    				if (fn === false) {
    					fn = returnFalse;
    				} else if (!fn) {
    					return this;
    				}
    
    				if (one === 1) {
    					origFn = fn;
    					fn = function(event) {
    						// Can use an empty set, since event contains the info
    						jQuery().off(event);
    						return origFn.apply(this, arguments);
    					};
    					// Use same guid so caller can remove using origFn
    					fn.guid = origFn.guid || (origFn.guid = jQuery.guid++);
    				}
    				return this.each(function() {
    					jQuery.event.add(this, types, fn, data, selector);
    				});
    			},
    			one: function(types, selector, data, fn) {
    				return this.on(types, selector, data, fn, 1);
    			},
    			off: function(types, selector, fn) {
    				var handleObj, type;
    				if (types && types.preventDefault && types.handleObj) {
    					// ( event )  dispatched jQuery.Event
    					handleObj = types.handleObj;
    					jQuery(types.delegateTarget).off(
    						handleObj.namespace ? handleObj.origType + "." + handleObj.namespace : handleObj.origType,
    						handleObj.selector,
    						handleObj.handler
    					);
    					return this;
    				}
    				if (typeof types === "object") {
    					// ( types-object [, selector] )
    					for (type in types) {
    						this.off(type, selector, types[type]);
    					}
    					return this;
    				}
    				if (selector === false || typeof selector === "function") {
    					// ( types [, fn] )
    					fn = selector;
    					selector = undefined;
    				}
    				if (fn === false) {
    					fn = returnFalse;
    				}
    				return this.each(function() {
    					jQuery.event.remove(this, types, fn, selector);
    				});
    			},
    
    			trigger: function(type, data) {
    				return this.each(function() {
    					jQuery.event.trigger(type, data, this);
    				});
    			},
    			triggerHandler: function(type, data) {
    				var elem = this[0];
    				if (elem) {
    					return jQuery.event.trigger(type, data, elem, true);
    				}
    			}
    		});
    
    
    		var
    			rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi,
    			rtagName = /<([\w:]+)/,
    			rhtml = /<|&#?\w+;/,
    			rnoInnerhtml = /<(?:script|style|link)/i,
    			// checked="checked" or checked
    			rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
    			rscriptType = /^$|\/(?:java|ecma)script/i,
    			rscriptTypeMasked = /^true\/(.*)/,
    			rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g,
    
    			// We have to close these tags to support XHTML (#13200)
    			wrapMap = {
    
    				// Support: IE9
    				option: [1, "<select multiple='multiple'>", "</select>"],
    
    				thead: [1, "<table>", "</table>"],
    				col: [2, "<table><colgroup>", "</colgroup></table>"],
    				tr: [2, "<table><tbody>", "</tbody></table>"],
    				td: [3, "<table><tbody><tr>", "</tr></tbody></table>"],
    
    				_default: [0, "", ""]
    			};
    
    		// Support: IE9
    		wrapMap.optgroup = wrapMap.option;
    
    		wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
    		wrapMap.th = wrapMap.td;
    
    		// Support: 1.x compatibility
    		// Manipulating tables requires a tbody
    		function manipulationTarget(elem, content) {
    			return jQuery.nodeName(elem, "table") &&
    				jQuery.nodeName(content.nodeType !== 11 ? content : content.firstChild, "tr") ?
    
    				elem.getElementsByTagName("tbody")[0] ||
    				elem.appendChild(elem.ownerDocument.createElement("tbody")) :
    				elem;
    		}
    
    		// Replace/restore the type attribute of script elements for safe DOM manipulation
    		function disableScript(elem) {
    			elem.type = (elem.getAttribute("type") !== null) + "/" + elem.type;
    			return elem;
    		}
    
    		function restoreScript(elem) {
    			var match = rscriptTypeMasked.exec(elem.type);
    
    			if (match) {
    				elem.type = match[1];
    			} else {
    				elem.removeAttribute("type");
    			}
    
    			return elem;
    		}
    
    		// Mark scripts as having already been evaluated
    		function setGlobalEval(elems, refElements) {
    			var i = 0,
    				l = elems.length;
    
    			for (; i < l; i++) {
    				data_priv.set(
    					elems[i], "globalEval", !refElements || data_priv.get(refElements[i], "globalEval")
    				);
    			}
    		}
    
    		function cloneCopyEvent(src, dest) {
    			var i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;
    
    			if (dest.nodeType !== 1) {
    				return;
    			}
    
    			// 1. Copy private data: events, handlers, etc.
    			if (data_priv.hasData(src)) {
    				pdataOld = data_priv.access(src);
    				pdataCur = data_priv.set(dest, pdataOld);
    				events = pdataOld.events;
    
    				if (events) {
    					delete pdataCur.handle;
    					pdataCur.events = {};
    
    					for (type in events) {
    						for (i = 0, l = events[type].length; i < l; i++) {
    							jQuery.event.add(dest, type, events[type][i]);
    						}
    					}
    				}
    			}
    
    			// 2. Copy user data
    			if (data_user.hasData(src)) {
    				udataOld = data_user.access(src);
    				udataCur = jQuery.extend({}, udataOld);
    
    				data_user.set(dest, udataCur);
    			}
    		}
    
    		function getAll(context, tag) {
    			var ret = context.getElementsByTagName ? context.getElementsByTagName(tag || "*") :
    				context.querySelectorAll ? context.querySelectorAll(tag || "*") :
    				[];
    
    			return tag === undefined || tag && jQuery.nodeName(context, tag) ?
    				jQuery.merge([context], ret) :
    				ret;
    		}
    
    		// Fix IE bugs, see support tests
    		function fixInput(src, dest) {
    			var nodeName = dest.nodeName.toLowerCase();
    
    			// Fails to persist the checked state of a cloned checkbox or radio button.
    			if (nodeName === "input" && rcheckableType.test(src.type)) {
    				dest.checked = src.checked;
    
    				// Fails to return the selected option to the default selected state when cloning options
    			} else if (nodeName === "input" || nodeName === "textarea") {
    				dest.defaultValue = src.defaultValue;
    			}
    		}
    
    		jQuery.extend({
    			clone: function(elem, dataAndEvents, deepDataAndEvents) {
    				var i, l, srcElements, destElements,
    					clone = elem.cloneNode(true),
    					inPage = jQuery.contains(elem.ownerDocument, elem);
    
    				// Fix IE cloning issues
    				if (!support.noCloneChecked && (elem.nodeType === 1 || elem.nodeType === 11) &&
    					!jQuery.isXMLDoc(elem)) {
    
    					// We eschew Sizzle here for performance reasons: http://jsperf.com/getall-vs-sizzle/2
    					destElements = getAll(clone);
    					srcElements = getAll(elem);
    
    					for (i = 0, l = srcElements.length; i < l; i++) {
    						fixInput(srcElements[i], destElements[i]);
    					}
    				}
    
    				// Copy the events from the original to the clone
    				if (dataAndEvents) {
    					if (deepDataAndEvents) {
    						srcElements = srcElements || getAll(elem);
    						destElements = destElements || getAll(clone);
    
    						for (i = 0, l = srcElements.length; i < l; i++) {
    							cloneCopyEvent(srcElements[i], destElements[i]);
    						}
    					} else {
    						cloneCopyEvent(elem, clone);
    					}
    				}
    
    				// Preserve script evaluation history
    				destElements = getAll(clone, "script");
    				if (destElements.length > 0) {
    					setGlobalEval(destElements, !inPage && getAll(elem, "script"));
    				}
    
    				// Return the cloned set
    				return clone;
    			},
    
    			buildFragment: function(elems, context, scripts, selection) {
    				var elem, tmp, tag, wrap, contains, j,
    					fragment = context.createDocumentFragment(),
    					nodes = [],
    					i = 0,
    					l = elems.length;
    
    				for (; i < l; i++) {
    					elem = elems[i];
    
    					if (elem || elem === 0) {
    
    						// Add nodes directly
    						if (jQuery.type(elem) === "object") {
    							// Support: QtWebKit, PhantomJS
    							// push.apply(_, arraylike) throws on ancient WebKit
    							jQuery.merge(nodes, elem.nodeType ? [elem] : elem);
    
    							// Convert non-html into a text node
    						} else if (!rhtml.test(elem)) {
    							nodes.push(context.createTextNode(elem));
    
    							// Convert html into DOM nodes
    						} else {
    							tmp = tmp || fragment.appendChild(context.createElement("div"));
    
    							// Deserialize a standard representation
    							tag = (rtagName.exec(elem) || ["", ""])[1].toLowerCase();
    							wrap = wrapMap[tag] || wrapMap._default;
    							tmp.innerHTML = wrap[1] + elem.replace(rxhtmlTag, "<$1></$2>") + wrap[2];
    
    							// Descend through wrappers to the right content
    							j = wrap[0];
    							while (j--) {
    								tmp = tmp.lastChild;
    							}
    
    							// Support: QtWebKit, PhantomJS
    							// push.apply(_, arraylike) throws on ancient WebKit
    							jQuery.merge(nodes, tmp.childNodes);
    
    							// Remember the top-level container
    							tmp = fragment.firstChild;
    
    							// Ensure the created nodes are orphaned (#12392)
    							tmp.textContent = "";
    						}
    					}
    				}
    
    				// Remove wrapper from fragment
    				fragment.textContent = "";
    
    				i = 0;
    				while ((elem = nodes[i++])) {
    
    					// #4087 - If origin and destination elements are the same, and this is
    					// that element, do not do anything
    					if (selection && jQuery.inArray(elem, selection) !== -1) {
    						continue;
    					}
    
    					contains = jQuery.contains(elem.ownerDocument, elem);
    
    					// Append to fragment
    					tmp = getAll(fragment.appendChild(elem), "script");
    
    					// Preserve script evaluation history
    					if (contains) {
    						setGlobalEval(tmp);
    					}
    
    					// Capture executables
    					if (scripts) {
    						j = 0;
    						while ((elem = tmp[j++])) {
    							if (rscriptType.test(elem.type || "")) {
    								scripts.push(elem);
    							}
    						}
    					}
    				}
    
    				return fragment;
    			},
    
    			cleanData: function(elems) {
    				var data, elem, type, key,
    					special = jQuery.event.special,
    					i = 0;
    
    				for (;
    					(elem = elems[i]) !== undefined; i++) {
    					if (jQuery.acceptData(elem)) {
    						key = elem[data_priv.expando];
    
    						if (key && (data = data_priv.cache[key])) {
    							if (data.events) {
    								for (type in data.events) {
    									if (special[type]) {
    										jQuery.event.remove(elem, type);
    
    										// This is a shortcut to avoid jQuery.event.remove's overhead
    									} else {
    										jQuery.removeEvent(elem, type, data.handle);
    									}
    								}
    							}
    							if (data_priv.cache[key]) {
    								// Discard any remaining `private` data
    								delete data_priv.cache[key];
    							}
    						}
    					}
    					// Discard any remaining `user` data
    					delete data_user.cache[elem[data_user.expando]];
    				}
    			}
    		});
    
    		jQuery.fn.extend({
    			text: function(value) {
    				return access(this, function(value) {
    					return value === undefined ?
    						jQuery.text(this) :
    						this.empty().each(function() {
    							if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
    								this.textContent = value;
    							}
    						});
    				}, null, value, arguments.length);
    			},
    
    			append: function() {
    				return this.domManip(arguments, function(elem) {
    					if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
    						var target = manipulationTarget(this, elem);
    						target.appendChild(elem);
    					}
    				});
    			},
    
    			prepend: function() {
    				return this.domManip(arguments, function(elem) {
    					if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
    						var target = manipulationTarget(this, elem);
    						target.insertBefore(elem, target.firstChild);
    					}
    				});
    			},
    
    			before: function() {
    				return this.domManip(arguments, function(elem) {
    					if (this.parentNode) {
    						this.parentNode.insertBefore(elem, this);
    					}
    				});
    			},
    
    			after: function() {
    				return this.domManip(arguments, function(elem) {
    					if (this.parentNode) {
    						this.parentNode.insertBefore(elem, this.nextSibling);
    					}
    				});
    			},
    
    			remove: function(selector, keepData  ) {
    				var elem,
    					elems = selector ? jQuery.filter(selector, this) : this,
    					i = 0;
    
    				for (;
    					(elem = elems[i]) != null; i++) {
    					if (!keepData && elem.nodeType === 1) {
    						jQuery.cleanData(getAll(elem));
    					}
    
    					if (elem.parentNode) {
    						if (keepData && jQuery.contains(elem.ownerDocument, elem)) {
    							setGlobalEval(getAll(elem, "script"));
    						}
    						elem.parentNode.removeChild(elem);
    					}
    				}
    
    				return this;
    			},
    
    			empty: function() {
    				var elem,
    					i = 0;
    
    				for (;
    					(elem = this[i]) != null; i++) {
    					if (elem.nodeType === 1) {
    
    						// Prevent memory leaks
    						jQuery.cleanData(getAll(elem, false));
    
    						// Remove any remaining nodes
    						elem.textContent = "";
    					}
    				}
    
    				return this;
    			},
    
    			clone: function(dataAndEvents, deepDataAndEvents) {
    				dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
    				deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;
    
    				return this.map(function() {
    					return jQuery.clone(this, dataAndEvents, deepDataAndEvents);
    				});
    			},
    
    			html: function(value) {
    				return access(this, function(value) {
    					var elem = this[0] || {},
    						i = 0,
    						l = this.length;
    
    					if (value === undefined && elem.nodeType === 1) {
    						return elem.innerHTML;
    					}
    
    					// See if we can take a shortcut and just use innerHTML
    					if (typeof value === "string" && !rnoInnerhtml.test(value) &&
    						!wrapMap[(rtagName.exec(value) || ["", ""])[1].toLowerCase()]) {
    
    						value = value.replace(rxhtmlTag, "<$1></$2>");
    
    						try {
    							for (; i < l; i++) {
    								elem = this[i] || {};
    
    								// Remove element nodes and prevent memory leaks
    								if (elem.nodeType === 1) {
    									jQuery.cleanData(getAll(elem, false));
    									elem.innerHTML = value;
    								}
    							}
    
    							elem = 0;
    
    							// If using innerHTML throws an exception, use the fallback method
    						} catch (e) {}
    					}
    
    					if (elem) {
    						this.empty().append(value);
    					}
    				}, null, value, arguments.length);
    			},
    
    			replaceWith: function() {
    				var arg = arguments[0];
    
    				// Make the changes, replacing each context element with the new content
    				this.domManip(arguments, function(elem) {
    					arg = this.parentNode;
    
    					jQuery.cleanData(getAll(this));
    
    					if (arg) {
    						arg.replaceChild(elem, this);
    					}
    				});
    
    				// Force removal if there was no new content (e.g., from empty arguments)
    				return arg && (arg.length || arg.nodeType) ? this : this.remove();
    			},
    
    			detach: function(selector) {
    				return this.remove(selector, true);
    			},
    
    			domManip: function(args, callback) {
    
    				// Flatten any nested arrays
    				args = concat.apply([], args);
    
    				var fragment, first, scripts, hasScripts, node, doc,
    					i = 0,
    					l = this.length,
    					set = this,
    					iNoClone = l - 1,
    					value = args[0],
    					isFunction = jQuery.isFunction(value);
    
    				// We can't cloneNode fragments that contain checked, in WebKit
    				if (isFunction ||
    					(l > 1 && typeof value === "string" &&
    						!support.checkClone && rchecked.test(value))) {
    					return this.each(function(index) {
    						var self = set.eq(index);
    						if (isFunction) {
    							args[0] = value.call(this, index, self.html());
    						}
    						self.domManip(args, callback);
    					});
    				}
    
    				if (l) {
    					fragment = jQuery.buildFragment(args, this[0].ownerDocument, false, this);
    					first = fragment.firstChild;
    
    					if (fragment.childNodes.length === 1) {
    						fragment = first;
    					}
    
    					if (first) {
    						scripts = jQuery.map(getAll(fragment, "script"), disableScript);
    						hasScripts = scripts.length;
    
    						// Use the original fragment for the last item instead of the first because it can end up
    						// being emptied incorrectly in certain situations (#8070).
    						for (; i < l; i++) {
    							node = fragment;
    
    							if (i !== iNoClone) {
    								node = jQuery.clone(node, true, true);
    
    								// Keep references to cloned scripts for later restoration
    								if (hasScripts) {
    									// Support: QtWebKit
    									// jQuery.merge because push.apply(_, arraylike) throws
    									jQuery.merge(scripts, getAll(node, "script"));
    								}
    							}
    
    							callback.call(this[i], node, i);
    						}
    
    						if (hasScripts) {
    							doc = scripts[scripts.length - 1].ownerDocument;
    
    							// Reenable scripts
    							jQuery.map(scripts, restoreScript);
    
    							// Evaluate executable scripts on first document insertion
    							for (i = 0; i < hasScripts; i++) {
    								node = scripts[i];
    								if (rscriptType.test(node.type || "") &&
    									!data_priv.access(node, "globalEval") && jQuery.contains(doc, node)) {
    
    									if (node.src) {
    										// Optional AJAX dependency, but won't run scripts if not present
    										if (jQuery._evalUrl) {
    											jQuery._evalUrl(node.src);
    										}
    									} else {
    										jQuery.globalEval(node.textContent.replace(rcleanScript, ""));
    									}
    								}
    							}
    						}
    					}
    				}
    
    				return this;
    			}
    		});
    
    		jQuery.each({
    			appendTo: "append",
    			prependTo: "prepend",
    			insertBefore: "before",
    			insertAfter: "after",
    			replaceAll: "replaceWith"
    		}, function(name, original) {
    			jQuery.fn[name] = function(selector) {
    				var elems,
    					ret = [],
    					insert = jQuery(selector),
    					last = insert.length - 1,
    					i = 0;
    
    				for (; i <= last; i++) {
    					elems = i === last ? this : this.clone(true);
    					jQuery(insert[i])[original](elems);
    
    					// Support: QtWebKit
    					// .get() because push.apply(_, arraylike) throws
    					push.apply(ret, elems.get());
    				}
    
    				return this.pushStack(ret);
    			};
    		});
    
    
    		var iframe,
    			elemdisplay = {};
    
    		
    		// Called only from within defaultDisplay
    		function actualDisplay(name, doc) {
    			var style,
    				elem = jQuery(doc.createElement(name)).appendTo(doc.body),
    
    				// getDefaultComputedStyle might be reliably used only on attached element
    				display = window.getDefaultComputedStyle && (style = window.getDefaultComputedStyle(elem[0])) ?
    
    				// Use of this method is a temporary fix (more like optimization) until something better comes along,
    				// since it was removed from specification and supported only in FF
    				style.display : jQuery.css(elem[0], "display");
    
    			// We don't have any data stored on the element,
    			// so use "detach" method as fast way to get rid of the element
    			elem.detach();
    
    			return display;
    		}
    
    		
    		function defaultDisplay(nodeName) {
    			var doc = document,
    				display = elemdisplay[nodeName];
    
    			if (!display) {
    				display = actualDisplay(nodeName, doc);
    
    				// If the simple way fails, read from inside an iframe
    				if (display === "none" || !display) {
    
    					// Use the already-created iframe if possible
    					iframe = (iframe || jQuery("<iframe frameborder='0' width='0' height='0'/>")).appendTo(doc.documentElement);
    
    					// Always write a new HTML skeleton so Webkit and Firefox don't choke on reuse
    					doc = iframe[0].contentDocument;
    
    					// Support: IE
    					doc.write();
    					doc.close();
    
    					display = actualDisplay(nodeName, doc);
    					iframe.detach();
    				}
    
    				// Store the correct default display
    				elemdisplay[nodeName] = display;
    			}
    
    			return display;
    		}
    		var rmargin = (/^margin/);
    
    		var rnumnonpx = new RegExp("^(" + pnum + ")(?!px)[a-z%]+$", "i");
    
    		var getStyles = function(elem) {
    			// Support: IE<=11+, Firefox<=30+ (#15098, #14150)
    			// IE throws on elements created in popups
    			// FF meanwhile throws on frame elements through "defaultView.getComputedStyle"
    			if (elem.ownerDocument.defaultView.opener) {
    				return elem.ownerDocument.defaultView.getComputedStyle(elem, null);
    			}
    
    			return window.getComputedStyle(elem, null);
    		};
    
    
    
    		function curCSS(elem, name, computed) {
    			var width, minWidth, maxWidth, ret,
    				style = elem.style;
    
    			computed = computed || getStyles(elem);
    
    			// Support: IE9
    			// getPropertyValue is only needed for .css('filter') (#12537)
    			if (computed) {
    				ret = computed.getPropertyValue(name) || computed[name];
    			}
    
    			if (computed) {
    
    				if (ret === "" && !jQuery.contains(elem.ownerDocument, elem)) {
    					ret = jQuery.style(elem, name);
    				}
    
    				// Support: iOS < 6
    				// A tribute to the "awesome hack by Dean Edwards"
    				// iOS < 6 (at least) returns percentage for a larger set of values, but width seems to be reliably pixels
    				// this is against the CSSOM draft spec: http://dev.w3.org/csswg/cssom/#resolved-values
    				if (rnumnonpx.test(ret) && rmargin.test(name)) {
    
    					// Remember the original values
    					width = style.width;
    					minWidth = style.minWidth;
    					maxWidth = style.maxWidth;
    
    					// Put in the new values to get a computed value out
    					style.minWidth = style.maxWidth = style.width = ret;
    					ret = computed.width;
    
    					// Revert the changed values
    					style.width = width;
    					style.minWidth = minWidth;
    					style.maxWidth = maxWidth;
    				}
    			}
    
    			return ret !== undefined ?
    				// Support: IE
    				// IE returns zIndex value as an integer.
    				ret + "" :
    				ret;
    		}
    
    
    		function addGetHookIf(conditionFn, hookFn) {
    			// Define the hook, we'll check on the first run if it's really needed.
    			return {
    				get: function() {
    					if (conditionFn()) {
    						// Hook not needed (or it's not possible to use it due
    						// to missing dependency), remove it.
    						delete this.get;
    						return;
    					}
    
    					// Hook needed; redefine it so that the support test is not executed again.
    					return (this.get = hookFn).apply(this, arguments);
    				}
    			};
    		}
    
    
    		(function() {
    			var pixelPositionVal, boxSizingReliableVal,
    				docElem = document.documentElement,
    				container = document.createElement("div"),
    				div = document.createElement("div");
    
    			if (!div.style) {
    				return;
    			}
    
    			// Support: IE9-11+
    			// Style of cloned element affects source element cloned (#8908)
    			div.style.backgroundClip = "content-box";
    			div.cloneNode(true).style.backgroundClip = "";
    			support.clearCloneStyle = div.style.backgroundClip === "content-box";
    
    			container.style.cssText = "border:0;width:0;height:0;top:0;left:-9999px;margin-top:1px;" +
    				"position:absolute";
    			container.appendChild(div);
    
    			// Executing both pixelPosition & boxSizingReliable tests require only one layout
    			// so they're executed at the same time to save the second computation.
    			function computePixelPositionAndBoxSizingReliable() {
    				div.style.cssText =
    					// Support: Firefox<29, Android 2.3
    					// Vendor-prefix box-sizing
    					"-webkit-box-sizing:border-box;-moz-box-sizing:border-box;" +
    					"box-sizing:border-box;display:block;margin-top:1%;top:1%;" +
    					"border:1px;padding:1px;width:4px;position:absolute";
    				div.innerHTML = "";
    				docElem.appendChild(container);
    
    				var divStyle = window.getComputedStyle(div, null);
    				pixelPositionVal = divStyle.top !== "1%";
    				boxSizingReliableVal = divStyle.width === "4px";
    
    				docElem.removeChild(container);
    			}
    
    			// Support: node.js jsdom
    			// Don't assume that getComputedStyle is a property of the global object
    			if (window.getComputedStyle) {
    				jQuery.extend(support, {
    					pixelPosition: function() {
    
    						// This test is executed only once but we still do memoizing
    						// since we can use the boxSizingReliable pre-computing.
    						// No need to check if the test was already performed, though.
    						computePixelPositionAndBoxSizingReliable();
    						return pixelPositionVal;
    					},
    					boxSizingReliable: function() {
    						if (boxSizingReliableVal == null) {
    							computePixelPositionAndBoxSizingReliable();
    						}
    						return boxSizingReliableVal;
    					},
    					reliableMarginRight: function() {
    
    						// Support: Android 2.3
    						// Check if div with explicit width and no margin-right incorrectly
    						// gets computed margin-right based on width of container. (#3333)
    						// WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right
    						// This support function is only executed once so no memoizing is needed.
    						var ret,
    							marginDiv = div.appendChild(document.createElement("div"));
    
    						// Reset CSS: box-sizing; display; margin; border; padding
    						marginDiv.style.cssText = div.style.cssText =
    							// Support: Firefox<29, Android 2.3
    							// Vendor-prefix box-sizing
    							"-webkit-box-sizing:content-box;-moz-box-sizing:content-box;" +
    							"box-sizing:content-box;display:block;margin:0;border:0;padding:0";
    						marginDiv.style.marginRight = marginDiv.style.width = "0";
    						div.style.width = "1px";
    						docElem.appendChild(container);
    
    						ret = !parseFloat(window.getComputedStyle(marginDiv, null).marginRight);
    
    						docElem.removeChild(container);
    						div.removeChild(marginDiv);
    
    						return ret;
    					}
    				});
    			}
    		})();
    
    
    		// A method for quickly swapping in/out CSS properties to get correct calculations.
    		jQuery.swap = function(elem, options, callback, args) {
    			var ret, name,
    				old = {};
    
    			// Remember the old values, and insert the new ones
    			for (name in options) {
    				old[name] = elem.style[name];
    				elem.style[name] = options[name];
    			}
    
    			ret = callback.apply(elem, args || []);
    
    			// Revert the old values
    			for (name in options) {
    				elem.style[name] = old[name];
    			}
    
    			return ret;
    		};
    
    
    		var
    		// Swappable if display is none or starts with table except "table", "table-cell", or "table-caption"
    		// See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
    			rdisplayswap = /^(none|table(?!-c[ea]).+)/,
    			rnumsplit = new RegExp("^(" + pnum + ")(.*)$", "i"),
    			rrelNum = new RegExp("^([+-])=(" + pnum + ")", "i"),
    
    			cssShow = {
    				position: "absolute",
    				visibility: "hidden",
    				display: "block"
    			},
    			cssNormalTransform = {
    				letterSpacing: "0",
    				fontWeight: "400"
    			},
    
    			cssPrefixes = ["Webkit", "O", "Moz", "ms"];
    
    		// Return a css property mapped to a potentially vendor prefixed property
    		function vendorPropName(style, name) {
    
    			// Shortcut for names that are not vendor prefixed
    			if (name in style) {
    				return name;
    			}
    
    			// Check for vendor prefixed names
    			var capName = name[0].toUpperCase() + name.slice(1),
    				origName = name,
    				i = cssPrefixes.length;
    
    			while (i--) {
    				name = cssPrefixes[i] + capName;
    				if (name in style) {
    					return name;
    				}
    			}
    
    			return origName;
    		}
    
    		function setPositiveNumber(elem, value, subtract) {
    			var matches = rnumsplit.exec(value);
    			return matches ?
    				// Guard against undefined "subtract", e.g., when used as in cssHooks
    				Math.max(0, matches[1] - (subtract || 0)) + (matches[2] || "px") :
    				value;
    		}
    
    		function augmentWidthOrHeight(elem, name, extra, isBorderBox, styles) {
    			var i = extra === (isBorderBox ? "border" : "content") ?
    				// If we already have the right measurement, avoid augmentation
    				4 :
    				// Otherwise initialize for horizontal or vertical properties
    				name === "width" ? 1 : 0,
    
    				val = 0;
    
    			for (; i < 4; i += 2) {
    				// Both box models exclude margin, so add it if we want it
    				if (extra === "margin") {
    					val += jQuery.css(elem, extra + cssExpand[i], true, styles);
    				}
    
    				if (isBorderBox) {
    					// border-box includes padding, so remove it if we want content
    					if (extra === "content") {
    						val -= jQuery.css(elem, "padding" + cssExpand[i], true, styles);
    					}
    
    					// At this point, extra isn't border nor margin, so remove border
    					if (extra !== "margin") {
    						val -= jQuery.css(elem, "border" + cssExpand[i] + "Width", true, styles);
    					}
    				} else {
    					// At this point, extra isn't content, so add padding
    					val += jQuery.css(elem, "padding" + cssExpand[i], true, styles);
    
    					// At this point, extra isn't content nor padding, so add border
    					if (extra !== "padding") {
    						val += jQuery.css(elem, "border" + cssExpand[i] + "Width", true, styles);
    					}
    				}
    			}
    
    			return val;
    		}
    
    		function getWidthOrHeight(elem, name, extra) {
    
    			// Start with offset property, which is equivalent to the border-box value
    			var valueIsBorderBox = true,
    				val = name === "width" ? elem.offsetWidth : elem.offsetHeight,
    				styles = getStyles(elem),
    				isBorderBox = jQuery.css(elem, "boxSizing", false, styles) === "border-box";
    
    			// Some non-html elements return undefined for offsetWidth, so check for null/undefined
    			// svg - https://bugzilla.mozilla.org/show_bug.cgi?id=649285
    			// MathML - https://bugzilla.mozilla.org/show_bug.cgi?id=491668
    			if (val <= 0 || val == null) {
    				// Fall back to computed then uncomputed css if necessary
    				val = curCSS(elem, name, styles);
    				if (val < 0 || val == null) {
    					val = elem.style[name];
    				}
    
    				// Computed unit is not pixels. Stop here and return.
    				if (rnumnonpx.test(val)) {
    					return val;
    				}
    
    				// Check for style in case a browser which returns unreliable values
    				// for getComputedStyle silently falls back to the reliable elem.style
    				valueIsBorderBox = isBorderBox &&
    					(support.boxSizingReliable() || val === elem.style[name]);
    
    				// Normalize "", auto, and prepare for extra
    				val = parseFloat(val) || 0;
    			}
    
    			// Use the active box-sizing model to add/subtract irrelevant styles
    			return (val +
    				augmentWidthOrHeight(
    					elem,
    					name,
    					extra || (isBorderBox ? "border" : "content"),
    					valueIsBorderBox,
    					styles
    				)
    			) + "px";
    		}
    
    		function showHide(elements, show) {
    			var display, elem, hidden,
    				values = [],
    				index = 0,
    				length = elements.length;
    
    			for (; index < length; index++) {
    				elem = elements[index];
    				if (!elem.style) {
    					continue;
    				}
    
    				values[index] = data_priv.get(elem, "olddisplay");
    				display = elem.style.display;
    				if (show) {
    					// Reset the inline display of this element to learn if it is
    					// being hidden by cascaded rules or not
    					if (!values[index] && display === "none") {
    						elem.style.display = "";
    					}
    
    					// Set elements which have been overridden with display: none
    					// in a stylesheet to whatever the default browser style is
    					// for such an element
    					if (elem.style.display === "" && isHidden(elem)) {
    						values[index] = data_priv.access(elem, "olddisplay", defaultDisplay(elem.nodeName));
    					}
    				} else {
    					hidden = isHidden(elem);
    
    					if (display !== "none" || !hidden) {
    						data_priv.set(elem, "olddisplay", hidden ? display : jQuery.css(elem, "display"));
    					}
    				}
    			}
    
    			// Set the display of most of the elements in a second loop
    			// to avoid the constant reflow
    			for (index = 0; index < length; index++) {
    				elem = elements[index];
    				if (!elem.style) {
    					continue;
    				}
    				if (!show || elem.style.display === "none" || elem.style.display === "") {
    					elem.style.display = show ? values[index] || "" : "none";
    				}
    			}
    
    			return elements;
    		}
    
    		jQuery.extend({
    
    			// Add in style property hooks for overriding the default
    			// behavior of getting and setting a style property
    			cssHooks: {
    				opacity: {
    					get: function(elem, computed) {
    						if (computed) {
    
    							// We should always get a number back from opacity
    							var ret = curCSS(elem, "opacity");
    							return ret === "" ? "1" : ret;
    						}
    					}
    				}
    			},
    
    			// Don't automatically add "px" to these possibly-unitless properties
    			cssNumber: {
    				"columnCount": true,
    				"fillOpacity": true,
    				"flexGrow": true,
    				"flexShrink": true,
    				"fontWeight": true,
    				"lineHeight": true,
    				"opacity": true,
    				"order": true,
    				"orphans": true,
    				"widows": true,
    				"zIndex": true,
    				"zoom": true
    			},
    
    			// Add in properties whose names you wish to fix before
    			// setting or getting the value
    			cssProps: {
    				"float": "cssFloat"
    			},
    
    			// Get and set the style property on a DOM Node
    			style: function(elem, name, value, extra) {
    
    				// Don't set styles on text and comment nodes
    				if (!elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style) {
    					return;
    				}
    
    				// Make sure that we're working with the right name
    				var ret, type, hooks,
    					origName = jQuery.camelCase(name),
    					style = elem.style;
    
    				name = jQuery.cssProps[origName] || (jQuery.cssProps[origName] = vendorPropName(style, origName));
    
    				// Gets hook for the prefixed version, then unprefixed version
    				hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName];
    
    				// Check if we're setting a value
    				if (value !== undefined) {
    					type = typeof value;
    
    					// Convert "+=" or "-=" to relative numbers (#7345)
    					if (type === "string" && (ret = rrelNum.exec(value))) {
    						value = (ret[1] + 1) * ret[2] + parseFloat(jQuery.css(elem, name));
    						// Fixes bug #9237
    						type = "number";
    					}
    
    					// Make sure that null and NaN values aren't set (#7116)
    					if (value == null || value !== value) {
    						return;
    					}
    
    					// If a number, add 'px' to the (except for certain CSS properties)
    					if (type === "number" && !jQuery.cssNumber[origName]) {
    						value += "px";
    					}
    
    					// Support: IE9-11+
    					// background-* props affect original clone's values
    					if (!support.clearCloneStyle && value === "" && name.indexOf("background") === 0) {
    						style[name] = "inherit";
    					}
    
    					// If a hook was provided, use that value, otherwise just set the specified value
    					if (!hooks || !("set" in hooks) || (value = hooks.set(elem, value, extra)) !== undefined) {
    						style[name] = value;
    					}
    
    				} else {
    					// If a hook was provided get the non-computed value from there
    					if (hooks && "get" in hooks && (ret = hooks.get(elem, false, extra)) !== undefined) {
    						return ret;
    					}
    
    					// Otherwise just get the value from the style object
    					return style[name];
    				}
    			},
    
    			css: function(elem, name, extra, styles) {
    				var val, num, hooks,
    					origName = jQuery.camelCase(name);
    
    				// Make sure that we're working with the right name
    				name = jQuery.cssProps[origName] || (jQuery.cssProps[origName] = vendorPropName(elem.style, origName));
    
    				// Try prefixed name followed by the unprefixed name
    				hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName];
    
    				// If a hook was provided get the computed value from there
    				if (hooks && "get" in hooks) {
    					val = hooks.get(elem, true, extra);
    				}
    
    				// Otherwise, if a way to get the computed value exists, use that
    				if (val === undefined) {
    					val = curCSS(elem, name, styles);
    				}
    
    				// Convert "normal" to computed value
    				if (val === "normal" && name in cssNormalTransform) {
    					val = cssNormalTransform[name];
    				}
    
    				// Make numeric if forced or a qualifier was provided and val looks numeric
    				if (extra === "" || extra) {
    					num = parseFloat(val);
    					return extra === true || jQuery.isNumeric(num) ? num || 0 : val;
    				}
    				return val;
    			}
    		});
    
    		jQuery.each(["height", "width"], function(i, name) {
    			jQuery.cssHooks[name] = {
    				get: function(elem, computed, extra) {
    					if (computed) {
    
    						// Certain elements can have dimension info if we invisibly show them
    						// but it must have a current display style that would benefit
    						return rdisplayswap.test(jQuery.css(elem, "display")) && elem.offsetWidth === 0 ?
    							jQuery.swap(elem, cssShow, function() {
    								return getWidthOrHeight(elem, name, extra);
    							}) :
    							getWidthOrHeight(elem, name, extra);
    					}
    				},
    
    				set: function(elem, value, extra) {
    					var styles = extra && getStyles(elem);
    					return setPositiveNumber(elem, value, extra ?
    						augmentWidthOrHeight(
    							elem,
    							name,
    							extra,
    							jQuery.css(elem, "boxSizing", false, styles) === "border-box",
    							styles
    						) : 0
    					);
    				}
    			};
    		});
    
    		// Support: Android 2.3
    		jQuery.cssHooks.marginRight = addGetHookIf(support.reliableMarginRight,
    			function(elem, computed) {
    				if (computed) {
    					return jQuery.swap(elem, {
    							"display": "inline-block"
    						},
    						curCSS, [elem, "marginRight"]);
    				}
    			}
    		);
    
    		// These hooks are used by animate to expand properties
    		jQuery.each({
    			margin: "",
    			padding: "",
    			border: "Width"
    		}, function(prefix, suffix) {
    			jQuery.cssHooks[prefix + suffix] = {
    				expand: function(value) {
    					var i = 0,
    						expanded = {},
    
    						// Assumes a single number if not a string
    						parts = typeof value === "string" ? value.split(" ") : [value];
    
    					for (; i < 4; i++) {
    						expanded[prefix + cssExpand[i] + suffix] =
    							parts[i] || parts[i - 2] || parts[0];
    					}
    
    					return expanded;
    				}
    			};
    
    			if (!rmargin.test(prefix)) {
    				jQuery.cssHooks[prefix + suffix].set = setPositiveNumber;
    			}
    		});
    
    		jQuery.fn.extend({
    			css: function(name, value) {
    				return access(this, function(elem, name, value) {
    					var styles, len,
    						map = {},
    						i = 0;
    
    					if (jQuery.isArray(name)) {
    						styles = getStyles(elem);
    						len = name.length;
    
    						for (; i < len; i++) {
    							map[name[i]] = jQuery.css(elem, name[i], false, styles);
    						}
    
    						return map;
    					}
    
    					return value !== undefined ?
    						jQuery.style(elem, name, value) :
    						jQuery.css(elem, name);
    				}, name, value, arguments.length > 1);
    			},
    			show: function() {
    				return showHide(this, true);
    			},
    			hide: function() {
    				return showHide(this);
    			},
    			toggle: function(state) {
    				if (typeof state === "boolean") {
    					return state ? this.show() : this.hide();
    				}
    
    				return this.each(function() {
    					if (isHidden(this)) {
    						jQuery(this).show();
    					} else {
    						jQuery(this).hide();
    					}
    				});
    			}
    		});
    
    
    		function Tween(elem, options, prop, end, easing) {
    			return new Tween.prototype.init(elem, options, prop, end, easing);
    		}
    		jQuery.Tween = Tween;
    
    		Tween.prototype = {
    			constructor: Tween,
    			init: function(elem, options, prop, end, easing, unit) {
    				this.elem = elem;
    				this.prop = prop;
    				this.easing = easing || "swing";
    				this.options = options;
    				this.start = this.now = this.cur();
    				this.end = end;
    				this.unit = unit || (jQuery.cssNumber[prop] ? "" : "px");
    			},
    			cur: function() {
    				var hooks = Tween.propHooks[this.prop];
    
    				return hooks && hooks.get ?
    					hooks.get(this) :
    					Tween.propHooks._default.get(this);
    			},
    			run: function(percent) {
    				var eased,
    					hooks = Tween.propHooks[this.prop];
    
    				if (this.options.duration) {
    					this.pos = eased = jQuery.easing[this.easing](
    						percent, this.options.duration * percent, 0, 1, this.options.duration
    					);
    				} else {
    					this.pos = eased = percent;
    				}
    				this.now = (this.end - this.start) * eased + this.start;
    
    				if (this.options.step) {
    					this.options.step.call(this.elem, this.now, this);
    				}
    
    				if (hooks && hooks.set) {
    					hooks.set(this);
    				} else {
    					Tween.propHooks._default.set(this);
    				}
    				return this;
    			}
    		};
    
    		Tween.prototype.init.prototype = Tween.prototype;
    
    		Tween.propHooks = {
    			_default: {
    				get: function(tween) {
    					var result;
    
    					if (tween.elem[tween.prop] != null &&
    						(!tween.elem.style || tween.elem.style[tween.prop] == null)) {
    						return tween.elem[tween.prop];
    					}
    
    					// Passing an empty string as a 3rd parameter to .css will automatically
    					// attempt a parseFloat and fallback to a string if the parse fails.
    					// Simple values such as "10px" are parsed to Float;
    					// complex values such as "rotate(1rad)" are returned as-is.
    					result = jQuery.css(tween.elem, tween.prop, "");
    					// Empty strings, null, undefined and "auto" are converted to 0.
    					return !result || result === "auto" ? 0 : result;
    				},
    				set: function(tween) {
    					// Use step hook for back compat.
    					// Use cssHook if its there.
    					// Use .style if available and use plain properties where available.
    					if (jQuery.fx.step[tween.prop]) {
    						jQuery.fx.step[tween.prop](tween);
    					} else if (tween.elem.style && (tween.elem.style[jQuery.cssProps[tween.prop]] != null || jQuery.cssHooks[tween.prop])) {
    						jQuery.style(tween.elem, tween.prop, tween.now + tween.unit);
    					} else {
    						tween.elem[tween.prop] = tween.now;
    					}
    				}
    			}
    		};
    
    		// Support: IE9
    		// Panic based approach to setting things on disconnected nodes
    		Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
    			set: function(tween) {
    				if (tween.elem.nodeType && tween.elem.parentNode) {
    					tween.elem[tween.prop] = tween.now;
    				}
    			}
    		};
    
    		jQuery.easing = {
    			linear: function(p) {
    				return p;
    			},
    			swing: function(p) {
    				return 0.5 - Math.cos(p * Math.PI) / 2;
    			}
    		};
    
    		jQuery.fx = Tween.prototype.init;
    
    		// Back Compat <1.8 extension point
    		jQuery.fx.step = {};
    
    
    
    		var
    			fxNow, timerId,
    			rfxtypes = /^(?:toggle|show|hide)$/,
    			rfxnum = new RegExp("^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i"),
    			rrun = /queueHooks$/,
    			animationPrefilters = [defaultPrefilter],
    			tweeners = {
    				"*": [function(prop, value) {
    					var tween = this.createTween(prop, value),
    						target = tween.cur(),
    						parts = rfxnum.exec(value),
    						unit = parts && parts[3] || (jQuery.cssNumber[prop] ? "" : "px"),
    
    						// Starting value computation is required for potential unit mismatches
    						start = (jQuery.cssNumber[prop] || unit !== "px" && +target) &&
    						rfxnum.exec(jQuery.css(tween.elem, prop)),
    						scale = 1,
    						maxIterations = 20;
    
    					if (start && start[3] !== unit) {
    						// Trust units reported by jQuery.css
    						unit = unit || start[3];
    
    						// Make sure we update the tween properties later on
    						parts = parts || [];
    
    						// Iteratively approximate from a nonzero starting point
    						start = +target || 1;
    
    						do {
    							// If previous iteration zeroed out, double until we get *something*.
    							// Use string for doubling so we don't accidentally see scale as unchanged below
    							scale = scale || ".5";
    
    							// Adjust and apply
    							start = start / scale;
    							jQuery.style(tween.elem, prop, start + unit);
    
    							// Update scale, tolerating zero or NaN from tween.cur(),
    							// break the loop if scale is unchanged or perfect, or if we've just had enough
    						} while (scale !== (scale = tween.cur() / target) && scale !== 1 && --maxIterations);
    					}
    
    					// Update tween properties
    					if (parts) {
    						start = tween.start = +start || +target || 0;
    						tween.unit = unit;
    						// If a +=/-= token was provided, we're doing a relative animation
    						tween.end = parts[1] ?
    							start + (parts[1] + 1) * parts[2] :
    							+parts[2];
    					}
    
    					return tween;
    				}]
    			};
    
    		// Animations created synchronously will run synchronously
    		function createFxNow() {
    			setTimeout(function() {
    				fxNow = undefined;
    			});
    			return (fxNow = jQuery.now());
    		}
    
    		// Generate parameters to create a standard animation
    		function genFx(type, includeWidth) {
    			var which,
    				i = 0,
    				attrs = {
    					height: type
    				};
    
    			// If we include width, step value is 1 to do all cssExpand values,
    			// otherwise step value is 2 to skip over Left and Right
    			includeWidth = includeWidth ? 1 : 0;
    			for (; i < 4; i += 2 - includeWidth) {
    				which = cssExpand[i];
    				attrs["margin" + which] = attrs["padding" + which] = type;
    			}
    
    			if (includeWidth) {
    				attrs.opacity = attrs.width = type;
    			}
    
    			return attrs;
    		}
    
    		function createTween(value, prop, animation) {
    			var tween,
    				collection = (tweeners[prop] || []).concat(tweeners["*"]),
    				index = 0,
    				length = collection.length;
    			for (; index < length; index++) {
    				if ((tween = collection[index].call(animation, prop, value))) {
    
    					// We're done with this property
    					return tween;
    				}
    			}
    		}
    
    		function defaultPrefilter(elem, props, opts) {
    			
    			var prop, value, toggle, tween, hooks, oldfire, display, checkDisplay,
    				anim = this,
    				orig = {},
    				style = elem.style,
    				hidden = elem.nodeType && isHidden(elem),
    				dataShow = data_priv.get(elem, "fxshow");
    
    			// Handle queue: false promises
    			if (!opts.queue) {
    				hooks = jQuery._queueHooks(elem, "fx");
    				if (hooks.unqueued == null) {
    					hooks.unqueued = 0;
    					oldfire = hooks.empty.fire;
    					hooks.empty.fire = function() {
    						if (!hooks.unqueued) {
    							oldfire();
    						}
    					};
    				}
    				hooks.unqueued++;
    
    				anim.always(function() {
    					// Ensure the complete handler is called before this completes
    					anim.always(function() {
    						hooks.unqueued--;
    						if (!jQuery.queue(elem, "fx").length) {
    							hooks.empty.fire();
    						}
    					});
    				});
    			}
    
    			// Height/width overflow pass
    			if (elem.nodeType === 1 && ("height" in props || "width" in props)) {
    				// Make sure that nothing sneaks out
    				// Record all 3 overflow attributes because IE9-10 do not
    				// change the overflow attribute when overflowX and
    				// overflowY are set to the same value
    				opts.overflow = [style.overflow, style.overflowX, style.overflowY];
    
    				// Set display property to inline-block for height/width
    				// animations on inline elements that are having width/height animated
    				display = jQuery.css(elem, "display");
    
    				// Test default display if display is currently "none"
    				checkDisplay = display === "none" ?
    					data_priv.get(elem, "olddisplay") || defaultDisplay(elem.nodeName) : display;
    
    				if (checkDisplay === "inline" && jQuery.css(elem, "float") === "none") {
    					style.display = "inline-block";
    				}
    			}
    
    			if (opts.overflow) {
    				style.overflow = "hidden";
    				anim.always(function() {
    					style.overflow = opts.overflow[0];
    					style.overflowX = opts.overflow[1];
    					style.overflowY = opts.overflow[2];
    				});
    			}
    
    			// show/hide pass
    			for (prop in props) {
    				value = props[prop];
    				if (rfxtypes.exec(value)) {
    					delete props[prop];
    					toggle = toggle || value === "toggle";
    					if (value === (hidden ? "hide" : "show")) {
    
    						// If there is dataShow left over from a stopped hide or show and we are going to proceed with show, we should pretend to be hidden
    						if (value === "show" && dataShow && dataShow[prop] !== undefined) {
    							hidden = true;
    						} else {
    							continue;
    						}
    					}
    					orig[prop] = dataShow && dataShow[prop] || jQuery.style(elem, prop);
    
    					// Any non-fx value stops us from restoring the original display value
    				} else {
    					display = undefined;
    				}
    			}
    
    			if (!jQuery.isEmptyObject(orig)) {
    				if (dataShow) {
    					if ("hidden" in dataShow) {
    						hidden = dataShow.hidden;
    					}
    				} else {
    					dataShow = data_priv.access(elem, "fxshow", {});
    				}
    
    				// Store state if its toggle - enables .stop().toggle() to "reverse"
    				if (toggle) {
    					dataShow.hidden = !hidden;
    				}
    				if (hidden) {
    					jQuery(elem).show();
    				} else {
    					anim.done(function() {
    						jQuery(elem).hide();
    					});
    				}
    				anim.done(function() {
    					var prop;
    
    					data_priv.remove(elem, "fxshow");
    					for (prop in orig) {
    						jQuery.style(elem, prop, orig[prop]);
    					}
    				});
    				for (prop in orig) {
    					tween = createTween(hidden ? dataShow[prop] : 0, prop, anim);
    
    					if (!(prop in dataShow)) {
    						dataShow[prop] = tween.start;
    						if (hidden) {
    							tween.end = tween.start;
    							tween.start = prop === "width" || prop === "height" ? 1 : 0;
    						}
    					}
    				}
    
    				// If this is a noop like .hide().hide(), restore an overwritten display value
    			} else if ((display === "none" ? defaultDisplay(elem.nodeName) : display) === "inline") {
    				style.display = display;
    			}
    		}
    
    		function propFilter(props, specialEasing) {
    			var index, name, easing, value, hooks;
    
    			// camelCase, specialEasing and expand cssHook pass
    			for (index in props) {
    				name = jQuery.camelCase(index);
    				easing = specialEasing[name];
    				value = props[index];
    				if (jQuery.isArray(value)) {
    					easing = value[1];
    					value = props[index] = value[0];
    				}
    
    				if (index !== name) {
    					props[name] = value;
    					delete props[index];
    				}
    
    				hooks = jQuery.cssHooks[name];
    				if (hooks && "expand" in hooks) {
    					value = hooks.expand(value);
    					delete props[name];
    
    					// Not quite $.extend, this won't overwrite existing keys.
    					// Reusing 'index' because we have the correct "name"
    					for (index in value) {
    						if (!(index in props)) {
    							props[index] = value[index];
    							specialEasing[index] = easing;
    						}
    					}
    				} else {
    					specialEasing[name] = easing;
    				}
    			}
    		}
    
    		function Animation(elem, properties, options) {
    			var result,
    				stopped,
    				index = 0,
    				length = animationPrefilters.length,
    				deferred = jQuery.Deferred().always(function() {
    					// Don't match elem in the :animated selector
    					delete tick.elem;
    				}),
    				tick = function() {
    					if (stopped) {
    						return false;
    					}
    					var currentTime = fxNow || createFxNow(),
    						remaining = Math.max(0, animation.startTime + animation.duration - currentTime),
    						// Support: Android 2.3
    						// Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (#12497)
    						temp = remaining / animation.duration || 0,
    						percent = 1 - temp,
    						index = 0,
    						length = animation.tweens.length;
    
    					for (; index < length; index++) {
    						animation.tweens[index].run(percent);
    					}
    
    					deferred.notifyWith(elem, [animation, percent, remaining]);
    
    					if (percent < 1 && length) {
    						return remaining;
    					} else {
    						deferred.resolveWith(elem, [animation]);
    						return false;
    					}
    				},
    				animation = deferred.promise({
    					elem: elem,
    					props: jQuery.extend({}, properties),
    					opts: jQuery.extend(true, {
    						specialEasing: {}
    					}, options),
    					originalProperties: properties,
    					originalOptions: options,
    					startTime: fxNow || createFxNow(),
    					duration: options.duration,
    					tweens: [],
    					createTween: function(prop, end) {
    						var tween = jQuery.Tween(elem, animation.opts, prop, end,
    							animation.opts.specialEasing[prop] || animation.opts.easing);
    						animation.tweens.push(tween);
    						return tween;
    					},
    					stop: function(gotoEnd) {
    						var index = 0,
    							// If we are going to the end, we want to run all the tweens
    							// otherwise we skip this part
    							length = gotoEnd ? animation.tweens.length : 0;
    						if (stopped) {
    							return this;
    						}
    						stopped = true;
    						for (; index < length; index++) {
    							animation.tweens[index].run(1);
    						}
    
    						// Resolve when we played the last frame; otherwise, reject
    						if (gotoEnd) {
    							deferred.resolveWith(elem, [animation, gotoEnd]);
    						} else {
    							deferred.rejectWith(elem, [animation, gotoEnd]);
    						}
    						return this;
    					}
    				}),
    				props = animation.props;
    
    			propFilter(props, animation.opts.specialEasing);
    
    			for (; index < length; index++) {
    				result = animationPrefilters[index].call(animation, elem, props, animation.opts);
    				if (result) {
    					return result;
    				}
    			}
    
    			jQuery.map(props, createTween, animation);
    
    			if (jQuery.isFunction(animation.opts.start)) {
    				animation.opts.start.call(elem, animation);
    			}
    
    			jQuery.fx.timer(
    				jQuery.extend(tick, {
    					elem: elem,
    					anim: animation,
    					queue: animation.opts.queue
    				})
    			);
    
    			// attach callbacks from options
    			return animation.progress(animation.opts.progress)
    				.done(animation.opts.done, animation.opts.complete)
    				.fail(animation.opts.fail)
    				.always(animation.opts.always);
    		}
    
    		jQuery.Animation = jQuery.extend(Animation, {
    
    			tweener: function(props, callback) {
    				if (jQuery.isFunction(props)) {
    					callback = props;
    					props = ["*"];
    				} else {
    					props = props.split(" ");
    				}
    
    				var prop,
    					index = 0,
    					length = props.length;
    
    				for (; index < length; index++) {
    					prop = props[index];
    					tweeners[prop] = tweeners[prop] || [];
    					tweeners[prop].unshift(callback);
    				}
    			},
    
    			prefilter: function(callback, prepend) {
    				if (prepend) {
    					animationPrefilters.unshift(callback);
    				} else {
    					animationPrefilters.push(callback);
    				}
    			}
    		});
    
    		jQuery.speed = function(speed, easing, fn) {
    			var opt = speed && typeof speed === "object" ? jQuery.extend({}, speed) : {
    				complete: fn || !fn && easing ||
    					jQuery.isFunction(speed) && speed,
    				duration: speed,
    				easing: fn && easing || easing && !jQuery.isFunction(easing) && easing
    			};
    
    			opt.duration = jQuery.fx.off ? 0 : typeof opt.duration === "number" ? opt.duration :
    				opt.duration in jQuery.fx.speeds ? jQuery.fx.speeds[opt.duration] : jQuery.fx.speeds._default;
    
    			// Normalize opt.queue - true/undefined/null -> "fx"
    			if (opt.queue == null || opt.queue === true) {
    				opt.queue = "fx";
    			}
    
    			// Queueing
    			opt.old = opt.complete;
    
    			opt.complete = function() {
    				if (jQuery.isFunction(opt.old)) {
    					opt.old.call(this);
    				}
    
    				if (opt.queue) {
    					jQuery.dequeue(this, opt.queue);
    				}
    			};
    
    			return opt;
    		};
    
    		jQuery.fn.extend({
    			fadeTo: function(speed, to, easing, callback) {
    
    				// Show any hidden elements after setting opacity to 0
    				return this.filter(isHidden).css("opacity", 0).show()
    
    				// Animate to the value specified
    				.end().animate({
    					opacity: to
    				}, speed, easing, callback);
    			},
    			animate: function(prop, speed, easing, callback) {
    				var empty = jQuery.isEmptyObject(prop),
    					optall = jQuery.speed(speed, easing, callback),
    					doAnimation = function() {
    						// Operate on a copy of prop so per-property easing won't be lost
    						var anim = Animation(this, jQuery.extend({}, prop), optall);
    
    						// Empty animations, or finishing resolves immediately
    						if (empty || data_priv.get(this, "finish")) {
    							anim.stop(true);
    						}
    					};
    				doAnimation.finish = doAnimation;
    
    				return empty || optall.queue === false ?
    					this.each(doAnimation) :
    					this.queue(optall.queue, doAnimation);
    			},
    			stop: function(type, clearQueue, gotoEnd) {
    				var stopQueue = function(hooks) {
    					var stop = hooks.stop;
    					delete hooks.stop;
    					stop(gotoEnd);
    				};
    
    				if (typeof type !== "string") {
    					gotoEnd = clearQueue;
    					clearQueue = type;
    					type = undefined;
    				}
    				if (clearQueue && type !== false) {
    					this.queue(type || "fx", []);
    				}
    
    				return this.each(function() {
    					var dequeue = true,
    						index = type != null && type + "queueHooks",
    						timers = jQuery.timers,
    						data = data_priv.get(this);
    
    					if (index) {
    						if (data[index] && data[index].stop) {
    							stopQueue(data[index]);
    						}
    					} else {
    						for (index in data) {
    							if (data[index] && data[index].stop && rrun.test(index)) {
    								stopQueue(data[index]);
    							}
    						}
    					}
    
    					for (index = timers.length; index--;) {
    						if (timers[index].elem === this && (type == null || timers[index].queue === type)) {
    							timers[index].anim.stop(gotoEnd);
    							dequeue = false;
    							timers.splice(index, 1);
    						}
    					}
    
    					// Start the next in the queue if the last step wasn't forced.
    					// Timers currently will call their complete callbacks, which
    					// will dequeue but only if they were gotoEnd.
    					if (dequeue || !gotoEnd) {
    						jQuery.dequeue(this, type);
    					}
    				});
    			},
    			finish: function(type) {
    				if (type !== false) {
    					type = type || "fx";
    				}
    				return this.each(function() {
    					var index,
    						data = data_priv.get(this),
    						queue = data[type + "queue"],
    						hooks = data[type + "queueHooks"],
    						timers = jQuery.timers,
    						length = queue ? queue.length : 0;
    
    					// Enable finishing flag on private data
    					data.finish = true;
    
    					// Empty the queue first
    					jQuery.queue(this, type, []);
    
    					if (hooks && hooks.stop) {
    						hooks.stop.call(this, true);
    					}
    
    					// Look for any active animations, and finish them
    					for (index = timers.length; index--;) {
    						if (timers[index].elem === this && timers[index].queue === type) {
    							timers[index].anim.stop(true);
    							timers.splice(index, 1);
    						}
    					}
    
    					// Look for any animations in the old queue and finish them
    					for (index = 0; index < length; index++) {
    						if (queue[index] && queue[index].finish) {
    							queue[index].finish.call(this);
    						}
    					}
    
    					// Turn off finishing flag
    					delete data.finish;
    				});
    			}
    		});
    
    		jQuery.each(["toggle", "show", "hide"], function(i, name) {
    			var cssFn = jQuery.fn[name];
    			jQuery.fn[name] = function(speed, easing, callback) {
    				return speed == null || typeof speed === "boolean" ?
    					cssFn.apply(this, arguments) :
    					this.animate(genFx(name, true), speed, easing, callback);
    			};
    		});
    
    		// Generate shortcuts for custom animations
    		jQuery.each({
    			slideDown: genFx("show"),
    			slideUp: genFx("hide"),
    			slideToggle: genFx("toggle"),
    			fadeIn: {
    				opacity: "show"
    			},
    			fadeOut: {
    				opacity: "hide"
    			},
    			fadeToggle: {
    				opacity: "toggle"
    			}
    		}, function(name, props) {
    			jQuery.fn[name] = function(speed, easing, callback) {
    				return this.animate(props, speed, easing, callback);
    			};
    		});
    
    		jQuery.timers = [];
    		jQuery.fx.tick = function() {
    			var timer,
    				i = 0,
    				timers = jQuery.timers;
    
    			fxNow = jQuery.now();
    
    			for (; i < timers.length; i++) {
    				timer = timers[i];
    				// Checks the timer has not already been removed
    				if (!timer() && timers[i] === timer) {
    					timers.splice(i--, 1);
    				}
    			}
    
    			if (!timers.length) {
    				jQuery.fx.stop();
    			}
    			fxNow = undefined;
    		};
    
    		jQuery.fx.timer = function(timer) {
    			jQuery.timers.push(timer);
    			if (timer()) {
    				jQuery.fx.start();
    			} else {
    				jQuery.timers.pop();
    			}
    		};
    
    		jQuery.fx.interval = 13;
    
    		jQuery.fx.start = function() {
    			if (!timerId) {
    				timerId = setInterval(jQuery.fx.tick, jQuery.fx.interval);
    			}
    		};
    
    		jQuery.fx.stop = function() {
    			clearInterval(timerId);
    			timerId = null;
    		};
    
    		jQuery.fx.speeds = {
    			slow: 600,
    			fast: 200,
    			// Default speed
    			_default: 400
    		};
    
    
    		// Based off of the plugin by Clint Helfers, with permission.
    		// http://blindsignals.com/index.php/2009/07/jquery-delay/
    		jQuery.fn.delay = function(time, type) {
    			time = jQuery.fx ? jQuery.fx.speeds[time] || time : time;
    			type = type || "fx";
    
    			return this.queue(type, function(next, hooks) {
    				var timeout = setTimeout(next, time);
    				hooks.stop = function() {
    					clearTimeout(timeout);
    				};
    			});
    		};
    
    
    		(function() {
    			var input = document.createElement("input"),
    				select = document.createElement("select"),
    				opt = select.appendChild(document.createElement("option"));
    
    			input.type = "checkbox";
    
    			// Support: iOS<=5.1, Android<=4.2+
    			// Default value for a checkbox should be "on"
    			support.checkOn = input.value !== "";
    
    			// Support: IE<=11+
    			// Must access selectedIndex to make default options select
    			support.optSelected = opt.selected;
    
    			// Support: Android<=2.3
    			// Options inside disabled selects are incorrectly marked as disabled
    			select.disabled = true;
    			support.optDisabled = !opt.disabled;
    
    			// Support: IE<=11+
    			// An input loses its value after becoming a radio
    			input = document.createElement("input");
    			input.value = "t";
    			input.type = "radio";
    			support.radioValue = input.value === "t";
    		})();
    
    
    		var nodeHook, boolHook,
    			attrHandle = jQuery.expr.attrHandle;
    
    		jQuery.fn.extend({
    			attr: function(name, value) {
    				return access(this, jQuery.attr, name, value, arguments.length > 1);
    			},
    
    			removeAttr: function(name) {
    				return this.each(function() {
    					jQuery.removeAttr(this, name);
    				});
    			}
    		});
    
    		jQuery.extend({
    			attr: function(elem, name, value) {
    				var hooks, ret,
    					nType = elem.nodeType;
    
    				// don't get/set attributes on text, comment and attribute nodes
    				if (!elem || nType === 3 || nType === 8 || nType === 2) {
    					return;
    				}
    
    				// Fallback to prop when attributes are not supported
    				if (typeof elem.getAttribute === strundefined) {
    					return jQuery.prop(elem, name, value);
    				}
    
    				// All attributes are lowercase
    				// Grab necessary hook if one is defined
    				if (nType !== 1 || !jQuery.isXMLDoc(elem)) {
    					name = name.toLowerCase();
    					hooks = jQuery.attrHooks[name] ||
    						(jQuery.expr.match.bool.test(name) ? boolHook : nodeHook);
    				}
    
    				if (value !== undefined) {
    
    					if (value === null) {
    						jQuery.removeAttr(elem, name);
    
    					} else if (hooks && "set" in hooks && (ret = hooks.set(elem, value, name)) !== undefined) {
    						return ret;
    
    					} else {
    						elem.setAttribute(name, value + "");
    						return value;
    					}
    
    				} else if (hooks && "get" in hooks && (ret = hooks.get(elem, name)) !== null) {
    					return ret;
    
    				} else {
    					ret = jQuery.find.attr(elem, name);
    
    					// Non-existent attributes return null, we normalize to undefined
    					return ret == null ?
    						undefined :
    						ret;
    				}
    			},
    
    			removeAttr: function(elem, value) {
    				var name, propName,
    					i = 0,
    					attrNames = value && value.match(rnotwhite);
    
    				if (attrNames && elem.nodeType === 1) {
    					while ((name = attrNames[i++])) {
    						propName = jQuery.propFix[name] || name;
    
    						// Boolean attributes get special treatment (#10870)
    						if (jQuery.expr.match.bool.test(name)) {
    							// Set corresponding property to false
    							elem[propName] = false;
    						}
    
    						elem.removeAttribute(name);
    					}
    				}
    			},
    
    			attrHooks: {
    				type: {
    					set: function(elem, value) {
    						if (!support.radioValue && value === "radio" &&
    							jQuery.nodeName(elem, "input")) {
    							var val = elem.value;
    							elem.setAttribute("type", value);
    							if (val) {
    								elem.value = val;
    							}
    							return value;
    						}
    					}
    				}
    			}
    		});
    
    		// Hooks for boolean attributes
    		boolHook = {
    			set: function(elem, value, name) {
    				if (value === false) {
    					// Remove boolean attributes when set to false
    					jQuery.removeAttr(elem, name);
    				} else {
    					elem.setAttribute(name, name);
    				}
    				return name;
    			}
    		};
    		jQuery.each(jQuery.expr.match.bool.source.match(/\w+/g), function(i, name) {
    			var getter = attrHandle[name] || jQuery.find.attr;
    
    			attrHandle[name] = function(elem, name, isXML) {
    				var ret, handle;
    				if (!isXML) {
    					// Avoid an infinite loop by temporarily removing this function from the getter
    					handle = attrHandle[name];
    					attrHandle[name] = ret;
    					ret = getter(elem, name, isXML) != null ?
    						name.toLowerCase() :
    						null;
    					attrHandle[name] = handle;
    				}
    				return ret;
    			};
    		});
    
    
    
    		var rfocusable = /^(?:input|select|textarea|button)$/i;
    
    		jQuery.fn.extend({
    			prop: function(name, value) {
    				return access(this, jQuery.prop, name, value, arguments.length > 1);
    			},
    
    			removeProp: function(name) {
    				return this.each(function() {
    					delete this[jQuery.propFix[name] || name];
    				});
    			}
    		});
    
    		jQuery.extend({
    			propFix: {
    				"for": "htmlFor",
    				"class": "className"
    			},
    
    			prop: function(elem, name, value) {
    				var ret, hooks, notxml,
    					nType = elem.nodeType;
    
    				// Don't get/set properties on text, comment and attribute nodes
    				if (!elem || nType === 3 || nType === 8 || nType === 2) {
    					return;
    				}
    
    				notxml = nType !== 1 || !jQuery.isXMLDoc(elem);
    
    				if (notxml) {
    					// Fix name and attach hooks
    					name = jQuery.propFix[name] || name;
    					hooks = jQuery.propHooks[name];
    				}
    
    				if (value !== undefined) {
    					return hooks && "set" in hooks && (ret = hooks.set(elem, value, name)) !== undefined ?
    						ret :
    						(elem[name] = value);
    
    				} else {
    					return hooks && "get" in hooks && (ret = hooks.get(elem, name)) !== null ?
    						ret :
    						elem[name];
    				}
    			},
    
    			propHooks: {
    				tabIndex: {
    					get: function(elem) {
    						return elem.hasAttribute("tabindex") || rfocusable.test(elem.nodeName) || elem.href ?
    							elem.tabIndex :
    							-1;
    					}
    				}
    			}
    		});
    
    		if (!support.optSelected) {
    			jQuery.propHooks.selected = {
    				get: function(elem) {
    					var parent = elem.parentNode;
    					if (parent && parent.parentNode) {
    						parent.parentNode.selectedIndex;
    					}
    					return null;
    				}
    			};
    		}
    
    		jQuery.each([
    			"tabIndex",
    			"readOnly",
    			"maxLength",
    			"cellSpacing",
    			"cellPadding",
    			"rowSpan",
    			"colSpan",
    			"useMap",
    			"frameBorder",
    			"contentEditable"
    		], function() {
    			jQuery.propFix[this.toLowerCase()] = this;
    		});
    
    
    
    		var rclass = /[\t\r\n\f]/g;
    
    		jQuery.fn.extend({
    			addClass: function(value) {
    				var classes, elem, cur, clazz, j, finalValue,
    					proceed = typeof value === "string" && value,
    					i = 0,
    					len = this.length;
    
    				if (jQuery.isFunction(value)) {
    					return this.each(function(j) {
    						jQuery(this).addClass(value.call(this, j, this.className));
    					});
    				}
    
    				if (proceed) {
    					// The disjunction here is for better compressibility (see removeClass)
    					classes = (value || "").match(rnotwhite) || [];
    
    					for (; i < len; i++) {
    						elem = this[i];
    						cur = elem.nodeType === 1 && (elem.className ?
    							(" " + elem.className + " ").replace(rclass, " ") :
    							" "
    						);
    
    						if (cur) {
    							j = 0;
    							while ((clazz = classes[j++])) {
    								if (cur.indexOf(" " + clazz + " ") < 0) {
    									cur += clazz + " ";
    								}
    							}
    
    							// only assign if different to avoid unneeded rendering.
    							finalValue = jQuery.trim(cur);
    							if (elem.className !== finalValue) {
    								elem.className = finalValue;
    							}
    						}
    					}
    				}
    
    				return this;
    			},
    
    			removeClass: function(value) {
    				var classes, elem, cur, clazz, j, finalValue,
    					proceed = arguments.length === 0 || typeof value === "string" && value,
    					i = 0,
    					len = this.length;
    
    				if (jQuery.isFunction(value)) {
    					return this.each(function(j) {
    						jQuery(this).removeClass(value.call(this, j, this.className));
    					});
    				}
    				if (proceed) {
    					classes = (value || "").match(rnotwhite) || [];
    
    					for (; i < len; i++) {
    						elem = this[i];
    						// This expression is here for better compressibility (see addClass)
    						cur = elem.nodeType === 1 && (elem.className ?
    							(" " + elem.className + " ").replace(rclass, " ") :
    							""
    						);
    
    						if (cur) {
    							j = 0;
    							while ((clazz = classes[j++])) {
    								// Remove *all* instances
    								while (cur.indexOf(" " + clazz + " ") >= 0) {
    									cur = cur.replace(" " + clazz + " ", " ");
    								}
    							}
    
    							// Only assign if different to avoid unneeded rendering.
    							finalValue = value ? jQuery.trim(cur) : "";
    							if (elem.className !== finalValue) {
    								elem.className = finalValue;
    							}
    						}
    					}
    				}
    
    				return this;
    			},
    
    			toggleClass: function(value, stateVal) {
    				var type = typeof value;
    
    				if (typeof stateVal === "boolean" && type === "string") {
    					return stateVal ? this.addClass(value) : this.removeClass(value);
    				}
    
    				if (jQuery.isFunction(value)) {
    					return this.each(function(i) {
    						jQuery(this).toggleClass(value.call(this, i, this.className, stateVal), stateVal);
    					});
    				}
    
    				return this.each(function() {
    					if (type === "string") {
    						// Toggle individual class names
    						var className,
    							i = 0,
    							self = jQuery(this),
    							classNames = value.match(rnotwhite) || [];
    
    						while ((className = classNames[i++])) {
    							// Check each className given, space separated list
    							if (self.hasClass(className)) {
    								self.removeClass(className);
    							} else {
    								self.addClass(className);
    							}
    						}
    
    						// Toggle whole class name
    					} else if (type === strundefined || type === "boolean") {
    						if (this.className) {
    							// store className if set
    							data_priv.set(this, "__className__", this.className);
    						}
    
    						// If the element has a class name or if we're passed `false`,
    						// then remove the whole classname (if there was one, the above saved it).
    						// Otherwise bring back whatever was previously saved (if anything),
    						// falling back to the empty string if nothing was stored.
    						this.className = this.className || value === false ? "" : data_priv.get(this, "__className__") || "";
    					}
    				});
    			},
    
    			hasClass: function(selector) {
    				var className = " " + selector + " ",
    					i = 0,
    					l = this.length;
    				for (; i < l; i++) {
    					if (this[i].nodeType === 1 && (" " + this[i].className + " ").replace(rclass, " ").indexOf(className) >= 0) {
    						return true;
    					}
    				}
    
    				return false;
    			}
    		});
    
    
    
    		var rreturn = /\r/g;
    
    		jQuery.fn.extend({
    			val: function(value) {
    				var hooks, ret, isFunction,
    					elem = this[0];
    
    				if (!arguments.length) {
    					if (elem) {
    						hooks = jQuery.valHooks[elem.type] || jQuery.valHooks[elem.nodeName.toLowerCase()];
    
    						if (hooks && "get" in hooks && (ret = hooks.get(elem, "value")) !== undefined) {
    							return ret;
    						}
    
    						ret = elem.value;
    
    						return typeof ret === "string" ?
    							// Handle most common string cases
    							ret.replace(rreturn, "") :
    							// Handle cases where value is null/undef or number
    							ret == null ? "" : ret;
    					}
    
    					return;
    				}
    
    				isFunction = jQuery.isFunction(value);
    
    				return this.each(function(i) {
    					var val;
    
    					if (this.nodeType !== 1) {
    						return;
    					}
    
    					if (isFunction) {
    						val = value.call(this, i, jQuery(this).val());
    					} else {
    						val = value;
    					}
    
    					// Treat null/undefined as ""; convert numbers to string
    					if (val == null) {
    						val = "";
    
    					} else if (typeof val === "number") {
    						val += "";
    
    					} else if (jQuery.isArray(val)) {
    						val = jQuery.map(val, function(value) {
    							return value == null ? "" : value + "";
    						});
    					}
    
    					hooks = jQuery.valHooks[this.type] || jQuery.valHooks[this.nodeName.toLowerCase()];
    
    					// If set returns undefined, fall back to normal setting
    					if (!hooks || !("set" in hooks) || hooks.set(this, val, "value") === undefined) {
    						this.value = val;
    					}
    				});
    			}
    		});
    
    		jQuery.extend({
    			valHooks: {
    				option: {
    					get: function(elem) {
    						var val = jQuery.find.attr(elem, "value");
    						return val != null ?
    							val :
    							// Support: IE10-11+
    							// option.text throws exceptions (#14686, #14858)
    							jQuery.trim(jQuery.text(elem));
    					}
    				},
    				select: {
    					get: function(elem) {
    						var value, option,
    							options = elem.options,
    							index = elem.selectedIndex,
    							one = elem.type === "select-one" || index < 0,
    							values = one ? null : [],
    							max = one ? index + 1 : options.length,
    							i = index < 0 ?
    							max :
    							one ? index : 0;
    
    						// Loop through all the selected options
    						for (; i < max; i++) {
    							option = options[i];
    
    							// IE6-9 doesn't update selected after form reset (#2551)
    							if ((option.selected || i === index) &&
    								// Don't return options that are disabled or in a disabled optgroup
    								(support.optDisabled ? !option.disabled : option.getAttribute("disabled") === null) &&
    								(!option.parentNode.disabled || !jQuery.nodeName(option.parentNode, "optgroup"))) {
    
    								// Get the specific value for the option
    								value = jQuery(option).val();
    
    								// We don't need an array for one selects
    								if (one) {
    									return value;
    								}
    
    								// Multi-Selects return an array
    								values.push(value);
    							}
    						}
    
    						return values;
    					},
    
    					set: function(elem, value) {
    						var optionSet, option,
    							options = elem.options,
    							values = jQuery.makeArray(value),
    							i = options.length;
    
    						while (i--) {
    							option = options[i];
    							if ((option.selected = jQuery.inArray(option.value, values) >= 0)) {
    								optionSet = true;
    							}
    						}
    
    						// Force browsers to behave consistently when non-matching value is set
    						if (!optionSet) {
    							elem.selectedIndex = -1;
    						}
    						return values;
    					}
    				}
    			}
    		});
    
    		// Radios and checkboxes getter/setter
    		jQuery.each(["radio", "checkbox"], function() {
    			jQuery.valHooks[this] = {
    				set: function(elem, value) {
    					if (jQuery.isArray(value)) {
    						return (elem.checked = jQuery.inArray(jQuery(elem).val(), value) >= 0);
    					}
    				}
    			};
    			if (!support.checkOn) {
    				jQuery.valHooks[this].get = function(elem) {
    					return elem.getAttribute("value") === null ? "on" : elem.value;
    				};
    			}
    		});
    
    
    
    		// Return jQuery for attributes-only inclusion
    
    
    		jQuery.each(("blur focus focusin focusout load resize scroll unload click dblclick " +
    			"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
    			"change select submit keydown keypress keyup error contextmenu").split(" "), function(i, name) {
    
    			// Handle event binding
    			jQuery.fn[name] = function(data, fn) {
    				return arguments.length > 0 ?
    					this.on(name, null, data, fn) :
    					this.trigger(name);
    			};
    		});
    
    		jQuery.fn.extend({
    			hover: function(fnOver, fnOut) {
    				return this.mouseenter(fnOver).mouseleave(fnOut || fnOver);
    			},
    
    			bind: function(types, data, fn) {
    				return this.on(types, null, data, fn);
    			},
    			unbind: function(types, fn) {
    				return this.off(types, null, fn);
    			},
    
    			delegate: function(selector, types, data, fn) {
    				return this.on(types, selector, data, fn);
    			},
    			undelegate: function(selector, types, fn) {
    				// ( namespace ) or ( selector, types [, fn] )
    				return arguments.length === 1 ? this.off(selector, "**") : this.off(types, selector || "**", fn);
    			}
    		});
    
    
    		var nonce = jQuery.now();
    
    		var rquery = (/\?/);
    
    
    
    		// Support: Android 2.3
    		// Workaround failure to string-cast null input
    		jQuery.parseJSON = function(data) {
    			return JSON.parse(data + "");
    		};
    
    
    		// Cross-browser xml parsing
    		jQuery.parseXML = function(data) {
    			var xml, tmp;
    			if (!data || typeof data !== "string") {
    				return null;
    			}
    
    			// Support: IE9
    			try {
    				tmp = new DOMParser();
    				xml = tmp.parseFromString(data, "text/xml");
    			} catch (e) {
    				xml = undefined;
    			}
    
    			if (!xml || xml.getElementsByTagName("parsererror").length) {
    				jQuery.error("Invalid XML: " + data);
    			}
    			return xml;
    		};
    
    
    		var
    			rhash = /#.*$/,
    			rts = /([?&])_=[^&]*/,
    			rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg,
    			// #7653, #8125, #8152: local protocol detection
    			rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
    			rnoContent = /^(?:GET|HEAD)$/,
    			rprotocol = /^\/\//,
    			rurl = /^([\w.+-]+:)(?:\/\/(?:[^\/?#]*@|)([^\/?#:]*)(?::(\d+)|)|)/,
    
    			
    			prefilters = {},
    
    			
    			transports = {},
    
    			// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
    			allTypes = "*/".concat("*"),
    
    			// Document location
    			ajaxLocation = window.location.href,
    
    			// Segment location into parts
    			ajaxLocParts = rurl.exec(ajaxLocation.toLowerCase()) || [];
    
    		// Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
    		function addToPrefiltersOrTransports(structure) {
    
    			// dataTypeExpression is optional and defaults to "*"
    			return function(dataTypeExpression, func) {
    
    				if (typeof dataTypeExpression !== "string") {
    					func = dataTypeExpression;
    					dataTypeExpression = "*";
    				}
    
    				var dataType,
    					i = 0,
    					dataTypes = dataTypeExpression.toLowerCase().match(rnotwhite) || [];
    
    				if (jQuery.isFunction(func)) {
    					// For each dataType in the dataTypeExpression
    					while ((dataType = dataTypes[i++])) {
    						// Prepend if requested
    						if (dataType[0] === "+") {
    							dataType = dataType.slice(1) || "*";
    							(structure[dataType] = structure[dataType] || []).unshift(func);
    
    							// Otherwise append
    						} else {
    							(structure[dataType] = structure[dataType] || []).push(func);
    						}
    					}
    				}
    			};
    		}
    
    		// Base inspection function for prefilters and transports
    		function inspectPrefiltersOrTransports(structure, options, originalOptions, jqXHR) {
    
    			var inspected = {},
    				seekingTransport = (structure === transports);
    
    			function inspect(dataType) {
    				var selected;
    				inspected[dataType] = true;
    				jQuery.each(structure[dataType] || [], function(_, prefilterOrFactory) {
    					var dataTypeOrTransport = prefilterOrFactory(options, originalOptions, jqXHR);
    					if (typeof dataTypeOrTransport === "string" && !seekingTransport && !inspected[dataTypeOrTransport]) {
    						options.dataTypes.unshift(dataTypeOrTransport);
    						inspect(dataTypeOrTransport);
    						return false;
    					} else if (seekingTransport) {
    						return !(selected = dataTypeOrTransport);
    					}
    				});
    				return selected;
    			}
    
    			return inspect(options.dataTypes[0]) || !inspected["*"] && inspect("*");
    		}
    
    		// A special extend for ajax options
    		// that takes "flat" options (not to be deep extended)
    		// Fixes #9887
    		function ajaxExtend(target, src) {
    			var key, deep,
    				flatOptions = jQuery.ajaxSettings.flatOptions || {};
    
    			for (key in src) {
    				if (src[key] !== undefined) {
    					(flatOptions[key] ? target : (deep || (deep = {})))[key] = src[key];
    				}
    			}
    			if (deep) {
    				jQuery.extend(true, target, deep);
    			}
    
    			return target;
    		}
    
    		
    		function ajaxHandleResponses(s, jqXHR, responses) {
    
    			var ct, type, finalDataType, firstDataType,
    				contents = s.contents,
    				dataTypes = s.dataTypes;
    
    			// Remove auto dataType and get content-type in the process
    			while (dataTypes[0] === "*") {
    				dataTypes.shift();
    				if (ct === undefined) {
    					ct = s.mimeType || jqXHR.getResponseHeader("Content-Type");
    				}
    			}
    
    			// Check if we're dealing with a known content-type
    			if (ct) {
    				for (type in contents) {
    					if (contents[type] && contents[type].test(ct)) {
    						dataTypes.unshift(type);
    						break;
    					}
    				}
    			}
    
    			// Check to see if we have a response for the expected dataType
    			if (dataTypes[0] in responses) {
    				finalDataType = dataTypes[0];
    			} else {
    				// Try convertible dataTypes
    				for (type in responses) {
    					if (!dataTypes[0] || s.converters[type + " " + dataTypes[0]]) {
    						finalDataType = type;
    						break;
    					}
    					if (!firstDataType) {
    						firstDataType = type;
    					}
    				}
    				// Or just use first one
    				finalDataType = finalDataType || firstDataType;
    			}
    
    			// If we found a dataType
    			// We add the dataType to the list if needed
    			// and return the corresponding response
    			if (finalDataType) {
    				if (finalDataType !== dataTypes[0]) {
    					dataTypes.unshift(finalDataType);
    				}
    				return responses[finalDataType];
    			}
    		}
    
    		
    		function ajaxConvert(s, response, jqXHR, isSuccess) {
    			var conv2, current, conv, tmp, prev,
    				converters = {},
    				// Work with a copy of dataTypes in case we need to modify it for conversion
    				dataTypes = s.dataTypes.slice();
    
    			// Create converters map with lowercased keys
    			if (dataTypes[1]) {
    				for (conv in s.converters) {
    					converters[conv.toLowerCase()] = s.converters[conv];
    				}
    			}
    
    			current = dataTypes.shift();
    
    			// Convert to each sequential dataType
    			while (current) {
    
    				if (s.responseFields[current]) {
    					jqXHR[s.responseFields[current]] = response;
    				}
    
    				// Apply the dataFilter if provided
    				if (!prev && isSuccess && s.dataFilter) {
    					response = s.dataFilter(response, s.dataType);
    				}
    
    				prev = current;
    				current = dataTypes.shift();
    
    				if (current) {
    
    					// There's only work to do if current dataType is non-auto
    					if (current === "*") {
    
    						current = prev;
    
    						// Convert response if prev dataType is non-auto and differs from current
    					} else if (prev !== "*" && prev !== current) {
    
    						// Seek a direct converter
    						conv = converters[prev + " " + current] || converters["* " + current];
    
    						// If none found, seek a pair
    						if (!conv) {
    							for (conv2 in converters) {
    
    								// If conv2 outputs current
    								tmp = conv2.split(" ");
    								if (tmp[1] === current) {
    
    									// If prev can be converted to accepted input
    									conv = converters[prev + " " + tmp[0]] ||
    										converters["* " + tmp[0]];
    									if (conv) {
    										// Condense equivalence converters
    										if (conv === true) {
    											conv = converters[conv2];
    
    											// Otherwise, insert the intermediate dataType
    										} else if (converters[conv2] !== true) {
    											current = tmp[0];
    											dataTypes.unshift(tmp[1]);
    										}
    										break;
    									}
    								}
    							}
    						}
    
    						// Apply converter (if not an equivalence)
    						if (conv !== true) {
    
    							// Unless errors are allowed to bubble, catch and return them
    							if (conv && s["throws"]) {
    								response = conv(response);
    							} else {
    								try {
    									response = conv(response);
    								} catch (e) {
    									return {
    										state: "parsererror",
    										error: conv ? e : "No conversion from " + prev + " to " + current
    									};
    								}
    							}
    						}
    					}
    				}
    			}
    
    			return {
    				state: "success",
    				data: response
    			};
    		}
    
    		jQuery.extend({
    
    			// Counter for holding the number of active queries
    			active: 0,
    
    			// Last-Modified header cache for next request
    			lastModified: {},
    			etag: {},
    
    			ajaxSettings: {
    				url: ajaxLocation,
    				type: "GET",
    				isLocal: rlocalProtocol.test(ajaxLocParts[1]),
    				global: true,
    				processData: true,
    				async: true,
    				contentType: "application/x-www-form-urlencoded; charset=UTF-8",
    				
    
    				accepts: {
    					"*": allTypes,
    					text: "text/plain",
    					html: "text/html",
    					xml: "application/xml, text/xml",
    					json: "application/json, text/javascript"
    				},
    
    				contents: {
    					xml: /xml/,
    					html: /html/,
    					json: /json/
    				},
    
    				responseFields: {
    					xml: "responseXML",
    					text: "responseText",
    					json: "responseJSON"
    				},
    
    				// Data converters
    				// Keys separate source (or catchall "*") and destination types with a single space
    				converters: {
    
    					// Convert anything to text
    					"* text": String,
    
    					// Text to html (true = no transformation)
    					"text html": true,
    
    					// Evaluate text as a json expression
    					"text json": jQuery.parseJSON,
    
    					// Parse text as xml
    					"text xml": jQuery.parseXML
    				},
    
    				// For options that shouldn't be deep extended:
    				// you can add your own custom options here if
    				// and when you create one that shouldn't be
    				// deep extended (see ajaxExtend)
    				flatOptions: {
    					url: true,
    					context: true
    				}
    			},
    
    			// Creates a full fledged settings object into target
    			// with both ajaxSettings and settings fields.
    			// If target is omitted, writes into ajaxSettings.
    			ajaxSetup: function(target, settings) {
    				return settings ?
    
    					// Building a settings object
    					ajaxExtend(ajaxExtend(target, jQuery.ajaxSettings), settings) :
    
    					// Extending ajaxSettings
    					ajaxExtend(jQuery.ajaxSettings, target);
    			},
    
    			ajaxPrefilter: addToPrefiltersOrTransports(prefilters),
    			ajaxTransport: addToPrefiltersOrTransports(transports),
    
    			// Main method
    			ajax: function(url, options) {
    
    				// If url is an object, simulate pre-1.5 signature
    				if (typeof url === "object") {
    					options = url;
    					url = undefined;
    				}
    
    				// Force options to be an object
    				options = options || {};
    
    				var transport,
    					// URL without anti-cache param
    					cacheURL,
    					// Response headers
    					responseHeadersString,
    					responseHeaders,
    					// timeout handle
    					timeoutTimer,
    					// Cross-domain detection vars
    					parts,
    					// To know if global events are to be dispatched
    					fireGlobals,
    					// Loop variable
    					i,
    					// Create the final options object
    					s = jQuery.ajaxSetup({}, options),
    					// Callbacks context
    					callbackContext = s.context || s,
    					// Context for global events is callbackContext if it is a DOM node or jQuery collection
    					globalEventContext = s.context && (callbackContext.nodeType || callbackContext.jquery) ?
    					jQuery(callbackContext) :
    					jQuery.event,
    					// Deferreds
    					deferred = jQuery.Deferred(),
    					completeDeferred = jQuery.Callbacks("once memory"),
    					// Status-dependent callbacks
    					statusCode = s.statusCode || {},
    					// Headers (they are sent all at once)
    					requestHeaders = {},
    					requestHeadersNames = {},
    					// The jqXHR state
    					state = 0,
    					// Default abort message
    					strAbort = "canceled",
    					// Fake xhr
    					jqXHR = {
    						readyState: 0,
    
    						// Builds headers hashtable if needed
    						getResponseHeader: function(key) {
    							var match;
    							if (state === 2) {
    								if (!responseHeaders) {
    									responseHeaders = {};
    									while ((match = rheaders.exec(responseHeadersString))) {
    										responseHeaders[match[1].toLowerCase()] = match[2];
    									}
    								}
    								match = responseHeaders[key.toLowerCase()];
    							}
    							return match == null ? null : match;
    						},
    
    						// Raw string
    						getAllResponseHeaders: function() {
    							return state === 2 ? responseHeadersString : null;
    						},
    
    						// Caches the header
    						setRequestHeader: function(name, value) {
    							var lname = name.toLowerCase();
    							if (!state) {
    								name = requestHeadersNames[lname] = requestHeadersNames[lname] || name;
    								requestHeaders[name] = value;
    							}
    							return this;
    						},
    
    						// Overrides response content-type header
    						overrideMimeType: function(type) {
    							if (!state) {
    								s.mimeType = type;
    							}
    							return this;
    						},
    
    						// Status-dependent callbacks
    						statusCode: function(map) {
    							var code;
    							if (map) {
    								if (state < 2) {
    									for (code in map) {
    										// Lazy-add the new callback in a way that preserves old ones
    										statusCode[code] = [statusCode[code], map[code]];
    									}
    								} else {
    									// Execute the appropriate callbacks
    									jqXHR.always(map[jqXHR.status]);
    								}
    							}
    							return this;
    						},
    
    						// Cancel the request
    						abort: function(statusText) {
    							var finalText = statusText || strAbort;
    							if (transport) {
    								transport.abort(finalText);
    							}
    							done(0, finalText);
    							return this;
    						}
    					};
    
    				// Attach deferreds
    				deferred.promise(jqXHR).complete = completeDeferred.add;
    				jqXHR.success = jqXHR.done;
    				jqXHR.error = jqXHR.fail;
    
    				// Remove hash character (#7531: and string promotion)
    				// Add protocol if not provided (prefilters might expect it)
    				// Handle falsy url in the settings object (#10093: consistency with old signature)
    				// We also use the url parameter if available
    				s.url = ((url || s.url || ajaxLocation) + "").replace(rhash, "")
    					.replace(rprotocol, ajaxLocParts[1] + "//");
    
    				// Alias method option to type as per ticket #12004
    				s.type = options.method || options.type || s.method || s.type;
    
    				// Extract dataTypes list
    				s.dataTypes = jQuery.trim(s.dataType || "*").toLowerCase().match(rnotwhite) || [""];
    
    				// A cross-domain request is in order when we have a protocol:host:port mismatch
    				if (s.crossDomain == null) {
    					parts = rurl.exec(s.url.toLowerCase());
    					s.crossDomain = !!(parts &&
    						(parts[1] !== ajaxLocParts[1] || parts[2] !== ajaxLocParts[2] ||
    							(parts[3] || (parts[1] === "http:" ? "80" : "443")) !==
    							(ajaxLocParts[3] || (ajaxLocParts[1] === "http:" ? "80" : "443")))
    					);
    				}
    
    				// Convert data if not already a string
    				if (s.data && s.processData && typeof s.data !== "string") {
    					s.data = jQuery.param(s.data, s.traditional);
    				}
    
    				// Apply prefilters
    				inspectPrefiltersOrTransports(prefilters, s, options, jqXHR);
    
    				// If request was aborted inside a prefilter, stop there
    				if (state === 2) {
    					return jqXHR;
    				}
    
    				// We can fire global events as of now if asked to
    				// Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)
    				fireGlobals = jQuery.event && s.global;
    
    				// Watch for a new set of requests
    				if (fireGlobals && jQuery.active++ === 0) {
    					jQuery.event.trigger("ajaxStart");
    				}
    
    				// Uppercase the type
    				s.type = s.type.toUpperCase();
    
    				// Determine if request has content
    				s.hasContent = !rnoContent.test(s.type);
    
    				// Save the URL in case we're toying with the If-Modified-Since
    				// and/or If-None-Match header later on
    				cacheURL = s.url;
    
    				// More options handling for requests with no content
    				if (!s.hasContent) {
    
    					// If data is available, append data to url
    					if (s.data) {
    						cacheURL = (s.url += (rquery.test(cacheURL) ? "&" : "?") + s.data);
    						// #9682: remove data so that it's not used in an eventual retry
    						delete s.data;
    					}
    
    					// Add anti-cache in url if needed
    					if (s.cache === false) {
    						s.url = rts.test(cacheURL) ?
    
    							// If there is already a '_' parameter, set its value
    							cacheURL.replace(rts, "$1_=" + nonce++) :
    
    							// Otherwise add one to the end
    							cacheURL + (rquery.test(cacheURL) ? "&" : "?") + "_=" + nonce++;
    					}
    				}
    
    				// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
    				if (s.ifModified) {
    					if (jQuery.lastModified[cacheURL]) {
    						jqXHR.setRequestHeader("If-Modified-Since", jQuery.lastModified[cacheURL]);
    					}
    					if (jQuery.etag[cacheURL]) {
    						jqXHR.setRequestHeader("If-None-Match", jQuery.etag[cacheURL]);
    					}
    				}
    
    				// Set the correct header, if data is being sent
    				if (s.data && s.hasContent && s.contentType !== false || options.contentType) {
    					jqXHR.setRequestHeader("Content-Type", s.contentType);
    				}
    
    				// Set the Accepts header for the server, depending on the dataType
    				jqXHR.setRequestHeader(
    					"Accept",
    					s.dataTypes[0] && s.accepts[s.dataTypes[0]] ?
    					s.accepts[s.dataTypes[0]] + (s.dataTypes[0] !== "*" ? ", " + allTypes + "; q=0.01" : "") :
    					s.accepts["*"]
    				);
    
    				// Check for headers option
    				for (i in s.headers) {
    					jqXHR.setRequestHeader(i, s.headers[i]);
    				}
    
    				// Allow custom headers/mimetypes and early abort
    				if (s.beforeSend && (s.beforeSend.call(callbackContext, jqXHR, s) === false || state === 2)) {
    					// Abort if not done already and return
    					return jqXHR.abort();
    				}
    
    				// Aborting is no longer a cancellation
    				strAbort = "abort";
    
    				// Install callbacks on deferreds
    				for (i in {
    						success: 1,
    						error: 1,
    						complete: 1
    					}) {
    					jqXHR[i](s[i]);
    				}
    
    				// Get transport
    				transport = inspectPrefiltersOrTransports(transports, s, options, jqXHR);
    
    				// If no transport, we auto-abort
    				if (!transport) {
    					done(-1, "No Transport");
    				} else {
    					jqXHR.readyState = 1;
    
    					// Send global event
    					if (fireGlobals) {
    						globalEventContext.trigger("ajaxSend", [jqXHR, s]);
    					}
    					// Timeout
    					if (s.async && s.timeout > 0) {
    						timeoutTimer = setTimeout(function() {
    							jqXHR.abort("timeout");
    						}, s.timeout);
    					}
    
    					try {
    						state = 1;
    						transport.send(requestHeaders, done);
    					} catch (e) {
    						// Propagate exception as error if not done
    						if (state < 2) {
    							done(-1, e);
    							// Simply rethrow otherwise
    						} else {
    							throw e;
    						}
    					}
    				}
    
    				// Callback for when everything is done
    				function done(status, nativeStatusText, responses, headers) {
    					var isSuccess, success, error, response, modified,
    						statusText = nativeStatusText;
    
    					// Called once
    					if (state === 2) {
    						return;
    					}
    
    					// State is "done" now
    					state = 2;
    
    					// Clear timeout if it exists
    					if (timeoutTimer) {
    						clearTimeout(timeoutTimer);
    					}
    
    					// Dereference transport for early garbage collection
    					// (no matter how long the jqXHR object will be used)
    					transport = undefined;
    
    					// Cache response headers
    					responseHeadersString = headers || "";
    
    					// Set readyState
    					jqXHR.readyState = status > 0 ? 4 : 0;
    
    					// Determine if successful
    					isSuccess = status >= 200 && status < 300 || status === 304;
    
    					// Get response data
    					if (responses) {
    						response = ajaxHandleResponses(s, jqXHR, responses);
    					}
    
    					// Convert no matter what (that way responseXXX fields are always set)
    					response = ajaxConvert(s, response, jqXHR, isSuccess);
    
    					// If successful, handle type chaining
    					if (isSuccess) {
    
    						// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
    						if (s.ifModified) {
    							modified = jqXHR.getResponseHeader("Last-Modified");
    							if (modified) {
    								jQuery.lastModified[cacheURL] = modified;
    							}
    							modified = jqXHR.getResponseHeader("etag");
    							if (modified) {
    								jQuery.etag[cacheURL] = modified;
    							}
    						}
    
    						// if no content
    						if (status === 204 || s.type === "HEAD") {
    							statusText = "nocontent";
    
    							// if not modified
    						} else if (status === 304) {
    							statusText = "notmodified";
    
    							// If we have data, let's convert it
    						} else {
    							statusText = response.state;
    							success = response.data;
    							error = response.error;
    							isSuccess = !error;
    						}
    					} else {
    						// Extract error from statusText and normalize for non-aborts
    						error = statusText;
    						if (status || !statusText) {
    							statusText = "error";
    							if (status < 0) {
    								status = 0;
    							}
    						}
    					}
    
    					// Set data for the fake xhr object
    					jqXHR.status = status;
    					jqXHR.statusText = (nativeStatusText || statusText) + "";
    
    					// Success/Error
    					if (isSuccess) {
    						deferred.resolveWith(callbackContext, [success, statusText, jqXHR]);
    					} else {
    						deferred.rejectWith(callbackContext, [jqXHR, statusText, error]);
    					}
    
    					// Status-dependent callbacks
    					jqXHR.statusCode(statusCode);
    					statusCode = undefined;
    
    					if (fireGlobals) {
    						globalEventContext.trigger(isSuccess ? "ajaxSuccess" : "ajaxError", [jqXHR, s, isSuccess ? success : error]);
    					}
    
    					// Complete
    					completeDeferred.fireWith(callbackContext, [jqXHR, statusText]);
    
    					if (fireGlobals) {
    						globalEventContext.trigger("ajaxComplete", [jqXHR, s]);
    						// Handle the global AJAX counter
    						if (!(--jQuery.active)) {
    							jQuery.event.trigger("ajaxStop");
    						}
    					}
    				}
    
    				return jqXHR;
    			},
    
    			getJSON: function(url, data, callback) {
    				return jQuery.get(url, data, callback, "json");
    			},
    
    			getScript: function(url, callback) {
    				return jQuery.get(url, undefined, callback, "script");
    			}
    		});
    
    		jQuery.each(["get", "post"], function(i, method) {
    			jQuery[method] = function(url, data, callback, type) {
    				// Shift arguments if data argument was omitted
    				if (jQuery.isFunction(data)) {
    					type = type || callback;
    					callback = data;
    					data = undefined;
    				}
    
    				return jQuery.ajax({
    					url: url,
    					type: method,
    					dataType: type,
    					data: data,
    					success: callback
    				});
    			};
    		});
    
    
    		jQuery._evalUrl = function(url) {
    			return jQuery.ajax({
    				url: url,
    				type: "GET",
    				dataType: "script",
    				async: false,
    				global: false,
    				"throws": true
    			});
    		};
    
    
    		jQuery.fn.extend({
    			wrapAll: function(html) {
    				var wrap;
    
    				if (jQuery.isFunction(html)) {
    					return this.each(function(i) {
    						jQuery(this).wrapAll(html.call(this, i));
    					});
    				}
    
    				if (this[0]) {
    
    					// The elements to wrap the target around
    					wrap = jQuery(html, this[0].ownerDocument).eq(0).clone(true);
    
    					if (this[0].parentNode) {
    						wrap.insertBefore(this[0]);
    					}
    
    					wrap.map(function() {
    						var elem = this;
    
    						while (elem.firstElementChild) {
    							elem = elem.firstElementChild;
    						}
    
    						return elem;
    					}).append(this);
    				}
    
    				return this;
    			},
    
    			wrapInner: function(html) {
    				if (jQuery.isFunction(html)) {
    					return this.each(function(i) {
    						jQuery(this).wrapInner(html.call(this, i));
    					});
    				}
    
    				return this.each(function() {
    					var self = jQuery(this),
    						contents = self.contents();
    
    					if (contents.length) {
    						contents.wrapAll(html);
    
    					} else {
    						self.append(html);
    					}
    				});
    			},
    
    			wrap: function(html) {
    				var isFunction = jQuery.isFunction(html);
    
    				return this.each(function(i) {
    					jQuery(this).wrapAll(isFunction ? html.call(this, i) : html);
    				});
    			},
    
    			unwrap: function() {
    				return this.parent().each(function() {
    					if (!jQuery.nodeName(this, "body")) {
    						jQuery(this).replaceWith(this.childNodes);
    					}
    				}).end();
    			}
    		});
    
    
    		jQuery.expr.filters.hidden = function(elem) {
    			// Support: Opera <= 12.12
    			// Opera reports offsetWidths and offsetHeights less than zero on some elements
    			return elem.offsetWidth <= 0 && elem.offsetHeight <= 0;
    		};
    		jQuery.expr.filters.visible = function(elem) {
    			return !jQuery.expr.filters.hidden(elem);
    		};
    
    
    
    		var r20 = /%20/g,
    			rbracket = /\[\]$/,
    			rCRLF = /\r?\n/g,
    			rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
    			rsubmittable = /^(?:input|select|textarea|keygen)/i;
    
    		function buildParams(prefix, obj, traditional, add) {
    			var name;
    
    			if (jQuery.isArray(obj)) {
    				// Serialize array item.
    				jQuery.each(obj, function(i, v) {
    					if (traditional || rbracket.test(prefix)) {
    						// Treat each array item as a scalar.
    						add(prefix, v);
    
    					} else {
    						// Item is non-scalar (array or object), encode its numeric index.
    						buildParams(prefix + "[" + (typeof v === "object" ? i : "") + "]", v, traditional, add);
    					}
    				});
    
    			} else if (!traditional && jQuery.type(obj) === "object") {
    				// Serialize object item.
    				for (name in obj) {
    					buildParams(prefix + "[" + name + "]", obj[name], traditional, add);
    				}
    
    			} else {
    				// Serialize scalar item.
    				add(prefix, obj);
    			}
    		}
    
    		// Serialize an array of form elements or a set of
    		// key/values into a query string
    		jQuery.param = function(a, traditional) {
    			var prefix,
    				s = [],
    				add = function(key, value) {
    					// If value is a function, invoke it and return its value
    					value = jQuery.isFunction(value) ? value() : (value == null ? "" : value);
    					s[s.length] = encodeURIComponent(key) + "=" + encodeURIComponent(value);
    				};
    
    			// Set traditional to true for jQuery <= 1.3.2 behavior.
    			if (traditional === undefined) {
    				traditional = jQuery.ajaxSettings && jQuery.ajaxSettings.traditional;
    			}
    
    			// If an array was passed in, assume that it is an array of form elements.
    			if (jQuery.isArray(a) || (a.jquery && !jQuery.isPlainObject(a))) {
    				// Serialize the form elements
    				jQuery.each(a, function() {
    					add(this.name, this.value);
    				});
    
    			} else {
    				// If traditional, encode the "old" way (the way 1.3.2 or older
    				// did it), otherwise encode params recursively.
    				for (prefix in a) {
    					buildParams(prefix, a[prefix], traditional, add);
    				}
    			}
    
    			// Return the resulting serialization
    			return s.join("&").replace(r20, "+");
    		};
    
    		jQuery.fn.extend({
    			serialize: function() {
    				return jQuery.param(this.serializeArray());
    			},
    			serializeArray: function() {
    				return this.map(function() {
    						// Can add propHook for "elements" to filter or add form elements
    						var elements = jQuery.prop(this, "elements");
    						return elements ? jQuery.makeArray(elements) : this;
    					})
    					.filter(function() {
    						var type = this.type;
    
    						// Use .is( ":disabled" ) so that fieldset[disabled] works
    						return this.name && !jQuery(this).is(":disabled") &&
    							rsubmittable.test(this.nodeName) && !rsubmitterTypes.test(type) &&
    							(this.checked || !rcheckableType.test(type));
    					})
    					.map(function(i, elem) {
    						var val = jQuery(this).val();
    
    						return val == null ?
    							null :
    							jQuery.isArray(val) ?
    							jQuery.map(val, function(val) {
    								return {
    									name: elem.name,
    									value: val.replace(rCRLF, "\r\n")
    								};
    							}) : {
    								name: elem.name,
    								value: val.replace(rCRLF, "\r\n")
    							};
    					}).get();
    			}
    		});
    
    
    		jQuery.ajaxSettings.xhr = function() {
    			try {
    				return new XMLHttpRequest();
    			} catch (e) {}
    		};
    
    		var xhrId = 0,
    			xhrCallbacks = {},
    			xhrSuccessStatus = {
    				// file protocol always yields status code 0, assume 200
    				0: 200,
    				// Support: IE9
    				// #1450: sometimes IE returns 1223 when it should be 204
    				1223: 204
    			},
    			xhrSupported = jQuery.ajaxSettings.xhr();
    
    		// Support: IE9
    		// Open requests must be manually aborted on unload (#5280)
    		// See https://support.microsoft.com/kb/2856746 for more info
    		if (window.attachEvent) {
    			window.attachEvent("onunload", function() {
    				for (var key in xhrCallbacks) {
    					xhrCallbacks[key]();
    				}
    			});
    		}
    
    		support.cors = !!xhrSupported && ("withCredentials" in xhrSupported);
    		support.ajax = xhrSupported = !!xhrSupported;
    
    		jQuery.ajaxTransport(function(options) {
    			var callback;
    
    			// Cross domain only allowed if supported through XMLHttpRequest
    			if (support.cors || xhrSupported && !options.crossDomain) {
    				return {
    					send: function(headers, complete) {
    						var i,
    							xhr = options.xhr(),
    							id = ++xhrId;
    
    						xhr.open(options.type, options.url, options.async, options.username, options.password);
    
    						// Apply custom fields if provided
    						if (options.xhrFields) {
    							for (i in options.xhrFields) {
    								xhr[i] = options.xhrFields[i];
    							}
    						}
    
    						// Override mime type if needed
    						if (options.mimeType && xhr.overrideMimeType) {
    							xhr.overrideMimeType(options.mimeType);
    						}
    
    						// X-Requested-With header
    						// For cross-domain requests, seeing as conditions for a preflight are
    						// akin to a jigsaw puzzle, we simply never set it to be sure.
    						// (it can always be set on a per-request basis or even using ajaxSetup)
    						// For same-domain requests, won't change header if already provided.
    						if (!options.crossDomain && !headers["X-Requested-With"]) {
    							headers["X-Requested-With"] = "XMLHttpRequest";
    						}
    
    						// Set headers
    						for (i in headers) {
    							xhr.setRequestHeader(i, headers[i]);
    						}
    
    						// Callback
    						callback = function(type) {
    							return function() {
    								if (callback) {
    									delete xhrCallbacks[id];
    									callback = xhr.onload = xhr.onerror = null;
    
    									if (type === "abort") {
    										xhr.abort();
    									} else if (type === "error") {
    										complete(
    											// file: protocol always yields status 0; see #8605, #14207
    											xhr.status,
    											xhr.statusText
    										);
    									} else {
    										complete(
    											xhrSuccessStatus[xhr.status] || xhr.status,
    											xhr.statusText,
    											// Support: IE9
    											// Accessing binary-data responseText throws an exception
    											// (#11426)
    											typeof xhr.responseText === "string" ? {
    												text: xhr.responseText
    											} : undefined,
    											xhr.getAllResponseHeaders()
    										);
    									}
    								}
    							};
    						};
    
    						// Listen to events
    						xhr.onload = callback();
    						xhr.onerror = callback("error");
    
    						// Create the abort callback
    						callback = xhrCallbacks[id] = callback("abort");
    
    						try {
    							// Do send the request (this may raise an exception)
    							xhr.send(options.hasContent && options.data || null);
    						} catch (e) {
    							// #14683: Only rethrow if this hasn't been notified as an error yet
    							if (callback) {
    								throw e;
    							}
    						}
    					},
    
    					abort: function() {
    						if (callback) {
    							callback();
    						}
    					}
    				};
    			}
    		});
    
    
    
    		// Install script dataType
    		jQuery.ajaxSetup({
    			accepts: {
    				script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
    			},
    			contents: {
    				script: /(?:java|ecma)script/
    			},
    			converters: {
    				"text script": function(text) {
    					jQuery.globalEval(text);
    					return text;
    				}
    			}
    		});
    
    		// Handle cache's special case and crossDomain
    		jQuery.ajaxPrefilter("script", function(s) {
    			if (s.cache === undefined) {
    				s.cache = false;
    			}
    			if (s.crossDomain) {
    				s.type = "GET";
    			}
    		});
    
    		// Bind script tag hack transport
    		jQuery.ajaxTransport("script", function(s) {
    			// This transport only deals with cross domain requests
    			if (s.crossDomain) {
    				var script, callback;
    				return {
    					send: function(_, complete) {
    						script = jQuery("<script>").prop({
    							async: true,
    							charset: s.scriptCharset,
    							src: s.url
    						}).on(
    							"load error",
    							callback = function(evt) {
    								script.remove();
    								callback = null;
    								if (evt) {
    									complete(evt.type === "error" ? 404 : 200, evt.type);
    								}
    							}
    						);
    						document.head.appendChild(script[0]);
    					},
    					abort: function() {
    						if (callback) {
    							callback();
    						}
    					}
    				};
    			}
    		});
    
    
    
    		var oldCallbacks = [],
    			rjsonp = /(=)\?(?=&|$)|\?\?/;
    
    		// Default jsonp settings
    		jQuery.ajaxSetup({
    			jsonp: "callback",
    			jsonpCallback: function() {
    				var callback = oldCallbacks.pop() || (jQuery.expando + "_" + (nonce++));
    				this[callback] = true;
    				return callback;
    			}
    		});
    
    		// Detect, normalize options and install callbacks for jsonp requests
    		jQuery.ajaxPrefilter("json jsonp", function(s, originalSettings, jqXHR) {
    
    			var callbackName, overwritten, responseContainer,
    				jsonProp = s.jsonp !== false && (rjsonp.test(s.url) ?
    					"url" :
    					typeof s.data === "string" && !(s.contentType || "").indexOf("application/x-www-form-urlencoded") && rjsonp.test(s.data) && "data"
    				);
    
    			// Handle iff the expected data type is "jsonp" or we have a parameter to set
    			if (jsonProp || s.dataTypes[0] === "jsonp") {
    
    				// Get callback name, remembering preexisting value associated with it
    				callbackName = s.jsonpCallback = jQuery.isFunction(s.jsonpCallback) ?
    					s.jsonpCallback() :
    					s.jsonpCallback;
    
    				// Insert callback into url or form data
    				if (jsonProp) {
    					s[jsonProp] = s[jsonProp].replace(rjsonp, "$1" + callbackName);
    				} else if (s.jsonp !== false) {
    					s.url += (rquery.test(s.url) ? "&" : "?") + s.jsonp + "=" + callbackName;
    				}
    
    				// Use data converter to retrieve json after script execution
    				s.converters["script json"] = function() {
    					if (!responseContainer) {
    						jQuery.error(callbackName + " was not called");
    					}
    					return responseContainer[0];
    				};
    
    				// force json dataType
    				s.dataTypes[0] = "json";
    
    				// Install callback
    				overwritten = window[callbackName];
    				window[callbackName] = function() {
    					responseContainer = arguments;
    				};
    
    				// Clean-up function (fires after converters)
    				jqXHR.always(function() {
    					// Restore preexisting value
    					window[callbackName] = overwritten;
    
    					// Save back as free
    					if (s[callbackName]) {
    						// make sure that re-using the options doesn't screw things around
    						s.jsonpCallback = originalSettings.jsonpCallback;
    
    						// save the callback name for future use
    						oldCallbacks.push(callbackName);
    					}
    
    					// Call if it was a function and we have a response
    					if (responseContainer && jQuery.isFunction(overwritten)) {
    						overwritten(responseContainer[0]);
    					}
    
    					responseContainer = overwritten = undefined;
    				});
    
    				// Delegate to script
    				return "script";
    			}
    		});
    
    
    
    		// data: string of html
    		// context (optional): If specified, the fragment will be created in this context, defaults to document
    		// keepScripts (optional): If true, will include scripts passed in the html string
    		jQuery.parseHTML = function(data, context, keepScripts) {
    			if (!data || typeof data !== "string") {
    				return null;
    			}
    			if (typeof context === "boolean") {
    				keepScripts = context;
    				context = false;
    			}
    			context = context || document;
    
    			var parsed = rsingleTag.exec(data),
    				scripts = !keepScripts && [];
    
    			// Single tag
    			if (parsed) {
    				return [context.createElement(parsed[1])];
    			}
    
    			parsed = jQuery.buildFragment([data], context, scripts);
    
    			if (scripts && scripts.length) {
    				jQuery(scripts).remove();
    			}
    
    			return jQuery.merge([], parsed.childNodes);
    		};
    
    
    		// Keep a copy of the old load method
    		var _load = jQuery.fn.load;
    
    		
    		jQuery.fn.load = function(url, params, callback) {
    			if (typeof url !== "string" && _load) {
    				return _load.apply(this, arguments);
    			}
    
    			var selector, type, response,
    				self = this,
    				off = url.indexOf(" ");
    
    			if (off >= 0) {
    				selector = jQuery.trim(url.slice(off));
    				url = url.slice(0, off);
    			}
    
    			// If it's a function
    			if (jQuery.isFunction(params)) {
    
    				// We assume that it's the callback
    				callback = params;
    				params = undefined;
    
    				// Otherwise, build a param string
    			} else if (params && typeof params === "object") {
    				type = "POST";
    			}
    
    			// If we have elements to modify, make the request
    			if (self.length > 0) {
    				jQuery.ajax({
    					url: url,
    
    					// if "type" variable is undefined, then "GET" method will be used
    					type: type,
    					dataType: "html",
    					data: params
    				}).done(function(responseText) {
    
    					// Save response for use in complete callback
    					response = arguments;
    
    					self.html(selector ?
    
    						// If a selector was specified, locate the right elements in a dummy div
    						// Exclude scripts to avoid IE 'Permission Denied' errors
    						jQuery("<div>").append(jQuery.parseHTML(responseText)).find(selector) :
    
    						// Otherwise use the full result
    						responseText);
    
    				}).complete(callback && function(jqXHR, status) {
    					self.each(callback, response || [jqXHR.responseText, status, jqXHR]);
    				});
    			}
    
    			return this;
    		};
    
    
    
    		// Attach a bunch of functions for handling common AJAX events
    		jQuery.each(["ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend"], function(i, type) {
    			jQuery.fn[type] = function(fn) {
    				return this.on(type, fn);
    			};
    		});
    
    
    
    		jQuery.expr.filters.animated = function(elem) {
    			return jQuery.grep(jQuery.timers, function(fn) {
    				return elem === fn.elem;
    			}).length;
    		};
    
    
    
    		var docElem = window.document.documentElement;
    
    		
    		function getWindow(elem) {
    			return jQuery.isWindow(elem) ? elem : elem.nodeType === 9 && elem.defaultView;
    		}
    
    		jQuery.offset = {
    			setOffset: function(elem, options, i) {
    				var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,
    					position = jQuery.css(elem, "position"),
    					curElem = jQuery(elem),
    					props = {};
    
    				// Set position first, in-case top/left are set even on static elem
    				if (position === "static") {
    					elem.style.position = "relative";
    				}
    
    				curOffset = curElem.offset();
    				curCSSTop = jQuery.css(elem, "top");
    				curCSSLeft = jQuery.css(elem, "left");
    				calculatePosition = (position === "absolute" || position === "fixed") &&
    					(curCSSTop + curCSSLeft).indexOf("auto") > -1;
    
    				// Need to be able to calculate position if either
    				// top or left is auto and position is either absolute or fixed
    				if (calculatePosition) {
    					curPosition = curElem.position();
    					curTop = curPosition.top;
    					curLeft = curPosition.left;
    
    				} else {
    					curTop = parseFloat(curCSSTop) || 0;
    					curLeft = parseFloat(curCSSLeft) || 0;
    				}
    
    				if (jQuery.isFunction(options)) {
    					options = options.call(elem, i, curOffset);
    				}
    
    				if (options.top != null) {
    					props.top = (options.top - curOffset.top) + curTop;
    				}
    				if (options.left != null) {
    					props.left = (options.left - curOffset.left) + curLeft;
    				}
    
    				if ("using" in options) {
    					options.using.call(elem, props);
    
    				} else {
    					curElem.css(props);
    				}
    			}
    		};
    
    		jQuery.fn.extend({
    			offset: function(options) {
    				if (arguments.length) {
    					return options === undefined ?
    						this :
    						this.each(function(i) {
    							jQuery.offset.setOffset(this, options, i);
    						});
    				}
    
    				var docElem, win,
    					elem = this[0],
    					box = {
    						top: 0,
    						left: 0
    					},
    					doc = elem && elem.ownerDocument;
    
    				if (!doc) {
    					return;
    				}
    
    				docElem = doc.documentElement;
    
    				// Make sure it's not a disconnected DOM node
    				if (!jQuery.contains(docElem, elem)) {
    					return box;
    				}
    
    				// Support: BlackBerry 5, iOS 3 (original iPhone)
    				// If we don't have gBCR, just use 0,0 rather than error
    				if (typeof elem.getBoundingClientRect !== strundefined) {
    					box = elem.getBoundingClientRect();
    				}
    				win = getWindow(doc);
    				return {
    					top: box.top + win.pageYOffset - docElem.clientTop,
    					left: box.left + win.pageXOffset - docElem.clientLeft
    				};
    			},
    
    			position: function() {
    				if (!this[0]) {
    					return;
    				}
    
    				var offsetParent, offset,
    					elem = this[0],
    					parentOffset = {
    						top: 0,
    						left: 0
    					};
    
    				// Fixed elements are offset from window (parentOffset = {top:0, left: 0}, because it is its only offset parent
    				if (jQuery.css(elem, "position") === "fixed") {
    					// Assume getBoundingClientRect is there when computed position is fixed
    					offset = elem.getBoundingClientRect();
    
    				} else {
    					// Get *real* offsetParent
    					offsetParent = this.offsetParent();
    
    					// Get correct offsets
    					offset = this.offset();
    					if (!jQuery.nodeName(offsetParent[0], "html")) {
    						parentOffset = offsetParent.offset();
    					}
    
    					// Add offsetParent borders
    					parentOffset.top += jQuery.css(offsetParent[0], "borderTopWidth", true);
    					parentOffset.left += jQuery.css(offsetParent[0], "borderLeftWidth", true);
    				}
    
    				// Subtract parent offsets and element margins
    				return {
    					top: offset.top - parentOffset.top - jQuery.css(elem, "marginTop", true),
    					left: offset.left - parentOffset.left - jQuery.css(elem, "marginLeft", true)
    				};
    			},
    
    			offsetParent: function() {
    				return this.map(function() {
    					var offsetParent = this.offsetParent || docElem;
    
    					while (offsetParent && (!jQuery.nodeName(offsetParent, "html") && jQuery.css(offsetParent, "position") === "static")) {
    						offsetParent = offsetParent.offsetParent;
    					}
    
    					return offsetParent || docElem;
    				});
    			}
    		});
    
    		// Create scrollLeft and scrollTop methods
    		jQuery.each({
    			scrollLeft: "pageXOffset",
    			scrollTop: "pageYOffset"
    		}, function(method, prop) {
    			var top = "pageYOffset" === prop;
    
    			jQuery.fn[method] = function(val) {
    				return access(this, function(elem, method, val) {
    					var win = getWindow(elem);
    
    					if (val === undefined) {
    						return win ? win[prop] : elem[method];
    					}
    
    					if (win) {
    						win.scrollTo(!top ? val : window.pageXOffset,
    							top ? val : window.pageYOffset
    						);
    
    					} else {
    						elem[method] = val;
    					}
    				}, method, val, arguments.length, null);
    			};
    		});
    
    		// Support: Safari<7+, Chrome<37+
    		// Add the top/left cssHooks using jQuery.fn.position
    		// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
    		// Blink bug: https://code.google.com/p/chromium/issues/detail?id=229280
    		// getComputedStyle returns percent when specified for top/left/bottom/right;
    		// rather than make the css module depend on the offset module, just check for it here
    		jQuery.each(["top", "left"], function(i, prop) {
    			jQuery.cssHooks[prop] = addGetHookIf(support.pixelPosition,
    				function(elem, computed) {
    					if (computed) {
    						computed = curCSS(elem, prop);
    						// If curCSS returns percentage, fallback to offset
    						return rnumnonpx.test(computed) ?
    							jQuery(elem).position()[prop] + "px" :
    							computed;
    					}
    				}
    			);
    		});
    
    
    		// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
    		jQuery.each({
    			Height: "height",
    			Width: "width"
    		}, function(name, type) {
    			jQuery.each({
    				padding: "inner" + name,
    				content: type,
    				"": "outer" + name
    			}, function(defaultExtra, funcName) {
    				// Margin is only for outerHeight, outerWidth
    				jQuery.fn[funcName] = function(margin, value) {
    					var chainable = arguments.length && (defaultExtra || typeof margin !== "boolean"),
    						extra = defaultExtra || (margin === true || value === true ? "margin" : "border");
    
    					return access(this, function(elem, type, value) {
    						var doc;
    
    						if (jQuery.isWindow(elem)) {
    							// As of 5/8/2012 this will yield incorrect results for Mobile Safari, but there
    							// isn't a whole lot we can do. See pull request at this URL for discussion:
    							// https://github.com/jquery/jquery/pull/764
    							return elem.document.documentElement["client" + name];
    						}
    
    						// Get document width or height
    						if (elem.nodeType === 9) {
    							doc = elem.documentElement;
    
    							// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],
    							// whichever is greatest
    							return Math.max(
    								elem.body["scroll" + name], doc["scroll" + name],
    								elem.body["offset" + name], doc["offset" + name],
    								doc["client" + name]
    							);
    						}
    
    						return value === undefined ?
    							// Get width or height on the element, requesting but not forcing parseFloat
    							jQuery.css(elem, type, extra) :
    
    							// Set width or height on the element
    							jQuery.style(elem, type, value, extra);
    					}, type, chainable ? margin : undefined, chainable, null);
    				};
    			});
    		});
    
    
    		// The number of elements contained in the matched element set
    		jQuery.fn.size = function() {
    			return this.length;
    		};
    
    		jQuery.fn.andSelf = jQuery.fn.addBack;
    
    
    
    		// Register as a named AMD module, since jQuery can be concatenated with other
    		// files that may use define, but not via a proper concatenation script that
    		// understands anonymous AMD modules. A named AMD is safest and most robust
    		// way to register. Lowercase jquery is used because AMD module names are
    		// derived from file names, and jQuery is normally delivered in a lowercase
    		// file name. Do this after creating the global so that if an AMD module wants
    		// to call noConflict to hide this version of jQuery, it will work.
    
    		// Note that for maximum portability, libraries that are not jQuery should
    		// declare themselves as anonymous modules, and avoid setting a global if an
    		// AMD loader is present. jQuery is a special case. For more information, see
    		// https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon
    
    		if (typeof define === "function" && define.amd) {
    			define("jquery", [], function() {
    				return jQuery;
    			});
    		}
    
    
    
    		var
    		// Map over jQuery in case of overwrite
    			_jQuery = window.jQuery,
    
    			// Map over the $ in case of overwrite
    			_$ = window.$;
    
    		jQuery.noConflict = function(deep) {
    			if (window.$ === jQuery) {
    				window.$ = _$;
    			}
    
    			if (deep && window.jQuery === jQuery) {
    				window.jQuery = _jQuery;
    			}
    
    			return jQuery;
    		};
    
    		// Expose jQuery and $ identifiers, even in AMD
    		// (#7102#comment:10, https://github.com/jquery/jquery/pull/557)
    		// and CommonJS for browser emulators (#13566)
    		if (typeof noGlobal === strundefined) {
    			window.jQuery = window.$ = jQuery;
    		}
    
    
    
    		return jQuery;
    
    	})(window, true);
    });
    //attention bug, those name didn't significance
    //attention bug, between user config and system config mix
    
    define('spreadsheet/config',function() {
    	
    	return {
    		
    		User: {
    			
    			initRowNum: 100,
    			
    			initColNum: 26,
    			
    			cellWidth: 72,
    			
    			cellHeight: 20,
    			
    			maxColNum: 100,
    			
    			maxRowNum: 9999,
    			
    			commentWidth: 150,
    			
    			commentHeight: 150,
    		},
    		
    		System: {
    			
    			outerLeft: 37,
    			
    			outerTop: 20,
    			
    			outerBottom: 30,
    			
    			effectDistanceCol: 10,
    			
    			effectDistanceRow: 5,
    			
    			prestrainHeight: 200,
    			
    			prestrainWidth: 100,
    			
    			maxRowNum: 9999,
    			
    			comment: {
    				height: 150,
    				width: 150
    			}
    		},
    		validationType: {
    			defaultType: 0,
    			intType: 1,
    			decimalType: 2,
    			sequenceType: 3,
    			textType: 6
    		},
    		sidebarWidth: 280,
    		mouseOperateState: {
    			select: 'selected',
    			dataSource: 'datasource',
    			drag: 'drag',
    			highlight: 'highlight',
    			ruleSource: 'rule'
    		},
    		dateFormatType: {
    			frist: 'yyyy/MM/dd',
    			second: 'yyyy/MM',
    			third: 'yyyy',
    			fourth: 'yyyy年MM月dd日',
    			fifth: 'yyyy年MM月',
    			sixth: 'yyyy年'
    		},
    		defaultNumberFormat: {
    			decimal: 6
    		},
    		shortcuts: {
    			clip: true,
    			alt_enter: true,
    			enter: true,
    			delete: true,
    			redo: true,
    			undo: true,
    			arrow: true
    		},
    		url: {
    			row: {
    				plus: 'row/plus',
    				reduce: 'row/reduce',
    				hide: 'row/hide',
    				show: 'row/show',
    				adjust: 'row/adjust',
    				plusBatch: 'row/plus-batch'
    			},
    			col: {
    				plus: 'col/plus',
    				reduce: 'col/reduce',
    				hide: 'col/hide',
    				show: 'col/show',
    				adjust: 'col/adjust',
    				plus_batch: 'col/plus-batch'
    			},
    			cell: {
    				merge: 'cell/merge',
    				split: 'cell/split',
    				border: 'cell/border',
    				bg: 'cell/bg',
    				wordwrap: 'cell/wordwrap',
    				alignTransverse: 'cell/align-landscape',
    				alignVertical: 'cell/align-portrait',
    				format: 'cell/format',
    				content: 'cell/content',
    				commentPlus: 'cell/comment-plus',
    				commentDel: 'cell/comment-reduce',
    				fontSize: 'cell/font-size',
    				fontFamily: 'cell/font-family',
    				fontWeight: 'cell/font-weight',
    				fontItalic: 'cell/font-italic',
    				fontColor: 'cell/font-color',
    				bgBatch: 'cell/bg-batch',
    				underline: 'cell/font-underline',
    				clear: 'cell/clean-data',
    				lock: 'cell/lock',
    			},
    			table: {
    				reload: 'reload'
    			},
    			sheet: {
    				cut: 'sheet/cut',
    				copy: 'sheet/copy',
    				paste: 'sheet/paste',
    				undo: 'sheet/undo',
    				redo: 'sheet/redo',
    				frozen: 'sheet/frozen',
    				unfrozen: 'sheet/unfrozen',
    				load: 'sheet/area',
    				protect: 'sheet/protect',
    				validate: 'sheet/validate-set',
    				validateFull: 'sheet/validate-full'
    			},
    		},
    		version: '0.12.0',
    		rootPath: 'http://excel-inc.acmr.com.cn/'
    	};
    });
    //attention bug , those cache objects has mix , for use 
    define('basic/tools/cache',function() {
    	
    	var config = require('spreadsheet/config');
    	
    	return {
    
    		sendQueueStep: 0,
    		containerId: '',
    		//ps:CurrentRule ，FrozenRules ，TempProp 都存有冻结信息，具体功能，需要说明
    		CurrentRule: {},
    		FrozenRules: {
    			main: [],
    			row: [],
    			col: []
    		},
    		scrollBarWidth: null,
    		
    		scrollBufferHeight: 600,
    		
    		CellsPosition: {
    			
    			strandX: {},
    			
    			strandY: {}
    		},
    		clipState: 'null', //copy：复制状态，cut:剪切状态，null:未进行剪切板操作
    		
    		validate: [],
    		validateCounter: 0,
    
    		
    		UserView: {
    			
    			colAlias: '1',
    			
    			rowAlias: '1',
    			
    			colEndAlias: '1',
    			
    			rowEndAlias: '1'
    		},
    		highlightDirection: 'null',
    
    		//鼠标操作状态
    		mouseOperateState: config.mouseOperateState.select,
    
    		listenerList: {}, //事件监听列表
    		
    		localRowPosi: 0,
    		
    		localColPosi: 0,
    		
    		aliasRowCounter: '100',
    		
    		aliasColCounter: '26',
    		
    		loadCol: {
    			startSort: 0,
    			endSort: 0
    		},
    		
    		TempProp: {
    			
    			isFrozen: false,
    			
    			colAlias: '1',
    			
    			rowAlias: '1',
    			
    			rowFrozen: false,
    			
    			colFrozen: false
    		},
    		//变量值重复，需要删除
    		//动态加载，模型对象已加载区域，以坐标为记录单位
    		rowRegionPosi: [],
    		//动态加载，模型对象已加载区域，以坐标为记录单位
    		colRegionPosi: [],
    		//动态加载，模型对象已加载区域，以坐标为记录单位
    		cellRegionPosi: {
    			transverse: [],
    			vertical: []
    		},
    		viewRegion: {
    			top: 0,
    			bottom: 0,
    			left: 0,
    			right: 0,
    			scrollLeft: 0,
    			scrollTop: 0
    		},
    		commentEidtState: false,
    
    		clipboardData: null,
    
    		shortcut: {
    			select: {
    				colAlias: '1',
    				rowAlias: '1'
    			}
    		},
    		sidebarState: false,
    
    		protectState: false,
    
    		redoUndoLock: false,
    		//
    		
    		cachePosition: function(aliasRow, aliasCol, index) {
    			var positionX,
    				positionY;
    			positionX = this.CellsPosition.strandX;
    			if (!positionX[aliasCol]) {
    				positionX[aliasCol] = {};
    			}
    			if (!positionX[aliasCol][aliasRow]) {
    				positionX[aliasCol][aliasRow] = {};
    			}
    			positionY = this.CellsPosition.strandY;
    			if (!positionY[aliasRow]) {
    				positionY[aliasRow] = {};
    			}
    			if (!positionY[aliasRow][aliasCol]) {
    				positionY[aliasRow][aliasCol] = {};
    			}
    			positionX[aliasCol][aliasRow] = index;
    			positionY[aliasRow][aliasCol] = index;
    		},
    
    		
    		deletePosi: function(aliasRow, aliasCol) {
    			var currentCellPosition = this.CellsPosition,
    				currentStrandX = currentCellPosition.strandX,
    				currentStrandY = currentCellPosition.strandY;
    			if (currentStrandX[aliasCol] !== undefined && currentStrandX[aliasCol][aliasRow] !== undefined) {
    				delete currentStrandX[aliasCol][aliasRow];
    				if (!Object.getOwnPropertyNames(currentStrandX[aliasCol]).length) {
    					delete currentStrandX[aliasCol];
    				}
    			}
    			if (currentStrandY[aliasRow] !== undefined && currentStrandY[aliasRow][aliasCol] !== undefined) {
    				delete currentStrandY[aliasRow][aliasCol];
    				if (!Object.getOwnPropertyNames(currentStrandY[aliasRow]).length) {
    					delete currentStrandY[aliasRow];
    				}
    			}
    		},
    		aliasGenerator: function(type) {
    			var alias,
    				num;
    			if (type === 'col') {
    				alias = this.aliasColCounter;
    			} else {
    				alias = this.aliasRowCounter;
    			}
    
    			num = parseInt(alias);
    			alias = (num + 1).toString();
    			if (type === 'col') {
    				this.aliasColCounter = alias;
    			} else {
    				this.aliasRowCounter = alias;
    			}
    			return alias;
    		}
    	};
    });
    
    define('basic/tools/point',function() {
    
    	var Point = function(config) {
    		var regCol = /^[A-Z]+$/,
    			regRow = /^[1-9]+[0-9]*$/;
    
    		if ((typeof config) !== 'object') {
    			throw new Error('Parameter format error');
    		}
    		this.startCol = config.startCol;
    		this.startRow = config.startRow;
    		this.endCol = config.endCol || config.startCol;
    		this.endRow = config.endRow || config.startRow;
    		this.success = config.success;
    		this.error = config.error;
    		//校验
    		if (this.startRow === undefined && this.startCol === undefined) {
    			throw new Error('Parameter format error');
    		}
    		if (this.startCol !== undefined && !regCol.test(this.startCol)) {
    			throw new Error('Parameter format error');
    		}
    		if (this.startRow !== undefined && !regRow.test(this.startRow)) {
    			throw new Error('Parameter format error');
    		}
    		if (this.endCol !== undefined && !regCol.test(this.endCol)) {
    			throw new Error('Parameter format error');
    		}
    		if (this.endRow !== undefined && !regRow.test(this.endRow)) {
    			throw new Error('Parameter format error');
    		}
    		if (!this.success && (typeof this.success) === 'function') {
    			throw new Error('Parameter format error');
    		}
    		if (!this.error && (typeof this.error) === 'function') {
    			throw new Error('Parameter format error');
    		}
    		//需要增加整行整列操作的校验
    	};
    	return Point;
    });
    
    define('basic/util/binary',function() {
    	
    	return {
    		
    		modelBinary: function(value, array, strandAttr, rangeAttr, startIndex, endIndex) {
    			var middle,
    				start = startIndex ? startIndex : 0,
    				end,
    				findValue = Math.floor(value),
    				strandAttrByArray,
    				rangeAttrByArray,
    				middleArray;
    			if (endIndex === undefined) {
    				end = array.length - 1;
    			} else {
    				end = endIndex;
    			}
    
    			if (start <= end) {
    				if (array[start].get(strandAttr) === findValue) {
    					return start;
    				}
    				if (array[end].get(strandAttr) === findValue) {
    					return end;
    				}
    				middle = end + start >>> 1;
    				middleArray = array[middle];
    				strandAttrByArray = middleArray.get(strandAttr);
    				rangeAttrByArray = middleArray.get(rangeAttr);
    				if (strandAttrByArray <= findValue && strandAttrByArray + rangeAttrByArray >= findValue) {
    					return middle;
    				} else if (strandAttrByArray > findValue) {
    					return this.modelBinary(findValue, array, strandAttr, rangeAttr, start, middle - 1);
    				} else if (strandAttrByArray + rangeAttrByArray < findValue) {
    					return this.modelBinary(findValue, array, strandAttr, rangeAttr, middle + 1, end);
    				}
    			}
    			return -1;
    		},
    		
    		newModelBinary: function(value, array, strandAttr, rangeAttr, startIndex, endIndex) {
    			var middle,
    				start = startIndex ? startIndex : 0,
    				end = endIndex ? endIndex : array.length,
    				findValue = Math.floor(value),
    				strandAttrByArray,
    				rangeAttrByArray,
    				middleArray;
    			while (start < end) {
    				middle = end + start >>> 1;
    				middleArray = array[middle];
    				strandAttrByArray = middleArray.get(strandAttr);
    				rangeAttrByArray = middleArray.get(rangeAttr);
    				if (strandAttrByArray + rangeAttrByArray < findValue) {
    					start = middle + 1;
    				} else {
    					end = middle;
    				}
    			}
    			return start;
    		},
    		
    		indexModelBinary: function(value, array, strandAttr, rangeAttr, startIndex, endIndex) {
    			if (array.length === 0) {
    				return 0;
    			}
    			var middle,
    				start = startIndex ? startIndex : 0,
    				end = endIndex ? endIndex : array.length - 1,
    				findValue = Math.floor(value),
    				strandAttrByArray,
    				rangeAttrByArray,
    				middleArray;
    			if (array.length === 1) {
    				return (array[0].get(strandAttr) + array[0].get(rangeAttr) >= findValue) ? 0 : 1;
    			}
    			while (start < end) {
    				if (array[start].get(strandAttr) + array[start].get(rangeAttr) >= findValue) {
    					return start;
    				}
    				if (array[end].get(strandAttr) + array[end].get(rangeAttr) === findValue) {
    					return end;
    				}
    				if (array[end].get(strandAttr) + array[end].get(rangeAttr) < findValue) {
    					return end + 1;
    				}
    				middle = end + start >>> 1;
    				middleArray = array[middle];
    				strandAttrByArray = middleArray.get(strandAttr);
    				rangeAttrByArray = middleArray.get(rangeAttr);
    				if (strandAttrByArray + rangeAttrByArray < findValue) {
    					start = middle + 1;
    				} else {
    					end = middle;
    				}
    			}
    			return start;
    		},
    		existArrayBinary: function(value, array, startAttr, endAttr, startIndex, endIndex) {
    			var middle,
    				start = startIndex ? startIndex : 0,
    				end = endIndex ? endIndex : array.length - 1,
    				findValue = Math.floor(value);
    			if (array.length === 0) {
    				return false;
    			}
    			if (array.length === 1) {
    				if (array[0][endAttr] >= findValue && array[0][startAttr] <= findValue) {
    					return true;
    				} else {
    					return false;
    				}
    			}
    			while (start < end) {
    				if (array[start][startAttr] <= findValue && array[start][endAttr] >= findValue) {
    					return true;
    				}
    				if (array[end][startAttr] <= findValue && array[end][endAttr] >= findValue) {
    					return true;
    				}
    				middle = end + start >>> 1;
    				if (array[end][startAttr] <= findValue && array[end][endAttr] >= findValue) {
    					return true;
    				} else if (array[middle][endAttr] < findValue) {
    					start = middle + 1;
    				} else {
    					end = middle;
    				}
    			}
    			return false;
    		},
    		indexArrayBinary: function(value, array, startAttr, endAttr, startIndex, endIndex) {
    			var middle,
    				start = startIndex ? startIndex : 0,
    				end = endIndex ? endIndex : array.length - 1,
    				findValue = Math.floor(value);
    			if (array.length === 0) {
    				return 0;
    			}
    			if (array.length === 1) {
    				if (array[start][endAttr] < findValue) {
    					return 1;
    				} else {
    					return 0;
    				}
    			}
    			while (start < end) {
    				if (array[start][startAttr] >= findValue) {
    					return start;
    				}
    				if (array[end][endAttr] < findValue) {
    					return end + 1;
    				}
    
    				middle = end + start >>> 1;
    
    				if (array[middle][startAttr] <= findValue && array[middle][endAttr] >= findValue) {
    					return middle;
    				} else if (array[middle][endAttr] < findValue) {
    					start = middle + 1;
    				} else {
    					end = middle;
    				}
    			}
    			return start;
    		},
    		
    		indexAttrBinary: function(value, array, attr, startIndex, endIndex) {
    			var middleIndex;
    
    			startIndex = startIndex || 0;
    			endIndex = endIndex || array.length - 1;
    			if (array[startIndex].attributes[attr] > value) {
    				return -1;
    			}
    			if (array[endIndex].attributes[attr] < value) {
    				return -1;
    			}
    			while (startIndex < endIndex) {
    				if (array[startIndex].attributes[attr] === value) {
    					return startIndex;
    				}
    				if (array[endIndex].attributes[attr] === value) {
    					return endIndex;
    				}
    				middleIndex = endIndex + startIndex >>> 1;
    				if (array[middleIndex].attributes[attr] === value) {
    					return middleIndex;
    				} else if (array[middleIndex].attributes[attr] < value) {
    					startIndex = middleIndex + 1;
    				} else {
    					endIndex = middleIndex;
    				}
    			}
    			return -1;
    		}
    	};
    
    });
    
    define('basic/tools/send',function() {
    	var $ = require('lib/jquery'),
    		cache = require('basic/tools/cache'),
    		systemConfig = require('spreadsheet/config');
    	
    	return {
    		
    		PackAjax: function(cfg) {
    			var config = {},
    				NULLFUNC = function() {};
    
    			if (!cfg.url) {
    				return;
    			}
    			config = {
    				url: typeof cfg.url === 'string' ? (systemConfig.rootPath + cfg.url) : undefined,
    				type: cfg.type || 'post',
    				contentType: cfg.contentType || 'application/json; charset=UTF-8',
    				dataType: cfg.dataType || 'json',
    				data: cfg.data || '',
    				async: cfg.async !== undefined ? cfg.async : false,
    				// async: cfg.async !== undefined ? cfg.async : true,
    				timeout: cfg.timeout || 5000,
    				success: cfg.success || NULLFUNC,
    				error: cfg.error || NULLFUNC,
    				complete: cfg.complete || NULLFUNC,
    				isPublic: cfg.isPublic !== undefined ? cfg.isPublic : true,
    			};
    			doRequest(config);
    
    			function doRequest(config) {
    				$.ajax({
    					url: config.url,
    					beforeSend: function(request) {
    						if (config.isPublic) {
    							cache.sendQueueStep++;
    						}
    						request.setRequestHeader('step', cache.sendQueueStep);
    						request.setRequestHeader('excelId', window.SPREADSHEET_AUTHENTIC_KEY);
    						request.setRequestHeader('sheetId', '1');
    					},
    					type: config.type,
    					contentType: config.contentType,
    					dataType: config.dataType,
    					async: config.async,
    					data: config.data,
    					timeout: config.timeout,
    					error: config.error,
    					complete: config.complete,
    					success: function(data) {
    						if (data.isLegal === false) {
    							cache.sendQueueStep--;
    						}
    						config.success.apply(this, arguments);
    					}
    				});
    			}
    		}
    	};
    });
    define('basic/tools/text2sort',function() {
    	
    
    	function text2sort(text) {
    		var startColName,
    			startRowName,
    			endColName,
    			endRowName,
    			regPoint = /^\$([A-Z]+)\$([0-9]+)$/,
    			regRow = /^\$([0-9]+)$/,
    			regCol = /^\$([A-Z]+)$/,
    			match1,
    			match2,
    			part1,
    			part2;
    
    		if (text.indexOf('=') === 0) {
    			text = text.substring(1);
    		}
    		text = text.split(':');
    		part1 = text[0];
    		part2 = text[1];
    
    		if (typeof part2 === 'undefined') {
    			match1 = regPoint.exec(part1);
    			if (!match1) {
    				return;
    			}
    			startColName = match1[1];
    			startRowName = match1[2];
    			endColName = match1[1];
    			endRowName = match1[2];
    		} else {
    			if ((match1 = regPoint.exec(part1)) && (match2 = regPoint.exec(part2))) {
    				startColName = match1[1];
    				startRowName = match1[2];
    				endColName = match2[1];
    				endRowName = match2[2];
    			} else if ((match1 = regRow.exec(part1)) && (match2 = regRow.exec(part2))) {
    				startColName = 'A';
    				startRowName = match1[1];
    				endColName = 'MAX';
    				endRowName = match2[1];
    			} else if ((match1 = regCol.exec(part1)) && (match2 = regCol.exec(part2))) {
    				startColName = match1[1];
    				startRowName = '1';
    				endColName = match2[1];
    				endRowName = 'MAX';
    			}
    		}
    		if (startColName) {
    			return {
    				startColSort: colSignToSort(startColName),
    				endColSort: colSignToSort(endColName),
    				startRowSort: rowSignToSort(startRowName),
    				endRowSort: rowSignToSort(endRowName)
    			};
    		} else {
    			return;
    		}
    
    		function colSignToSort(sign) {
    			if (sign === 'MAX') {
    				return sign;
    			}
    			var i = 0,
    				sort = 0,
    				len = sign.length,
    				letter = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'],
    				index;
    			for (; i < len; i++) {
    				index = letter.indexOf(sign[i]) + 1;
    				sort += index * (Math.pow(26, (len - i - 1)));
    			}
    			return sort - 1;
    		}
    
    		function rowSignToSort(sign) {
    			if (sign === 'MAX') {
    				return sign;
    			}
    			return parseInt(sign) - 1;
    		}
    	}
    	return text2sort;
    });
    
    define('basic/tools/loadrecorder',function() {
    	var binary = require('basic/util/binary');
    
    	return {
    		insertPosi: function(startPosi, endPosi, region) {
    			var temp,
    				startIndex,
    				endIndex,
    				startExist,
    				endExist,
    				startNextExist,
    				endNextExist,
    				newStartPosi,
    				newEndPosi,
    				len;
    
    			if (startPosi > endPosi) {
    				temp = startPosi;
    				startPosi = endPosi;
    				endPosi = temp;
    			}
    			startIndex = binary.indexArrayBinary(startPosi, region, 'start', 'end');
    			endIndex = binary.indexArrayBinary(endPosi, region, 'start', 'end');
    			startExist = binary.existArrayBinary(startPosi, region, 'start', 'end');
    			endExist = binary.existArrayBinary(endPosi, region, 'start', 'end');
    
    			newStartPosi = startExist === false ? startPosi : region[startIndex].start;
    			newEndPosi = endExist === false ? endPosi : region[endIndex].end;
    			//处理相邻点
    			startNextExist = binary.existArrayBinary(newStartPosi - 1, region, 'start', 'end');
    			endNextExist = binary.existArrayBinary(newEndPosi + 1, region, 'start', 'end');
    			if (startNextExist === true) {
    				startIndex = binary.indexArrayBinary(newStartPosi - 1, region, 'start', 'end');
    				newStartPosi = region[startIndex].start;
    				startExist = true;
    			}
    			if (endNextExist === true) {
    				endIndex = binary.indexArrayBinary(newEndPosi + 1, region, 'start', 'end');
    				newEndPosi = region[endIndex].end;
    				endExist = true;
    			}
    
    			if (startIndex === endIndex) {
    				if (startExist === true && endExist === true) {
    					return;
    				}
    				len = (startExist === true || endExist === true) ? 1 : 0;
    			} else {
    				len = endIndex - startIndex;
    				if (endExist === true) {
    					len++;
    				}
    			}
    			region.splice(startIndex, len, {
    				start: newStartPosi,
    				end: newEndPosi
    			});
    		},
    		adaptPosi: function(startPosi, value, region) {
    			var startIndex,
    				startExist,
    				i;
    			startIndex = binary.indexArrayBinary(startPosi, region, 'start', 'end');
    			startExist = binary.existArrayBinary(startPosi, region, 'start', 'end');
    			if (startExist === true) {
    				region[startIndex].end = region[startIndex].end + value;
    				if(region[startIndex].end < region[startIndex].start){
    					i = startIndex;
    					region.splice(startIndex,1);
    				}else{
    					i = startIndex + 1 ;
    				}
    				for (i = startIndex + 1; i < region.length; i++) {
    					region[i].start += value;
    					region[i].end += value;
    				}
    			} else {
    				for (i = startIndex; i < region.length; i++) {
    					region[i].start += value;
    					region[i].end += value;
    				}
    			}
    		},
    		isUnloadPosi: function(startPosi, endPosi, region) {
    			var startIndex,
    				startExist,
    				endIndex,
    				endExist;
    
    			startIndex = binary.indexArrayBinary(startPosi, region, 'start', 'end');
    			startExist = binary.existArrayBinary(startPosi, region, 'start', 'end');
    			endIndex = binary.indexArrayBinary(endPosi, region, 'start', 'end');
    			endExist = binary.existArrayBinary(endPosi, region, 'start', 'end');
    			if (startExist === false || endExist === false) {
    				return true;
    			}
    			if (startIndex !== endIndex) {
    
    				return true;
    			}
    			return false;
    		}
    	};
    });
    
    define('basic/tools/getdisplayname',function() {
    	var getDisplayName = {
    		getColDisplayName: function(currentIndex) {
    			var aliasCol = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'],
    				displayText = '',
    				remainder,
    				divisible;
    
    			if (currentIndex === 'MAX') {
    				return 'MAX';
    			}
    			remainder = currentIndex % aliasCol.length;
    			divisible = Math.floor(currentIndex / aliasCol.length);
    			displayText = aliasCol[remainder] + displayText;
    			while (divisible > 0) {
    				currentIndex = divisible - 1;
    				remainder = currentIndex % aliasCol.length;
    				divisible = Math.floor(currentIndex / aliasCol.length);
    				displayText = aliasCol[remainder] + displayText;
    			}
    			return displayText;
    		},
    		
    		getRowDisplayName: function(currentIndex) {
    			if (currentIndex === 'MAX') {
    				return 'MAX';
    			}
    			return (currentIndex + 1).toString();
    		}
    	};
    	return getDisplayName;
    });
    //     Underscore.js 1.8.3
    //     http://underscorejs.org
    //     (c) 2009-2016 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
    //     Underscore may be freely distributed under the MIT license.
    
    define('lib/underscore',function() {
    
      // Baseline setup
      // --------------
    
      // Establish the root object, `window` (`self`) in the browser, `global`
      // on the server, or `this` in some virtual machines. We use `self`
      // instead of `window` for `WebWorker` support.
      var root = typeof self == 'object' && self.self === self && self ||
                typeof global == 'object' && global.global === global && global ||
                this;
    
      // Save the previous value of the `_` variable.
      var previousUnderscore = root._;
    
      // Save bytes in the minified (but not gzipped) version:
      var ArrayProto = Array.prototype, ObjProto = Object.prototype;
      var SymbolProto = typeof Symbol !== 'undefined' ? Symbol.prototype : null;
    
      // Create quick reference variables for speed access to core prototypes.
      var push = ArrayProto.push,
          slice = ArrayProto.slice,
          toString = ObjProto.toString,
          hasOwnProperty = ObjProto.hasOwnProperty;
    
      // All **ECMAScript 5** native function implementations that we hope to use
      // are declared here.
      var nativeIsArray = Array.isArray,
          nativeKeys = Object.keys,
          nativeCreate = Object.create;
    
      // Naked function reference for surrogate-prototype-swapping.
      var Ctor = function(){};
    
      // Create a safe reference to the Underscore object for use below.
      var _ = function(obj) {
        if (obj instanceof _) return obj;
        if (!(this instanceof _)) return new _(obj);
        this._wrapped = obj;
      };
    
      // Export the Underscore object for **Node.js**, with
      // backwards-compatibility for their old module API. If we're in
      // the browser, add `_` as a global object.
      // (`nodeType` is checked to ensure that `module`
      // and `exports` are not HTML elements.)
      if (typeof exports != 'undefined' && !exports.nodeType) {
        if (typeof module != 'undefined' && !module.nodeType && module.exports) {
          exports = module.exports = _;
        }
        exports._ = _;
      } else {
        root._ = _;
      }
    
      // Current version.
      _.VERSION = '1.8.3';
    
      // Internal function that returns an efficient (for current engines) version
      // of the passed-in callback, to be repeatedly applied in other Underscore
      // functions.
      var optimizeCb = function(func, context, argCount) {
        if (context === void 0) return func;
        switch (argCount == null ? 3 : argCount) {
          case 1: return function(value) {
            return func.call(context, value);
          };
          // The 2-parameter case has been omitted only because no current consumers
          // made use of it.
          case 3: return function(value, index, collection) {
            return func.call(context, value, index, collection);
          };
          case 4: return function(accumulator, value, index, collection) {
            return func.call(context, accumulator, value, index, collection);
          };
        }
        return function() {
          return func.apply(context, arguments);
        };
      };
    
      var builtinIteratee;
    
      // An internal function to generate callbacks that can be applied to each
      // element in a collection, returning the desired result — either `identity`,
      // an arbitrary callback, a property matcher, or a property accessor.
      var cb = function(value, context, argCount) {
        if (_.iteratee !== builtinIteratee) return _.iteratee(value, context);
        if (value == null) return _.identity;
        if (_.isFunction(value)) return optimizeCb(value, context, argCount);
        if (_.isObject(value)) return _.matcher(value);
        return _.property(value);
      };
    
      // External wrapper for our callback generator. Users may customize
      // `_.iteratee` if they want additional predicate/iteratee shorthand styles.
      // This abstraction hides the internal-only argCount argument.
      _.iteratee = builtinIteratee = function(value, context) {
        return cb(value, context, Infinity);
      };
    
      // Similar to ES6's rest param (http://ariya.ofilabs.com/2013/03/es6-and-rest-parameter.html)
      // This accumulates the arguments passed into an array, after a given index.
      var restArgs = function(func, startIndex) {
        startIndex = startIndex == null ? func.length - 1 : +startIndex;
        return function() {
          var length = Math.max(arguments.length - startIndex, 0);
          var rest = Array(length);
          for (var index = 0; index < length; index++) {
            rest[index] = arguments[index + startIndex];
          }
          switch (startIndex) {
            case 0: return func.call(this, rest);
            case 1: return func.call(this, arguments[0], rest);
            case 2: return func.call(this, arguments[0], arguments[1], rest);
          }
          var args = Array(startIndex + 1);
          for (index = 0; index < startIndex; index++) {
            args[index] = arguments[index];
          }
          args[startIndex] = rest;
          return func.apply(this, args);
        };
      };
    
      // An internal function for creating a new object that inherits from another.
      var baseCreate = function(prototype) {
        if (!_.isObject(prototype)) return {};
        if (nativeCreate) return nativeCreate(prototype);
        Ctor.prototype = prototype;
        var result = new Ctor;
        Ctor.prototype = null;
        return result;
      };
    
      var property = function(key) {
        return function(obj) {
          return obj == null ? void 0 : obj[key];
        };
      };
    
      // Helper for collection methods to determine whether a collection
      // should be iterated as an array or as an object.
      // Related: http://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength
      // Avoids a very nasty iOS 8 JIT bug on ARM-64. #2094
      var MAX_ARRAY_INDEX = Math.pow(2, 53) - 1;
      var getLength = property('length');
      var isArrayLike = function(collection) {
        var length = getLength(collection);
        return typeof length == 'number' && length >= 0 && length <= MAX_ARRAY_INDEX;
      };
    
      // Collection Functions
      // --------------------
    
      // The cornerstone, an `each` implementation, aka `forEach`.
      // Handles raw objects in addition to array-likes. Treats all
      // sparse array-likes as if they were dense.
      _.each = _.forEach = function(obj, iteratee, context) {
        iteratee = optimizeCb(iteratee, context);
        var i, length;
        if (isArrayLike(obj)) {
          for (i = 0, length = obj.length; i < length; i++) {
            iteratee(obj[i], i, obj);
          }
        } else {
          var keys = _.keys(obj);
          for (i = 0, length = keys.length; i < length; i++) {
            iteratee(obj[keys[i]], keys[i], obj);
          }
        }
        return obj;
      };
    
      // Return the results of applying the iteratee to each element.
      _.map = _.collect = function(obj, iteratee, context) {
        iteratee = cb(iteratee, context);
        var keys = !isArrayLike(obj) && _.keys(obj),
            length = (keys || obj).length,
            results = Array(length);
        for (var index = 0; index < length; index++) {
          var currentKey = keys ? keys[index] : index;
          results[index] = iteratee(obj[currentKey], currentKey, obj);
        }
        return results;
      };
    
      // Create a reducing function iterating left or right.
      var createReduce = function(dir) {
        // Wrap code that reassigns argument variables in a separate function than
        // the one that accesses `arguments.length` to avoid a perf hit. (#1991)
        var reducer = function(obj, iteratee, memo, initial) {
          var keys = !isArrayLike(obj) && _.keys(obj),
              length = (keys || obj).length,
              index = dir > 0 ? 0 : length - 1;
          if (!initial) {
            memo = obj[keys ? keys[index] : index];
            index += dir;
          }
          for (; index >= 0 && index < length; index += dir) {
            var currentKey = keys ? keys[index] : index;
            memo = iteratee(memo, obj[currentKey], currentKey, obj);
          }
          return memo;
        };
    
        return function(obj, iteratee, memo, context) {
          var initial = arguments.length >= 3;
          return reducer(obj, optimizeCb(iteratee, context, 4), memo, initial);
        };
      };
    
      // **Reduce** builds up a single result from a list of values, aka `inject`,
      // or `foldl`.
      _.reduce = _.foldl = _.inject = createReduce(1);
    
      // The right-associative version of reduce, also known as `foldr`.
      _.reduceRight = _.foldr = createReduce(-1);
    
      // Return the first value which passes a truth test. Aliased as `detect`.
      _.find = _.detect = function(obj, predicate, context) {
        var keyFinder = isArrayLike(obj) ? _.findIndex : _.findKey;
        var key = keyFinder(obj, predicate, context);
        if (key !== void 0 && key !== -1) return obj[key];
      };
    
      // Return all the elements that pass a truth test.
      // Aliased as `select`.
      _.filter = _.select = function(obj, predicate, context) {
        var results = [];
        predicate = cb(predicate, context);
        _.each(obj, function(value, index, list) {
          if (predicate(value, index, list)) results.push(value);
        });
        return results;
      };
    
      // Return all the elements for which a truth test fails.
      _.reject = function(obj, predicate, context) {
        return _.filter(obj, _.negate(cb(predicate)), context);
      };
    
      // Determine whether all of the elements match a truth test.
      // Aliased as `all`.
      _.every = _.all = function(obj, predicate, context) {
        predicate = cb(predicate, context);
        var keys = !isArrayLike(obj) && _.keys(obj),
            length = (keys || obj).length;
        for (var index = 0; index < length; index++) {
          var currentKey = keys ? keys[index] : index;
          if (!predicate(obj[currentKey], currentKey, obj)) return false;
        }
        return true;
      };
    
      // Determine if at least one element in the object matches a truth test.
      // Aliased as `any`.
      _.some = _.any = function(obj, predicate, context) {
        predicate = cb(predicate, context);
        var keys = !isArrayLike(obj) && _.keys(obj),
            length = (keys || obj).length;
        for (var index = 0; index < length; index++) {
          var currentKey = keys ? keys[index] : index;
          if (predicate(obj[currentKey], currentKey, obj)) return true;
        }
        return false;
      };
    
      // Determine if the array or object contains a given item (using `===`).
      // Aliased as `includes` and `include`.
      _.contains = _.includes = _.include = function(obj, item, fromIndex, guard) {
        if (!isArrayLike(obj)) obj = _.values(obj);
        if (typeof fromIndex != 'number' || guard) fromIndex = 0;
        return _.indexOf(obj, item, fromIndex) >= 0;
      };
    
      // Invoke a method (with arguments) on every item in a collection.
      _.invoke = restArgs(function(obj, method, args) {
        var isFunc = _.isFunction(method);
        return _.map(obj, function(value) {
          var func = isFunc ? method : value[method];
          return func == null ? func : func.apply(value, args);
        });
      });
    
      // Convenience version of a common use case of `map`: fetching a property.
      _.pluck = function(obj, key) {
        return _.map(obj, _.property(key));
      };
    
      // Convenience version of a common use case of `filter`: selecting only objects
      // containing specific `key:value` pairs.
      _.where = function(obj, attrs) {
        return _.filter(obj, _.matcher(attrs));
      };
    
      // Convenience version of a common use case of `find`: getting the first object
      // containing specific `key:value` pairs.
      _.findWhere = function(obj, attrs) {
        return _.find(obj, _.matcher(attrs));
      };
    
      // Return the maximum element (or element-based computation).
      _.max = function(obj, iteratee, context) {
        var result = -Infinity, lastComputed = -Infinity,
            value, computed;
        if (iteratee == null || (typeof iteratee == 'number' && typeof obj[0] != 'object') && obj != null) {
          obj = isArrayLike(obj) ? obj : _.values(obj);
          for (var i = 0, length = obj.length; i < length; i++) {
            value = obj[i];
            if (value != null && value > result) {
              result = value;
            }
          }
        } else {
          iteratee = cb(iteratee, context);
          _.each(obj, function(v, index, list) {
            computed = iteratee(v, index, list);
            if (computed > lastComputed || computed === -Infinity && result === -Infinity) {
              result = v;
              lastComputed = computed;
            }
          });
        }
        return result;
      };
    
      // Return the minimum element (or element-based computation).
      _.min = function(obj, iteratee, context) {
        var result = Infinity, lastComputed = Infinity,
            value, computed;
        if (iteratee == null || (typeof iteratee == 'number' && typeof obj[0] != 'object') && obj != null) {
          obj = isArrayLike(obj) ? obj : _.values(obj);
          for (var i = 0, length = obj.length; i < length; i++) {
            value = obj[i];
            if (value != null && value < result) {
              result = value;
            }
          }
        } else {
          iteratee = cb(iteratee, context);
          _.each(obj, function(v, index, list) {
            computed = iteratee(v, index, list);
            if (computed < lastComputed || computed === Infinity && result === Infinity) {
              result = v;
              lastComputed = computed;
            }
          });
        }
        return result;
      };
    
      // Shuffle a collection.
      _.shuffle = function(obj) {
        return _.sample(obj, Infinity);
      };
    
      // Sample **n** random values from a collection using the modern version of the
      // [Fisher-Yates shuffle](http://en.wikipedia.org/wiki/Fisher–Yates_shuffle).
      // If **n** is not specified, returns a single random element.
      // The internal `guard` argument allows it to work with `map`.
      _.sample = function(obj, n, guard) {
        if (n == null || guard) {
          if (!isArrayLike(obj)) obj = _.values(obj);
          return obj[_.random(obj.length - 1)];
        }
        var sample = isArrayLike(obj) ? _.clone(obj) : _.values(obj);
        var length = getLength(sample);
        n = Math.max(Math.min(n, length), 0);
        var last = length - 1;
        for (var index = 0; index < n; index++) {
          var rand = _.random(index, last);
          var temp = sample[index];
          sample[index] = sample[rand];
          sample[rand] = temp;
        }
        return sample.slice(0, n);
      };
    
      // Sort the object's values by a criterion produced by an iteratee.
      _.sortBy = function(obj, iteratee, context) {
        var index = 0;
        iteratee = cb(iteratee, context);
        return _.pluck(_.map(obj, function(value, key, list) {
          return {
            value: value,
            index: index++,
            criteria: iteratee(value, key, list)
          };
        }).sort(function(left, right) {
          var a = left.criteria;
          var b = right.criteria;
          if (a !== b) {
            if (a > b || a === void 0) return 1;
            if (a < b || b === void 0) return -1;
          }
          return left.index - right.index;
        }), 'value');
      };
    
      // An internal function used for aggregate "group by" operations.
      var group = function(behavior, partition) {
        return function(obj, iteratee, context) {
          var result = partition ? [[], []] : {};
          iteratee = cb(iteratee, context);
          _.each(obj, function(value, index) {
            var key = iteratee(value, index, obj);
            behavior(result, value, key);
          });
          return result;
        };
      };
    
      // Groups the object's values by a criterion. Pass either a string attribute
      // to group by, or a function that returns the criterion.
      _.groupBy = group(function(result, value, key) {
        if (_.has(result, key)) result[key].push(value); else result[key] = [value];
      });
    
      // Indexes the object's values by a criterion, similar to `groupBy`, but for
      // when you know that your index values will be unique.
      _.indexBy = group(function(result, value, key) {
        result[key] = value;
      });
    
      // Counts instances of an object that group by a certain criterion. Pass
      // either a string attribute to count by, or a function that returns the
      // criterion.
      _.countBy = group(function(result, value, key) {
        if (_.has(result, key)) result[key]++; else result[key] = 1;
      });
    
      var reStrSymbol = /[^\ud800-\udfff]|[\ud800-\udbff][\udc00-\udfff]|[\ud800-\udfff]/g;
      // Safely create a real, live array from anything iterable.
      _.toArray = function(obj) {
        if (!obj) return [];
        if (_.isArray(obj)) return slice.call(obj);
        if (_.isString(obj)) {
          // Keep surrogate pair characters together
          return obj.match(reStrSymbol);
        }
        if (isArrayLike(obj)) return _.map(obj, _.identity);
        return _.values(obj);
      };
    
      // Return the number of elements in an object.
      _.size = function(obj) {
        if (obj == null) return 0;
        return isArrayLike(obj) ? obj.length : _.keys(obj).length;
      };
    
      // Split a collection into two arrays: one whose elements all satisfy the given
      // predicate, and one whose elements all do not satisfy the predicate.
      _.partition = group(function(result, value, pass) {
        result[pass ? 0 : 1].push(value);
      }, true);
    
      // Array Functions
      // ---------------
    
      // Get the first element of an array. Passing **n** will return the first N
      // values in the array. Aliased as `head` and `take`. The **guard** check
      // allows it to work with `_.map`.
      _.first = _.head = _.take = function(array, n, guard) {
        if (array == null || array.length < 1) return void 0;
        if (n == null || guard) return array[0];
        return _.initial(array, array.length - n);
      };
    
      // Returns everything but the last entry of the array. Especially useful on
      // the arguments object. Passing **n** will return all the values in
      // the array, excluding the last N.
      _.initial = function(array, n, guard) {
        return slice.call(array, 0, Math.max(0, array.length - (n == null || guard ? 1 : n)));
      };
    
      // Get the last element of an array. Passing **n** will return the last N
      // values in the array.
      _.last = function(array, n, guard) {
        if (array == null || array.length < 1) return void 0;
        if (n == null || guard) return array[array.length - 1];
        return _.rest(array, Math.max(0, array.length - n));
      };
    
      // Returns everything but the first entry of the array. Aliased as `tail` and `drop`.
      // Especially useful on the arguments object. Passing an **n** will return
      // the rest N values in the array.
      _.rest = _.tail = _.drop = function(array, n, guard) {
        return slice.call(array, n == null || guard ? 1 : n);
      };
    
      // Trim out all falsy values from an array.
      _.compact = function(array) {
        return _.filter(array, Boolean);
      };
    
      // Internal implementation of a recursive `flatten` function.
      var flatten = function(input, shallow, strict, output) {
        output = output || [];
        var idx = output.length;
        for (var i = 0, length = getLength(input); i < length; i++) {
          var value = input[i];
          if (isArrayLike(value) && (_.isArray(value) || _.isArguments(value))) {
            // Flatten current level of array or arguments object.
            if (shallow) {
              var j = 0, len = value.length;
              while (j < len) output[idx++] = value[j++];
            } else {
              flatten(value, shallow, strict, output);
              idx = output.length;
            }
          } else if (!strict) {
            output[idx++] = value;
          }
        }
        return output;
      };
    
      // Flatten out an array, either recursively (by default), or just one level.
      _.flatten = function(array, shallow) {
        return flatten(array, shallow, false);
      };
    
      // Return a version of the array that does not contain the specified value(s).
      _.without = restArgs(function(array, otherArrays) {
        return _.difference(array, otherArrays);
      });
    
      // Produce a duplicate-free version of the array. If the array has already
      // been sorted, you have the option of using a faster algorithm.
      // Aliased as `unique`.
      _.uniq = _.unique = function(array, isSorted, iteratee, context) {
        if (!_.isBoolean(isSorted)) {
          context = iteratee;
          iteratee = isSorted;
          isSorted = false;
        }
        if (iteratee != null) iteratee = cb(iteratee, context);
        var result = [];
        var seen = [];
        for (var i = 0, length = getLength(array); i < length; i++) {
          var value = array[i],
              computed = iteratee ? iteratee(value, i, array) : value;
          if (isSorted) {
            if (!i || seen !== computed) result.push(value);
            seen = computed;
          } else if (iteratee) {
            if (!_.contains(seen, computed)) {
              seen.push(computed);
              result.push(value);
            }
          } else if (!_.contains(result, value)) {
            result.push(value);
          }
        }
        return result;
      };
    
      // Produce an array that contains the union: each distinct element from all of
      // the passed-in arrays.
      _.union = restArgs(function(arrays) {
        return _.uniq(flatten(arrays, true, true));
      });
    
      // Produce an array that contains every item shared between all the
      // passed-in arrays.
      _.intersection = function(array) {
        var result = [];
        var argsLength = arguments.length;
        for (var i = 0, length = getLength(array); i < length; i++) {
          var item = array[i];
          if (_.contains(result, item)) continue;
          var j;
          for (j = 1; j < argsLength; j++) {
            if (!_.contains(arguments[j], item)) break;
          }
          if (j === argsLength) result.push(item);
        }
        return result;
      };
    
      // Take the difference between one array and a number of other arrays.
      // Only the elements present in just the first array will remain.
      _.difference = restArgs(function(array, rest) {
        rest = flatten(rest, true, true);
        return _.filter(array, function(value){
          return !_.contains(rest, value);
        });
      });
    
      // Complement of _.zip. Unzip accepts an array of arrays and groups
      // each array's elements on shared indices.
      _.unzip = function(array) {
        var length = array && _.max(array, getLength).length || 0;
        var result = Array(length);
    
        for (var index = 0; index < length; index++) {
          result[index] = _.pluck(array, index);
        }
        return result;
      };
    
      // Zip together multiple lists into a single array -- elements that share
      // an index go together.
      _.zip = restArgs(_.unzip);
    
      // Converts lists into objects. Pass either a single array of `[key, value]`
      // pairs, or two parallel arrays of the same length -- one of keys, and one of
      // the corresponding values.
      _.object = function(list, values) {
        var result = {};
        for (var i = 0, length = getLength(list); i < length; i++) {
          if (values) {
            result[list[i]] = values[i];
          } else {
            result[list[i][0]] = list[i][1];
          }
        }
        return result;
      };
    
      // Generator function to create the findIndex and findLastIndex functions.
      var createPredicateIndexFinder = function(dir) {
        return function(array, predicate, context) {
          predicate = cb(predicate, context);
          var length = getLength(array);
          var index = dir > 0 ? 0 : length - 1;
          for (; index >= 0 && index < length; index += dir) {
            if (predicate(array[index], index, array)) return index;
          }
          return -1;
        };
      };
    
      // Returns the first index on an array-like that passes a predicate test.
      _.findIndex = createPredicateIndexFinder(1);
      _.findLastIndex = createPredicateIndexFinder(-1);
    
      // Use a comparator function to figure out the smallest index at which
      // an object should be inserted so as to maintain order. Uses binary search.
      _.sortedIndex = function(array, obj, iteratee, context) {
        iteratee = cb(iteratee, context, 1);
        var value = iteratee(obj);
        var low = 0, high = getLength(array);
        while (low < high) {
          var mid = Math.floor((low + high) / 2);
          if (iteratee(array[mid]) < value) low = mid + 1; else high = mid;
        }
        return low;
      };
    
      // Generator function to create the indexOf and lastIndexOf functions.
      var createIndexFinder = function(dir, predicateFind, sortedIndex) {
        return function(array, item, idx) {
          var i = 0, length = getLength(array);
          if (typeof idx == 'number') {
            if (dir > 0) {
              i = idx >= 0 ? idx : Math.max(idx + length, i);
            } else {
              length = idx >= 0 ? Math.min(idx + 1, length) : idx + length + 1;
            }
          } else if (sortedIndex && idx && length) {
            idx = sortedIndex(array, item);
            return array[idx] === item ? idx : -1;
          }
          if (item !== item) {
            idx = predicateFind(slice.call(array, i, length), _.isNaN);
            return idx >= 0 ? idx + i : -1;
          }
          for (idx = dir > 0 ? i : length - 1; idx >= 0 && idx < length; idx += dir) {
            if (array[idx] === item) return idx;
          }
          return -1;
        };
      };
    
      // Return the position of the first occurrence of an item in an array,
      // or -1 if the item is not included in the array.
      // If the array is large and already in sort order, pass `true`
      // for **isSorted** to use binary search.
      _.indexOf = createIndexFinder(1, _.findIndex, _.sortedIndex);
      _.lastIndexOf = createIndexFinder(-1, _.findLastIndex);
    
      // Generate an integer Array containing an arithmetic progression. A port of
      // the native Python `range()` function. See
      // [the Python documentation](http://docs.python.org/library/functions.html#range).
      _.range = function(start, stop, step) {
        if (stop == null) {
          stop = start || 0;
          start = 0;
        }
        if (!step) {
          step = stop < start ? -1 : 1;
        }
    
        var length = Math.max(Math.ceil((stop - start) / step), 0);
        var range = Array(length);
    
        for (var idx = 0; idx < length; idx++, start += step) {
          range[idx] = start;
        }
    
        return range;
      };
    
      // Split an **array** into several arrays containing **count** or less elements
      // of initial array.
      _.chunk = function(array, count) {
        if (count == null || count < 1) return [];
    
        var result = [];
        var i = 0, length = array.length;
        while (i < length) {
          result.push(slice.call(array, i, i += count));
        }
        return result;
      };
    
      // Function (ahem) Functions
      // ------------------
    
      // Determines whether to execute a function as a constructor
      // or a normal function with the provided arguments.
      var executeBound = function(sourceFunc, boundFunc, context, callingContext, args) {
        if (!(callingContext instanceof boundFunc)) return sourceFunc.apply(context, args);
        var self = baseCreate(sourceFunc.prototype);
        var result = sourceFunc.apply(self, args);
        if (_.isObject(result)) return result;
        return self;
      };
    
      // Create a function bound to a given object (assigning `this`, and arguments,
      // optionally). Delegates to **ECMAScript 5**'s native `Function.bind` if
      // available.
      _.bind = restArgs(function(func, context, args) {
        if (!_.isFunction(func)) throw new TypeError('Bind must be called on a function');
        var bound = restArgs(function(callArgs) {
          return executeBound(func, bound, context, this, args.concat(callArgs));
        });
        return bound;
      });
    
      // Partially apply a function by creating a version that has had some of its
      // arguments pre-filled, without changing its dynamic `this` context. _ acts
      // as a placeholder by default, allowing any combination of arguments to be
      // pre-filled. Set `_.partial.placeholder` for a custom placeholder argument.
      _.partial = restArgs(function(func, boundArgs) {
        var placeholder = _.partial.placeholder;
        var bound = function() {
          var position = 0, length = boundArgs.length;
          var args = Array(length);
          for (var i = 0; i < length; i++) {
            args[i] = boundArgs[i] === placeholder ? arguments[position++] : boundArgs[i];
          }
          while (position < arguments.length) args.push(arguments[position++]);
          return executeBound(func, bound, this, this, args);
        };
        return bound;
      });
    
      _.partial.placeholder = _;
    
      // Bind a number of an object's methods to that object. Remaining arguments
      // are the method names to be bound. Useful for ensuring that all callbacks
      // defined on an object belong to it.
      _.bindAll = restArgs(function(obj, keys) {
        keys = flatten(keys, false, false);
        var index = keys.length;
        if (index < 1) throw new Error('bindAll must be passed function names');
        while (index--) {
          var key = keys[index];
          obj[key] = _.bind(obj[key], obj);
        }
      });
    
      // Memoize an expensive function by storing its results.
      _.memoize = function(func, hasher) {
        var memoize = function(key) {
          var cache = memoize.cache;
          var address = '' + (hasher ? hasher.apply(this, arguments) : key);
          if (!_.has(cache, address)) cache[address] = func.apply(this, arguments);
          return cache[address];
        };
        memoize.cache = {};
        return memoize;
      };
    
      // Delays a function for the given number of milliseconds, and then calls
      // it with the arguments supplied.
      _.delay = restArgs(function(func, wait, args) {
        return setTimeout(function() {
          return func.apply(null, args);
        }, wait);
      });
    
      // Defers a function, scheduling it to run after the current call stack has
      // cleared.
      _.defer = _.partial(_.delay, _, 1);
    
      // Returns a function, that, when invoked, will only be triggered at most once
      // during a given window of time. Normally, the throttled function will run
      // as much as it can, without ever going more than once per `wait` duration;
      // but if you'd like to disable the execution on the leading edge, pass
      // `{leading: false}`. To disable execution on the trailing edge, ditto.
      _.throttle = function(func, wait, options) {
        var timeout, context, args, result;
        var previous = 0;
        if (!options) options = {};
    
        var later = function() {
          previous = options.leading === false ? 0 : _.now();
          timeout = null;
          result = func.apply(context, args);
          if (!timeout) context = args = null;
        };
    
        var throttled = function() {
          var now = _.now();
          if (!previous && options.leading === false) previous = now;
          var remaining = wait - (now - previous);
          context = this;
          args = arguments;
          if (remaining <= 0 || remaining > wait) {
            if (timeout) {
              clearTimeout(timeout);
              timeout = null;
            }
            previous = now;
            result = func.apply(context, args);
            if (!timeout) context = args = null;
          } else if (!timeout && options.trailing !== false) {
            timeout = setTimeout(later, remaining);
          }
          return result;
        };
    
        throttled.cancel = function() {
          clearTimeout(timeout);
          previous = 0;
          timeout = context = args = null;
        };
    
        return throttled;
      };
    
      // Returns a function, that, as long as it continues to be invoked, will not
      // be triggered. The function will be called after it stops being called for
      // N milliseconds. If `immediate` is passed, trigger the function on the
      // leading edge, instead of the trailing.
      _.debounce = function(func, wait, immediate) {
        var timeout, result;
    
        var later = function(context, args) {
          timeout = null;
          if (args) result = func.apply(context, args);
        };
    
        var debounced = restArgs(function(args) {
          if (timeout) clearTimeout(timeout);
          if (immediate) {
            var callNow = !timeout;
            timeout = setTimeout(later, wait);
            if (callNow) result = func.apply(this, args);
          } else {
            timeout = _.delay(later, wait, this, args);
          }
    
          return result;
        });
    
        debounced.cancel = function() {
          clearTimeout(timeout);
          timeout = null;
        };
    
        return debounced;
      };
    
      // Returns the first function passed as an argument to the second,
      // allowing you to adjust arguments, run code before and after, and
      // conditionally execute the original function.
      _.wrap = function(func, wrapper) {
        return _.partial(wrapper, func);
      };
    
      // Returns a negated version of the passed-in predicate.
      _.negate = function(predicate) {
        return function() {
          return !predicate.apply(this, arguments);
        };
      };
    
      // Returns a function that is the composition of a list of functions, each
      // consuming the return value of the function that follows.
      _.compose = function() {
        var args = arguments;
        var start = args.length - 1;
        return function() {
          var i = start;
          var result = args[start].apply(this, arguments);
          while (i--) result = args[i].call(this, result);
          return result;
        };
      };
    
      // Returns a function that will only be executed on and after the Nth call.
      _.after = function(times, func) {
        return function() {
          if (--times < 1) {
            return func.apply(this, arguments);
          }
        };
      };
    
      // Returns a function that will only be executed up to (but not including) the Nth call.
      _.before = function(times, func) {
        var memo;
        return function() {
          if (--times > 0) {
            memo = func.apply(this, arguments);
          }
          if (times <= 1) func = null;
          return memo;
        };
      };
    
      // Returns a function that will be executed at most one time, no matter how
      // often you call it. Useful for lazy initialization.
      _.once = _.partial(_.before, 2);
    
      _.restArgs = restArgs;
    
      // Object Functions
      // ----------------
    
      // Keys in IE < 9 that won't be iterated by `for key in ...` and thus missed.
      var hasEnumBug = !{toString: null}.propertyIsEnumerable('toString');
      var nonEnumerableProps = ['valueOf', 'isPrototypeOf', 'toString',
                          'propertyIsEnumerable', 'hasOwnProperty', 'toLocaleString'];
    
      var collectNonEnumProps = function(obj, keys) {
        var nonEnumIdx = nonEnumerableProps.length;
        var constructor = obj.constructor;
        var proto = _.isFunction(constructor) && constructor.prototype || ObjProto;
    
        // Constructor is a special case.
        var prop = 'constructor';
        if (_.has(obj, prop) && !_.contains(keys, prop)) keys.push(prop);
    
        while (nonEnumIdx--) {
          prop = nonEnumerableProps[nonEnumIdx];
          if (prop in obj && obj[prop] !== proto[prop] && !_.contains(keys, prop)) {
            keys.push(prop);
          }
        }
      };
    
      // Retrieve the names of an object's own properties.
      // Delegates to **ECMAScript 5**'s native `Object.keys`.
      _.keys = function(obj) {
        if (!_.isObject(obj)) return [];
        if (nativeKeys) return nativeKeys(obj);
        var keys = [];
        for (var key in obj) if (_.has(obj, key)) keys.push(key);
        // Ahem, IE < 9.
        if (hasEnumBug) collectNonEnumProps(obj, keys);
        return keys;
      };
    
      // Retrieve all the property names of an object.
      _.allKeys = function(obj) {
        if (!_.isObject(obj)) return [];
        var keys = [];
        for (var key in obj) keys.push(key);
        // Ahem, IE < 9.
        if (hasEnumBug) collectNonEnumProps(obj, keys);
        return keys;
      };
    
      // Retrieve the values of an object's properties.
      _.values = function(obj) {
        var keys = _.keys(obj);
        var length = keys.length;
        var values = Array(length);
        for (var i = 0; i < length; i++) {
          values[i] = obj[keys[i]];
        }
        return values;
      };
    
      // Returns the results of applying the iteratee to each element of the object.
      // In contrast to _.map it returns an object.
      _.mapObject = function(obj, iteratee, context) {
        iteratee = cb(iteratee, context);
        var keys = _.keys(obj),
            length = keys.length,
            results = {};
        for (var index = 0; index < length; index++) {
          var currentKey = keys[index];
          results[currentKey] = iteratee(obj[currentKey], currentKey, obj);
        }
        return results;
      };
    
      // Convert an object into a list of `[key, value]` pairs.
      _.pairs = function(obj) {
        var keys = _.keys(obj);
        var length = keys.length;
        var pairs = Array(length);
        for (var i = 0; i < length; i++) {
          pairs[i] = [keys[i], obj[keys[i]]];
        }
        return pairs;
      };
    
      // Invert the keys and values of an object. The values must be serializable.
      _.invert = function(obj) {
        var result = {};
        var keys = _.keys(obj);
        for (var i = 0, length = keys.length; i < length; i++) {
          result[obj[keys[i]]] = keys[i];
        }
        return result;
      };
    
      // Return a sorted list of the function names available on the object.
      // Aliased as `methods`.
      _.functions = _.methods = function(obj) {
        var names = [];
        for (var key in obj) {
          if (_.isFunction(obj[key])) names.push(key);
        }
        return names.sort();
      };
    
      // An internal function for creating assigner functions.
      var createAssigner = function(keysFunc, defaults) {
        return function(obj) {
          var length = arguments.length;
          if (defaults) obj = Object(obj);
          if (length < 2 || obj == null) return obj;
          for (var index = 1; index < length; index++) {
            var source = arguments[index],
                keys = keysFunc(source),
                l = keys.length;
            for (var i = 0; i < l; i++) {
              var key = keys[i];
              if (!defaults || obj[key] === void 0) obj[key] = source[key];
            }
          }
          return obj;
        };
      };
    
      // Extend a given object with all the properties in passed-in object(s).
      _.extend = createAssigner(_.allKeys);
    
      // Assigns a given object with all the own properties in the passed-in object(s).
      // (https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/assign)
      _.extendOwn = _.assign = createAssigner(_.keys);
    
      // Returns the first key on an object that passes a predicate test.
      _.findKey = function(obj, predicate, context) {
        predicate = cb(predicate, context);
        var keys = _.keys(obj), key;
        for (var i = 0, length = keys.length; i < length; i++) {
          key = keys[i];
          if (predicate(obj[key], key, obj)) return key;
        }
      };
    
      // Internal pick helper function to determine if `obj` has key `key`.
      var keyInObj = function(value, key, obj) {
        return key in obj;
      };
    
      // Return a copy of the object only containing the whitelisted properties.
      _.pick = restArgs(function(obj, keys) {
        var result = {}, iteratee = keys[0];
        if (obj == null) return result;
        if (_.isFunction(iteratee)) {
          if (keys.length > 1) iteratee = optimizeCb(iteratee, keys[1]);
          keys = _.allKeys(obj);
        } else {
          iteratee = keyInObj;
          keys = flatten(keys, false, false);
          obj = Object(obj);
        }
        for (var i = 0, length = keys.length; i < length; i++) {
          var key = keys[i];
          var value = obj[key];
          if (iteratee(value, key, obj)) result[key] = value;
        }
        return result;
      });
    
      // Return a copy of the object without the blacklisted properties.
      _.omit = restArgs(function(obj, keys) {
        var iteratee = keys[0], context;
        if (_.isFunction(iteratee)) {
          iteratee = _.negate(iteratee);
          if (keys.length > 1) context = keys[1];
        } else {
          keys = _.map(flatten(keys, false, false), String);
          iteratee = function(value, key) {
            return !_.contains(keys, key);
          };
        }
        return _.pick(obj, iteratee, context);
      });
    
      // Fill in a given object with default properties.
      _.defaults = createAssigner(_.allKeys, true);
    
      // Creates an object that inherits from the given prototype object.
      // If additional properties are provided then they will be added to the
      // created object.
      _.create = function(prototype, props) {
        var result = baseCreate(prototype);
        if (props) _.extendOwn(result, props);
        return result;
      };
    
      // Create a (shallow-cloned) duplicate of an object.
      _.clone = function(obj) {
        if (!_.isObject(obj)) return obj;
        return _.isArray(obj) ? obj.slice() : _.extend({}, obj);
      };
    
      // Invokes interceptor with the obj, and then returns obj.
      // The primary purpose of this method is to "tap into" a method chain, in
      // order to perform operations on intermediate results within the chain.
      _.tap = function(obj, interceptor) {
        interceptor(obj);
        return obj;
      };
    
      // Returns whether an object has a given set of `key:value` pairs.
      _.isMatch = function(object, attrs) {
        var keys = _.keys(attrs), length = keys.length;
        if (object == null) return !length;
        var obj = Object(object);
        for (var i = 0; i < length; i++) {
          var key = keys[i];
          if (attrs[key] !== obj[key] || !(key in obj)) return false;
        }
        return true;
      };
    
    
      // Internal recursive comparison function for `isEqual`.
      var eq, deepEq;
      eq = function(a, b, aStack, bStack) {
        // Identical objects are equal. `0 === -0`, but they aren't identical.
        // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).
        if (a === b) return a !== 0 || 1 / a === 1 / b;
        // A strict comparison is necessary because `null == undefined`.
        if (a == null || b == null) return a === b;
        // `NaN`s are equivalent, but non-reflexive.
        if (a !== a) return b !== b;
        // Exhaust primitive checks
        var type = typeof a;
        if (type !== 'function' && type !== 'object' && typeof b != 'object') return false;
        return deepEq(a, b, aStack, bStack);
      };
    
      // Internal recursive comparison function for `isEqual`.
      deepEq = function(a, b, aStack, bStack) {
        // Unwrap any wrapped objects.
        if (a instanceof _) a = a._wrapped;
        if (b instanceof _) b = b._wrapped;
        // Compare `[[Class]]` names.
        var className = toString.call(a);
        if (className !== toString.call(b)) return false;
        switch (className) {
          // Strings, numbers, regular expressions, dates, and booleans are compared by value.
          case '[object RegExp]':
          // RegExps are coerced to strings for comparison (Note: '' + /a/i === '/a/i')
          case '[object String]':
            // Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is
            // equivalent to `new String("5")`.
            return '' + a === '' + b;
          case '[object Number]':
            // `NaN`s are equivalent, but non-reflexive.
            // Object(NaN) is equivalent to NaN.
            if (+a !== +a) return +b !== +b;
            // An `egal` comparison is performed for other numeric values.
            return +a === 0 ? 1 / +a === 1 / b : +a === +b;
          case '[object Date]':
          case '[object Boolean]':
            // Coerce dates and booleans to numeric primitive values. Dates are compared by their
            // millisecond representations. Note that invalid dates with millisecond representations
            // of `NaN` are not equivalent.
            return +a === +b;
          case '[object Symbol]':
            return SymbolProto.valueOf.call(a) === SymbolProto.valueOf.call(b);
        }
    
        var areArrays = className === '[object Array]';
        if (!areArrays) {
          if (typeof a != 'object' || typeof b != 'object') return false;
    
          // Objects with different constructors are not equivalent, but `Object`s or `Array`s
          // from different frames are.
          var aCtor = a.constructor, bCtor = b.constructor;
          if (aCtor !== bCtor && !(_.isFunction(aCtor) && aCtor instanceof aCtor &&
                                   _.isFunction(bCtor) && bCtor instanceof bCtor)
                              && ('constructor' in a && 'constructor' in b)) {
            return false;
          }
        }
        // Assume equality for cyclic structures. The algorithm for detecting cyclic
        // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.
    
        // Initializing stack of traversed objects.
        // It's done here since we only need them for objects and arrays comparison.
        aStack = aStack || [];
        bStack = bStack || [];
        var length = aStack.length;
        while (length--) {
          // Linear search. Performance is inversely proportional to the number of
          // unique nested structures.
          if (aStack[length] === a) return bStack[length] === b;
        }
    
        // Add the first object to the stack of traversed objects.
        aStack.push(a);
        bStack.push(b);
    
        // Recursively compare objects and arrays.
        if (areArrays) {
          // Compare array lengths to determine if a deep comparison is necessary.
          length = a.length;
          if (length !== b.length) return false;
          // Deep compare the contents, ignoring non-numeric properties.
          while (length--) {
            if (!eq(a[length], b[length], aStack, bStack)) return false;
          }
        } else {
          // Deep compare objects.
          var keys = _.keys(a), key;
          length = keys.length;
          // Ensure that both objects contain the same number of properties before comparing deep equality.
          if (_.keys(b).length !== length) return false;
          while (length--) {
            // Deep compare each member
            key = keys[length];
            if (!(_.has(b, key) && eq(a[key], b[key], aStack, bStack))) return false;
          }
        }
        // Remove the first object from the stack of traversed objects.
        aStack.pop();
        bStack.pop();
        return true;
      };
    
      // Perform a deep comparison to check if two objects are equal.
      _.isEqual = function(a, b) {
        return eq(a, b);
      };
    
      // Is a given array, string, or object empty?
      // An "empty" object has no enumerable own-properties.
      _.isEmpty = function(obj) {
        if (obj == null) return true;
        if (isArrayLike(obj) && (_.isArray(obj) || _.isString(obj) || _.isArguments(obj))) return obj.length === 0;
        return _.keys(obj).length === 0;
      };
    
      // Is a given value a DOM element?
      _.isElement = function(obj) {
        return !!(obj && obj.nodeType === 1);
      };
    
      // Is a given value an array?
      // Delegates to ECMA5's native Array.isArray
      _.isArray = nativeIsArray || function(obj) {
        return toString.call(obj) === '[object Array]';
      };
    
      // Is a given variable an object?
      _.isObject = function(obj) {
        var type = typeof obj;
        return type === 'function' || type === 'object' && !!obj;
      };
    
      // Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp, isError, isMap, isWeakMap, isSet, isWeakSet.
      _.each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp', 'Error', 'Symbol', 'Map', 'WeakMap', 'Set', 'WeakSet'], function(name) {
        _['is' + name] = function(obj) {
          return toString.call(obj) === '[object ' + name + ']';
        };
      });
    
      // Define a fallback version of the method in browsers (ahem, IE < 9), where
      // there isn't any inspectable "Arguments" type.
      if (!_.isArguments(arguments)) {
        _.isArguments = function(obj) {
          return _.has(obj, 'callee');
        };
      }
    
      // Optimize `isFunction` if appropriate. Work around some typeof bugs in old v8,
      // IE 11 (#1621), Safari 8 (#1929), and PhantomJS (#2236).
      var nodelist = root.document && root.document.childNodes;
      if (typeof /./ != 'function' && typeof Int8Array != 'object' && typeof nodelist != 'function') {
        _.isFunction = function(obj) {
          return typeof obj == 'function' || false;
        };
      }
    
      // Is a given object a finite number?
      _.isFinite = function(obj) {
        return !_.isSymbol(obj) && isFinite(obj) && !isNaN(parseFloat(obj));
      };
    
      // Is the given value `NaN`?
      _.isNaN = function(obj) {
        return _.isNumber(obj) && isNaN(obj);
      };
    
      // Is a given value a boolean?
      _.isBoolean = function(obj) {
        return obj === true || obj === false || toString.call(obj) === '[object Boolean]';
      };
    
      // Is a given value equal to null?
      _.isNull = function(obj) {
        return obj === null;
      };
    
      // Is a given variable undefined?
      _.isUndefined = function(obj) {
        return obj === void 0;
      };
    
      // Shortcut function for checking if an object has a given property directly
      // on itself (in other words, not on a prototype).
      _.has = function(obj, key) {
        return obj != null && hasOwnProperty.call(obj, key);
      };
    
      // Utility Functions
      // -----------------
    
      // Run Underscore.js in *noConflict* mode, returning the `_` variable to its
      // previous owner. Returns a reference to the Underscore object.
      _.noConflict = function() {
        root._ = previousUnderscore;
        return this;
      };
    
      // Keep the identity function around for default iteratees.
      _.identity = function(value) {
        return value;
      };
    
      // Predicate-generating functions. Often useful outside of Underscore.
      _.constant = function(value) {
        return function() {
          return value;
        };
      };
    
      _.noop = function(){};
    
      _.property = property;
    
      // Generates a function for a given object that returns a given property.
      _.propertyOf = function(obj) {
        return obj == null ? function(){} : function(key) {
          return obj[key];
        };
      };
    
      // Returns a predicate for checking whether an object has a given set of
      // `key:value` pairs.
      _.matcher = _.matches = function(attrs) {
        attrs = _.extendOwn({}, attrs);
        return function(obj) {
          return _.isMatch(obj, attrs);
        };
      };
    
      // Run a function **n** times.
      _.times = function(n, iteratee, context) {
        var accum = Array(Math.max(0, n));
        iteratee = optimizeCb(iteratee, context, 1);
        for (var i = 0; i < n; i++) accum[i] = iteratee(i);
        return accum;
      };
    
      // Return a random integer between min and max (inclusive).
      _.random = function(min, max) {
        if (max == null) {
          max = min;
          min = 0;
        }
        return min + Math.floor(Math.random() * (max - min + 1));
      };
    
      // A (possibly faster) way to get the current timestamp as an integer.
      _.now = Date.now || function() {
        return new Date().getTime();
      };
    
      // List of HTML entities for escaping.
      var escapeMap = {
        '&': '&amp;',
        '<': '&lt;',
        '>': '&gt;',
        '"': '&quot;',
        "'": '&#x27;',
        '`': '&#x60;'
      };
      var unescapeMap = _.invert(escapeMap);
    
      // Functions for escaping and unescaping strings to/from HTML interpolation.
      var createEscaper = function(map) {
        var escaper = function(match) {
          return map[match];
        };
        // Regexes for identifying a key that needs to be escaped.
        var source = '(?:' + _.keys(map).join('|') + ')';
        var testRegexp = RegExp(source);
        var replaceRegexp = RegExp(source, 'g');
        return function(string) {
          string = string == null ? '' : '' + string;
          return testRegexp.test(string) ? string.replace(replaceRegexp, escaper) : string;
        };
      };
      _.escape = createEscaper(escapeMap);
      _.unescape = createEscaper(unescapeMap);
    
      // If the value of the named `property` is a function then invoke it with the
      // `object` as context; otherwise, return it.
      _.result = function(object, prop, fallback) {
        var value = object == null ? void 0 : object[prop];
        if (value === void 0) {
          value = fallback;
        }
        return _.isFunction(value) ? value.call(object) : value;
      };
    
      // Generate a unique integer id (unique within the entire client session).
      // Useful for temporary DOM ids.
      var idCounter = 0;
      _.uniqueId = function(prefix) {
        var id = ++idCounter + '';
        return prefix ? prefix + id : id;
      };
    
      // By default, Underscore uses ERB-style template delimiters, change the
      // following template settings to use alternative delimiters.
      _.templateSettings = {
        evaluate: /<%([\s\S]+?)%>/g,
        interpolate: /<%=([\s\S]+?)%>/g,
        escape: /<%-([\s\S]+?)%>/g
      };
    
      // When customizing `templateSettings`, if you don't want to define an
      // interpolation, evaluation or escaping regex, we need one that is
      // guaranteed not to match.
      var noMatch = /(.)^/;
    
      // Certain characters need to be escaped so that they can be put into a
      // string literal.
      var escapes = {
        "'": "'",
        '\\': '\\',
        '\r': 'r',
        '\n': 'n',
        '\u2028': 'u2028',
        '\u2029': 'u2029'
      };
    
      var escapeRegExp = /\\|'|\r|\n|\u2028|\u2029/g;
    
      var escapeChar = function(match) {
        return '\\' + escapes[match];
      };
    
      // JavaScript micro-templating, similar to John Resig's implementation.
      // Underscore templating handles arbitrary delimiters, preserves whitespace,
      // and correctly escapes quotes within interpolated code.
      // NB: `oldSettings` only exists for backwards compatibility.
      _.template = function(text, settings, oldSettings) {
        if (!settings && oldSettings) settings = oldSettings;
        settings = _.defaults({}, settings, _.templateSettings);
    
        // Combine delimiters into one regular expression via alternation.
        var matcher = RegExp([
          (settings.escape || noMatch).source,
          (settings.interpolate || noMatch).source,
          (settings.evaluate || noMatch).source
        ].join('|') + '|$', 'g');
    
        // Compile the template source, escaping string literals appropriately.
        var index = 0;
        var source = "__p+='";
        text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {
          source += text.slice(index, offset).replace(escapeRegExp, escapeChar);
          index = offset + match.length;
    
          if (escape) {
            source += "'+\n((__t=(" + escape + "))==null?'':_.escape(__t))+\n'";
          } else if (interpolate) {
            source += "'+\n((__t=(" + interpolate + "))==null?'':__t)+\n'";
          } else if (evaluate) {
            source += "';\n" + evaluate + "\n__p+='";
          }
    
          // Adobe VMs need the match returned to produce the correct offset.
          return match;
        });
        source += "';\n";
    
        // If a variable is not specified, place data values in local scope.
        if (!settings.variable) source = 'with(obj||{}){\n' + source + '}\n';
    
        source = "var __t,__p='',__j=Array.prototype.join," +
          "print=function(){__p+=__j.call(arguments,'');};\n" +
          source + 'return __p;\n';
    
        var render;
        try {
          render = new Function(settings.variable || 'obj', '_', source);
        } catch (e) {
          e.source = source;
          throw e;
        }
    
        var template = function(data) {
          return render.call(this, data, _);
        };
    
        // Provide the compiled source as a convenience for precompilation.
        var argument = settings.variable || 'obj';
        template.source = 'function(' + argument + '){\n' + source + '}';
    
        return template;
      };
    
      // Add a "chain" function. Start chaining a wrapped Underscore object.
      _.chain = function(obj) {
        var instance = _(obj);
        instance._chain = true;
        return instance;
      };
    
      // OOP
      // ---------------
      // If Underscore is called as a function, it returns a wrapped object that
      // can be used OO-style. This wrapper holds altered versions of all the
      // underscore functions. Wrapped objects may be chained.
    
      // Helper function to continue chaining intermediate results.
      var chainResult = function(instance, obj) {
        return instance._chain ? _(obj).chain() : obj;
      };
    
      // Add your own custom functions to the Underscore object.
      _.mixin = function(obj) {
        _.each(_.functions(obj), function(name) {
          var func = _[name] = obj[name];
          _.prototype[name] = function() {
            var args = [this._wrapped];
            push.apply(args, arguments);
            return chainResult(this, func.apply(_, args));
          };
        });
        return _;
      };
    
      // Add all of the Underscore functions to the wrapper object.
      _.mixin(_);
    
      // Add all mutator Array functions to the wrapper.
      _.each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {
        var method = ArrayProto[name];
        _.prototype[name] = function() {
          var obj = this._wrapped;
          method.apply(obj, arguments);
          if ((name === 'shift' || name === 'splice') && obj.length === 0) delete obj[0];
          return chainResult(this, obj);
        };
      });
    
      // Add all accessor Array functions to the wrapper.
      _.each(['concat', 'join', 'slice'], function(name) {
        var method = ArrayProto[name];
        _.prototype[name] = function() {
          return chainResult(this, method.apply(this._wrapped, arguments));
        };
      });
    
      // Extracts the result from a wrapped and chained object.
      _.prototype.value = function() {
        return this._wrapped;
      };
    
      // Provide unwrapping proxy for some methods used in engine operations
      // such as arithmetic and JSON stringification.
      _.prototype.valueOf = _.prototype.toJSON = _.prototype.value;
    
      _.prototype.toString = function() {
        return String(this._wrapped);
      };
    
      // AMD registration happens at the end for compatibility with AMD loaders
      // that may not enforce next-turn semantics on modules. Even though general
      // practice for AMD registration is to be anonymous, underscore registers
      // as a named module because, like jQuery, it is a base library that is
      // popular enough to be bundled in a third party lib, but not be part of
      // an AMD load request. Those cases could generate an error when an
      // anonymous define() is called outside of a loader request.
    
      return _;
    
    });
    
    //     Backbone.js 1.1.2
    
    //     (c) 2010-2014 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
    //     Backbone may be freely distributed under the MIT license.
    //     For all details and documentation:
    //     http://backbonejs.org
    define('lib/backbone',function() {
      var _ = require('lib/underscore'),
        $ = require('lib/jquery'),
        root = window,
        Backbone = {};
      // Export global even in AMD case in case this script is loaded with
      // others that may still expect a global Backbone.
      // Initial Setup
      // -------------
    
      // Save the previous value of the `Backbone` variable, so that it can be
      // restored later on, if `noConflict` is used.
      var previousBackbone = root.Backbone;
    
      // Create local references to array methods we'll want to use later.
      var array = [];
      var push = array.push;
      var slice = array.slice;
      var splice = array.splice;
    
      // Current version of the library. Keep in sync with `package.json`.
      Backbone.VERSION = '1.1.2';
    
      // For Backbone's purposes, jQuery, Zepto, Ender, or My Library (kidding) owns
      // the `$` variable.
      Backbone.$ = $;
    
      // Runs Backbone.js in *noConflict* mode, returning the `Backbone` variable
      // to its previous owner. Returns a reference to this Backbone object.
      Backbone.noConflict = function() {
        root.Backbone = previousBackbone;
        return this;
      };
    
      // Turn on `emulateHTTP` to support legacy HTTP servers. Setting this option
      // will fake `"PATCH"`, `"PUT"` and `"DELETE"` requests via the `_method` parameter and
      // set a `X-Http-Method-Override` header.
      Backbone.emulateHTTP = false;
    
      // Turn on `emulateJSON` to support legacy servers that can't deal with direct
      // `application/json` requests ... will encode the body as
      // `application/x-www-form-urlencoded` instead and will send the model in a
      // form param named `model`.
      Backbone.emulateJSON = false;
    
      // Backbone.Events
      // ---------------
    
      // A module that can be mixed in to *any object* in order to provide it with
      // custom events. You may bind with `on` or remove with `off` callback
      // functions to an event; `trigger`-ing an event fires all callbacks in
      // succession.
      //
      //     var object = {};
      //     _.extend(object, Backbone.Events);
      //     object.on('expand', function(){ alert('expanded'); });
      //     object.trigger('expand');
      //
      var Events = Backbone.Events = {
    
        // Bind an event to a `callback` function. Passing `"all"` will bind
        // the callback to all events fired.
        on: function(name, callback, context) {
          if (!eventsApi(this, 'on', name, [callback, context]) || !callback) return this;
          this._events || (this._events = {});
          var events = this._events[name] || (this._events[name] = []);
          events.push({
            callback: callback,
            context: context,
            ctx: context || this
          });
          return this;
        },
    
        // Bind an event to only be triggered a single time. After the first time
        // the callback is invoked, it will be removed.
        once: function(name, callback, context) {
          if (!eventsApi(this, 'once', name, [callback, context]) || !callback) return this;
          var self = this;
          var once = _.once(function() {
            self.off(name, once);
            callback.apply(this, arguments);
          });
          once._callback = callback;
          return this.on(name, once, context);
        },
    
        // Remove one or many callbacks. If `context` is null, removes all
        // callbacks with that function. If `callback` is null, removes all
        // callbacks for the event. If `name` is null, removes all bound
        // callbacks for all events.
        off: function(name, callback, context) {
          var retain, ev, events, names, i, l, j, k;
          if (!this._events || !eventsApi(this, 'off', name, [callback, context])) return this;
          if (!name && !callback && !context) {
            this._events = void 0;
            return this;
          }
          names = name ? [name] : _.keys(this._events);
          for (i = 0, l = names.length; i < l; i++) {
            name = names[i];
            if (events = this._events[name]) {
              this._events[name] = retain = [];
              if (callback || context) {
                for (j = 0, k = events.length; j < k; j++) {
                  ev = events[j];
                  if ((callback && callback !== ev.callback && callback !== ev.callback._callback) ||
                    (context && context !== ev.context)) {
                    retain.push(ev);
                  }
                }
              }
              if (!retain.length) delete this._events[name];
            }
          }
    
          return this;
        },
    
        // Trigger one or many events, firing all bound callbacks. Callbacks are
        // passed the same arguments as `trigger` is, apart from the event name
        // (unless you're listening on `"all"`, which will cause your callback to
        // receive the true name of the event as the first argument).
        trigger: function(name) {
          if (!this._events) return this;
          var args = slice.call(arguments, 1);
          if (!eventsApi(this, 'trigger', name, args)) return this;
          var events = this._events[name];
          var allEvents = this._events.all;
          if (events) triggerEvents(events, args);
          if (allEvents) triggerEvents(allEvents, arguments);
          return this;
        },
    
        // Tell this object to stop listening to either specific events ... or
        // to every object it's currently listening to.
        stopListening: function(obj, name, callback) {
          var listeningTo = this._listeningTo;
          if (!listeningTo) return this;
          var remove = !name && !callback;
          if (!callback && typeof name === 'object') callback = this;
          if (obj)(listeningTo = {})[obj._listenId] = obj;
          for (var id in listeningTo) {
            obj = listeningTo[id];
            obj.off(name, callback, this);
            if (remove || _.isEmpty(obj._events)) delete this._listeningTo[id];
          }
          return this;
        }
    
      };
    
      // Regular expression used to split event strings.
      var eventSplitter = /\s+/;
    
      // Implement fancy features of the Events API such as multiple event
      // names `"change blur"` and jQuery-style event maps `{change: action}`
      // in terms of the existing API.
      var eventsApi = function(obj, action, name, rest) {
        if (!name) return true;
    
        // Handle event maps.
        if (typeof name === 'object') {
          for (var key in name) {
            obj[action].apply(obj, [key, name[key]].concat(rest));
          }
          return false;
        }
    
        // Handle space separated event names.
        if (eventSplitter.test(name)) {
          var names = name.split(eventSplitter);
          for (var i = 0, l = names.length; i < l; i++) {
            obj[action].apply(obj, [names[i]].concat(rest));
          }
          return false;
        }
    
        return true;
      };
    
      // A difficult-to-believe, but optimized internal dispatch function for
      // triggering events. Tries to keep the usual cases speedy (most internal
      // Backbone events have 3 arguments).
      var triggerEvents = function(events, args) {
        var ev, i = -1,
          l = events.length,
          a1 = args[0],
          a2 = args[1],
          a3 = args[2];
        switch (args.length) {
          case 0:
            while (++i < l)(ev = events[i]).callback.call(ev.ctx);
            return;
          case 1:
            while (++i < l)(ev = events[i]).callback.call(ev.ctx, a1);
            return;
          case 2:
            while (++i < l)(ev = events[i]).callback.call(ev.ctx, a1, a2);
            return;
          case 3:
            while (++i < l)(ev = events[i]).callback.call(ev.ctx, a1, a2, a3);
            return;
          default:
            while (++i < l)(ev = events[i]).callback.apply(ev.ctx, args);
            return;
        }
      };
    
      var listenMethods = {
        listenTo: 'on',
        listenToOnce: 'once'
      };
    
      // Inversion-of-control versions of `on` and `once`. Tell *this* object to
      // listen to an event in another object ... keeping track of what it's
      // listening to.
      _.each(listenMethods, function(implementation, method) {
        Events[method] = function(obj, name, callback) {
          var listeningTo = this._listeningTo || (this._listeningTo = {});
          var id = obj._listenId || (obj._listenId = _.uniqueId('l'));
          listeningTo[id] = obj;
          if (!callback && typeof name === 'object') callback = this;
          obj[implementation](name, callback, this);
          return this;
        };
      });
    
      // Aliases for backwards compatibility.
      Events.bind = Events.on;
      Events.unbind = Events.off;
    
      // Allow the `Backbone` object to serve as a global event bus, for folks who
      // want global "pubsub" in a convenient place.
      _.extend(Backbone, Events);
    
      // Backbone.Model
      // --------------
    
      // Backbone **Models** are the basic data object in the framework --
      // frequently representing a row in a table in a database on your server.
      // A discrete chunk of data and a bunch of useful, related methods for
      // performing computations and transformations on that data.
    
      // Create a new model with the specified attributes. A client id (`cid`)
      // is automatically generated and assigned for you.
      var Model = Backbone.Model = function(attributes, options) {
        var attrs = attributes || {};
        options || (options = {});
        this.cid = _.uniqueId('c');
        this.attributes = {};
        if (options.collection) this.collection = options.collection;
        if (options.parse) attrs = this.parse(attrs, options) || {};
        attrs = _.defaults({}, attrs, _.result(this, 'defaults'));
        this.set(attrs, options);
        this.changed = {};
        this.initialize.apply(this, arguments);
      };
    
      // Attach all inheritable methods to the Model prototype.
      _.extend(Model.prototype, Events, {
    
        // A hash of attributes whose current and previous value differ.
        changed: null,
    
        // The value returned during the last failed validation.
        validationError: null,
    
        // The default name for the JSON `id` attribute is `"id"`. MongoDB and
        // CouchDB users may want to set this to `"_id"`.
        idAttribute: 'id',
    
        // Initialize is an empty function by default. Override it with your own
        // initialization logic.
        initialize: function() {},
    
        // Return a copy of the model's `attributes` object.
        toJSON: function(options) {
          return _.clone(this.attributes);
        },
    
        // Proxy `Backbone.sync` by default -- but override this if you need
        // custom syncing semantics for *this* particular model.
        sync: function() {
          return Backbone.sync.apply(this, arguments);
        },
    
        // Get the value of an attribute.
        get: function(attr) {
          return this.attributes[attr];
        },
    
        // Get the HTML-escaped value of an attribute.
        escape: function(attr) {
          return _.escape(this.get(attr));
        },
    
        // Returns `true` if the attribute contains a value that is not null
        // or undefined.
        has: function(attr) {
          return this.get(attr) != null;
        },
    
        // Set a hash of model attributes on the object, firing `"change"`. This is
        // the core primitive operation of a model, updating the data and notifying
        // anyone who needs to know about the change in state. The heart of the beast.
        set: function(key, val, options) {
          var attr, attrs, unset, changes, silent, changing, prev, current;
          if (key == null) return this;
    
          // Handle both `"key", value` and `{key: value}` -style arguments.
          if (typeof key === 'object') {
            attrs = key;
            options = val;
          } else {
            (attrs = {})[key] = val;
          }
    
          options || (options = {});
    
          // Run validation.
          if (!this._validate(attrs, options)) return false;
    
          // Extract attributes and options.
          unset = options.unset;
          silent = options.silent;
          changes = [];
          changing = this._changing;
          this._changing = true;
    
          if (!changing) {
            this._previousAttributes = _.clone(this.attributes);
            this.changed = {};
          }
          current = this.attributes, prev = this._previousAttributes;
    
          // Check for changes of `id`.
          if (this.idAttribute in attrs) this.id = attrs[this.idAttribute];
    
          // For each `set` attribute, update or delete the current value.
          for (attr in attrs) {
            val = attrs[attr];
            if (!_.isEqual(current[attr], val)) changes.push(attr);
            if (!_.isEqual(prev[attr], val)) {
              this.changed[attr] = val;
            } else {
              delete this.changed[attr];
            }
            unset ? delete current[attr] : current[attr] = val;
          }
    
          // Trigger all relevant attribute changes.
          if (!silent) {
            if (changes.length) this._pending = options;
            for (var i = 0, l = changes.length; i < l; i++) {
              this.trigger('change:' + changes[i], this, current[changes[i]], options);
            }
          }
    
          // You might be wondering why there's a `while` loop here. Changes can
          // be recursively nested within `"change"` events.
          if (changing) return this;
          if (!silent) {
            while (this._pending) {
              options = this._pending;
              this._pending = false;
              this.trigger('change', this, options);
            }
          }
          this._pending = false;
          this._changing = false;
          return this;
        },
    
        // Remove an attribute from the model, firing `"change"`. `unset` is a noop
        // if the attribute doesn't exist.
        unset: function(attr, options) {
          return this.set(attr, void 0, _.extend({}, options, {
            unset: true
          }));
        },
    
        // Clear all attributes on the model, firing `"change"`.
        clear: function(options) {
          var attrs = {};
          for (var key in this.attributes) attrs[key] = void 0;
          return this.set(attrs, _.extend({}, options, {
            unset: true
          }));
        },
    
        // Determine if the model has changed since the last `"change"` event.
        // If you specify an attribute name, determine if that attribute has changed.
        hasChanged: function(attr) {
          if (attr == null) return !_.isEmpty(this.changed);
          return _.has(this.changed, attr);
        },
    
        // Return an object containing all the attributes that have changed, or
        // false if there are no changed attributes. Useful for determining what
        // parts of a view need to be updated and/or what attributes need to be
        // persisted to the server. Unset attributes will be set to undefined.
        // You can also pass an attributes object to diff against the model,
        // determining if there *would be* a change.
        changedAttributes: function(diff) {
          if (!diff) return this.hasChanged() ? _.clone(this.changed) : false;
          var val, changed = false;
          var old = this._changing ? this._previousAttributes : this.attributes;
          for (var attr in diff) {
            if (_.isEqual(old[attr], (val = diff[attr]))) continue;
            (changed || (changed = {}))[attr] = val;
          }
          return changed;
        },
    
        // Get the previous value of an attribute, recorded at the time the last
        // `"change"` event was fired.
        previous: function(attr) {
          if (attr == null || !this._previousAttributes) return null;
          return this._previousAttributes[attr];
        },
    
        // Get all of the attributes of the model at the time of the previous
        // `"change"` event.
        previousAttributes: function() {
          return _.clone(this._previousAttributes);
        },
    
        // Fetch the model from the server. If the server's representation of the
        // model differs from its current attributes, they will be overridden,
        // triggering a `"change"` event.
        fetch: function(options) {
          options = options ? _.clone(options) : {};
          if (options.parse === void 0) options.parse = true;
          var model = this;
          var success = options.success;
          options.success = function(resp) {
            if (!model.set(model.parse(resp, options), options)) return false;
            if (success) success(model, resp, options);
            model.trigger('sync', model, resp, options);
          };
          wrapError(this, options);
          return this.sync('read', this, options);
        },
    
        // Set a hash of model attributes, and sync the model to the server.
        // If the server returns an attributes hash that differs, the model's
        // state will be `set` again.
        save: function(key, val, options) {
          var attrs, method, xhr, attributes = this.attributes;
    
          // Handle both `"key", value` and `{key: value}` -style arguments.
          if (key == null || typeof key === 'object') {
            attrs = key;
            options = val;
          } else {
            (attrs = {})[key] = val;
          }
    
          options = _.extend({
            validate: true
          }, options);
    
          // If we're not waiting and attributes exist, save acts as
          // `set(attr).save(null, opts)` with validation. Otherwise, check if
          // the model will be valid when the attributes, if any, are set.
          if (attrs && !options.wait) {
            if (!this.set(attrs, options)) return false;
          } else {
            if (!this._validate(attrs, options)) return false;
          }
    
          // Set temporary attributes if `{wait: true}`.
          if (attrs && options.wait) {
            this.attributes = _.extend({}, attributes, attrs);
          }
    
          // After a successful server-side save, the client is (optionally)
          // updated with the server-side state.
          if (options.parse === void 0) options.parse = true;
          var model = this;
          var success = options.success;
          options.success = function(resp) {
            // Ensure attributes are restored during synchronous saves.
            model.attributes = attributes;
            var serverAttrs = model.parse(resp, options);
            if (options.wait) serverAttrs = _.extend(attrs || {}, serverAttrs);
            if (_.isObject(serverAttrs) && !model.set(serverAttrs, options)) {
              return false;
            }
            if (success) success(model, resp, options);
            model.trigger('sync', model, resp, options);
          };
          wrapError(this, options);
    
          method = this.isNew() ? 'create' : (options.patch ? 'patch' : 'update');
          if (method === 'patch') options.attrs = attrs;
          xhr = this.sync(method, this, options);
    
          // Restore attributes.
          if (attrs && options.wait) this.attributes = attributes;
    
          return xhr;
        },
    
        // Destroy this model on the server if it was already persisted.
        // Optimistically removes the model from its collection, if it has one.
        // If `wait: true` is passed, waits for the server to respond before removal.
        destroy: function(options) {
          options = options ? _.clone(options) : {};
          var model = this;
          var success = options.success;
    
          var destroy = function() {
            model.trigger('destroy', model, model.collection, options);
          };
    
          options.success = function(resp) {
            if (options.wait || model.isNew()) destroy();
            if (success) success(model, resp, options);
            if (!model.isNew()) model.trigger('sync', model, resp, options);
          };
    
          if (this.isNew()) {
            options.success();
            return false;
          }
          wrapError(this, options);
    
          var xhr = this.sync('delete', this, options);
          if (!options.wait) destroy();
          return xhr;
        },
    
        // Default URL for the model's representation on the server -- if you're
        // using Backbone's restful methods, override this to change the endpoint
        // that will be called.
        url: function() {
          var base =
            _.result(this, 'urlRoot') ||
            _.result(this.collection, 'url') ||
            urlError();
          if (this.isNew()) return base;
          return base.replace(/([^\/])$/, '$1/') + encodeURIComponent(this.id);
        },
    
        // **parse** converts a response into the hash of attributes to be `set` on
        // the model. The default implementation is just to pass the response along.
        parse: function(resp, options) {
          return resp;
        },
    
        // Create a new model with identical attributes to this one.
        clone: function() {
          return new this.constructor(this.attributes);
        },
    
        // A model is new if it has never been saved to the server, and lacks an id.
        isNew: function() {
          return !this.has(this.idAttribute);
        },
    
        // Check if the model is currently in a valid state.
        isValid: function(options) {
          return this._validate({}, _.extend(options || {}, {
            validate: true
          }));
        },
    
        // Run validation against the next complete set of model attributes,
        // returning `true` if all is well. Otherwise, fire an `"invalid"` event.
        _validate: function(attrs, options) {
          if (!options.validate || !this.validate) return true;
          attrs = _.extend({}, this.attributes, attrs);
          var error = this.validationError = this.validate(attrs, options) || null;
          if (!error) return true;
          this.trigger('invalid', this, error, _.extend(options, {
            validationError: error
          }));
          return false;
        }
    
      });
    
      // Underscore methods that we want to implement on the Model.
      var modelMethods = ['keys', 'values', 'pairs', 'invert', 'pick', 'omit'];
    
      // Mix in each Underscore method as a proxy to `Model#attributes`.
      _.each(modelMethods, function(method) {
        Model.prototype[method] = function() {
          var args = slice.call(arguments);
          args.unshift(this.attributes);
          return _[method].apply(_, args);
        };
      });
    
      // Backbone.Collection
      // -------------------
    
      // If models tend to represent a single row of data, a Backbone Collection is
      // more analagous to a table full of data ... or a small slice or page of that
      // table, or a collection of rows that belong together for a particular reason
      // -- all of the messages in this particular folder, all of the documents
      // belonging to this particular author, and so on. Collections maintain
      // indexes of their models, both in order, and for lookup by `id`.
    
      // Create a new **Collection**, perhaps to contain a specific type of `model`.
      // If a `comparator` is specified, the Collection will maintain
      // its models in sort order, as they're added and removed.
      var Collection = Backbone.Collection = function(models, options) {
        options || (options = {});
        if (options.model) this.model = options.model;
        if (options.comparator !== void 0) this.comparator = options.comparator;
        this._reset();
        this.initialize.apply(this, arguments);
        if (models) this.reset(models, _.extend({
          silent: true
        }, options));
      };
    
      // Default options for `Collection#set`.
      var setOptions = {
        add: true,
        remove: true,
        merge: true
      };
      var addOptions = {
        add: true,
        remove: false
      };
    
      // Define the Collection's inheritable methods.
      _.extend(Collection.prototype, Events, {
    
        // The default model for a collection is just a **Backbone.Model**.
        // This should be overridden in most cases.
        model: Model,
    
        // Initialize is an empty function by default. Override it with your own
        // initialization logic.
        initialize: function() {},
    
        // The JSON representation of a Collection is an array of the
        // models' attributes.
        toJSON: function(options) {
          return this.map(function(model) {
            return model.toJSON(options);
          });
        },
    
        // Proxy `Backbone.sync` by default.
        sync: function() {
          return Backbone.sync.apply(this, arguments);
        },
    
        // Add a model, or list of models to the set.
        add: function(models, options) {
          return this.set(models, _.extend({
            merge: false
          }, options, addOptions));
        },
    
        // Remove a model, or a list of models from the set.
        remove: function(models, options) {
          var singular = !_.isArray(models);
          models = singular ? [models] : _.clone(models);
          options || (options = {});
          var i, l, index, model;
          for (i = 0, l = models.length; i < l; i++) {
            model = models[i] = this.get(models[i]);
            if (!model) continue;
            delete this._byId[model.id];
            delete this._byId[model.cid];
            index = this.indexOf(model);
            this.models.splice(index, 1);
            this.length--;
            if (!options.silent) {
              options.index = index;
              model.trigger('remove', model, this, options);
            }
            this._removeReference(model, options);
          }
          return singular ? models[0] : models;
        },
    
        // Update a collection by `set`-ing a new list of models, adding new ones,
        // removing models that are no longer present, and merging models that
        // already exist in the collection, as necessary. Similar to **Model#set**,
        // the core operation for updating the data contained by the collection.
        set: function(models, options) {
          options = _.defaults({}, options, setOptions);
          if (options.parse) models = this.parse(models, options);
          var singular = !_.isArray(models);
          models = singular ? (models ? [models] : []) : _.clone(models);
          var i, l, id, model, attrs, existing, sort;
          var at = options.at;
          var targetModel = this.model;
          var sortable = this.comparator && (at == null) && options.sort !== false;
          var sortAttr = _.isString(this.comparator) ? this.comparator : null;
          var toAdd = [],
            toRemove = [],
            modelMap = {};
          var add = options.add,
            merge = options.merge,
            remove = options.remove;
          var order = !sortable && add && remove ? [] : false;
    
          // Turn bare objects into model references, and prevent invalid models
          // from being added.
          for (i = 0, l = models.length; i < l; i++) {
            attrs = models[i] || {};
            if (attrs instanceof Model) {
              id = model = attrs;
            } else {
              id = attrs[targetModel.prototype.idAttribute || 'id'];
            }
    
            // If a duplicate is found, prevent it from being added and
            // optionally merge it into the existing model.
            if (existing = this.get(id)) {
              if (remove) modelMap[existing.cid] = true;
              if (merge) {
                attrs = attrs === model ? model.attributes : attrs;
                if (options.parse) attrs = existing.parse(attrs, options);
                existing.set(attrs, options);
                if (sortable && !sort && existing.hasChanged(sortAttr)) sort = true;
              }
              models[i] = existing;
    
              // If this is a new, valid model, push it to the `toAdd` list.
            } else if (add) {
              model = models[i] = this._prepareModel(attrs, options);
              if (!model) continue;
              toAdd.push(model);
              this._addReference(model, options);
            }
    
            // Do not add multiple models with the same `id`.
            model = existing || model;
            if (order && (model.isNew() || !modelMap[model.id])) order.push(model);
            modelMap[model.id] = true;
          }
    
          // Remove nonexistent models if appropriate.
          if (remove) {
            for (i = 0, l = this.length; i < l; ++i) {
              if (!modelMap[(model = this.models[i]).cid]) toRemove.push(model);
            }
            if (toRemove.length) this.remove(toRemove, options);
          }
    
          // See if sorting is needed, update `length` and splice in new models.
          if (toAdd.length || (order && order.length)) {
            if (sortable) sort = true;
            this.length += toAdd.length;
            if (at != null) {
              for (i = 0, l = toAdd.length; i < l; i++) {
                this.models.splice(at + i, 0, toAdd[i]);
              }
            } else {
              if (order) this.models.length = 0;
              var orderedModels = order || toAdd;
              for (i = 0, l = orderedModels.length; i < l; i++) {
                this.models.push(orderedModels[i]);
              }
            }
          }
    
          // Silently sort the collection if appropriate.
          if (sort) this.sort({
            silent: true
          });
    
          // Unless silenced, it's time to fire all appropriate add/sort events.
          if (!options.silent) {
            for (i = 0, l = toAdd.length; i < l; i++) {
              (model = toAdd[i]).trigger('add', model, this, options);
            }
            if (sort || (order && order.length)) this.trigger('sort', this, options);
          }
    
          // Return the added (or merged) model (or models).
          return singular ? models[0] : models;
        },
    
        // When you have more items than you want to add or remove individually,
        // you can reset the entire set with a new list of models, without firing
        // any granular `add` or `remove` events. Fires `reset` when finished.
        // Useful for bulk operations and optimizations.
        reset: function(models, options) {
          options || (options = {});
          for (var i = 0, l = this.models.length; i < l; i++) {
            this._removeReference(this.models[i], options);
          }
          options.previousModels = this.models;
          this._reset();
          models = this.add(models, _.extend({
            silent: true
          }, options));
          if (!options.silent) this.trigger('reset', this, options);
          return models;
        },
    
        // Add a model to the end of the collection.
        push: function(model, options) {
          return this.add(model, _.extend({
            at: this.length
          }, options));
        },
    
        // Remove a model from the end of the collection.
        pop: function(options) {
          var model = this.at(this.length - 1);
          this.remove(model, options);
          return model;
        },
    
        // Add a model to the beginning of the collection.
        unshift: function(model, options) {
          return this.add(model, _.extend({
            at: 0
          }, options));
        },
    
        // Remove a model from the beginning of the collection.
        shift: function(options) {
          var model = this.at(0);
          this.remove(model, options);
          return model;
        },
    
        // Slice out a sub-array of models from the collection.
        slice: function() {
          return slice.apply(this.models, arguments);
        },
    
        // Get a model from the set by id.
        get: function(obj) {
          if (obj == null) return void 0;
          return this._byId[obj] || this._byId[obj.id] || this._byId[obj.cid];
        },
    
        // Get the model at the given index.
        at: function(index) {
          return this.models[index];
        },
    
        // Return models with matching attributes. Useful for simple cases of
        // `filter`.
        where: function(attrs, first) {
          if (_.isEmpty(attrs)) return first ? void 0 : [];
          return this[first ? 'find' : 'filter'](function(model) {
            for (var key in attrs) {
              if (attrs[key] !== model.get(key)) return false;
            }
            return true;
          });
        },
    
        // Return the first model with matching attributes. Useful for simple cases
        // of `find`.
        findWhere: function(attrs) {
          return this.where(attrs, true);
        },
    
        // Force the collection to re-sort itself. You don't need to call this under
        // normal circumstances, as the set will maintain sort order as each item
        // is added.
        sort: function(options) {
          if (!this.comparator) throw new Error('Cannot sort a set without a comparator');
          options || (options = {});
    
          // Run sort based on type of `comparator`.
          if (_.isString(this.comparator) || this.comparator.length === 1) {
            this.models = this.sortBy(this.comparator, this);
          } else {
            this.models.sort(_.bind(this.comparator, this));
          }
    
          if (!options.silent) this.trigger('sort', this, options);
          return this;
        },
    
        // Pluck an attribute from each model in the collection.
        pluck: function(attr) {
          return _.invoke(this.models, 'get', attr);
        },
    
        // Fetch the default set of models for this collection, resetting the
        // collection when they arrive. If `reset: true` is passed, the response
        // data will be passed through the `reset` method instead of `set`.
        fetch: function(options) {
          options = options ? _.clone(options) : {};
          if (options.parse === void 0) options.parse = true;
          var success = options.success;
          var collection = this;
          options.success = function(resp) {
            var method = options.reset ? 'reset' : 'set';
            collection[method](resp, options);
            if (success) success(collection, resp, options);
            collection.trigger('sync', collection, resp, options);
          };
          wrapError(this, options);
          return this.sync('read', this, options);
        },
    
        // Create a new instance of a model in this collection. Add the model to the
        // collection immediately, unless `wait: true` is passed, in which case we
        // wait for the server to agree.
        create: function(model, options) {
          options = options ? _.clone(options) : {};
          if (!(model = this._prepareModel(model, options))) return false;
          if (!options.wait) this.add(model, options);
          var collection = this;
          var success = options.success;
          options.success = function(model, resp) {
            if (options.wait) collection.add(model, options);
            if (success) success(model, resp, options);
          };
          model.save(null, options);
          return model;
        },
    
        // **parse** converts a response into a list of models to be added to the
        // collection. The default implementation is just to pass it through.
        parse: function(resp, options) {
          return resp;
        },
    
        // Create a new collection with an identical list of models as this one.
        clone: function() {
          return new this.constructor(this.models);
        },
    
        // Private method to reset all internal state. Called when the collection
        // is first initialized or reset.
        _reset: function() {
          this.length = 0;
          this.models = [];
          this._byId = {};
        },
    
        // Prepare a hash of attributes (or other model) to be added to this
        // collection.
        _prepareModel: function(attrs, options) {
          if (attrs instanceof Model) return attrs;
          options = options ? _.clone(options) : {};
          options.collection = this;
          var model = new this.model(attrs, options);
          if (!model.validationError) return model;
          this.trigger('invalid', this, model.validationError, options);
          return false;
        },
    
        // Internal method to create a model's ties to a collection.
        _addReference: function(model, options) {
          this._byId[model.cid] = model;
          if (model.id != null) this._byId[model.id] = model;
          if (!model.collection) model.collection = this;
          model.on('all', this._onModelEvent, this);
        },
    
        // Internal method to sever a model's ties to a collection.
        _removeReference: function(model, options) {
          if (this === model.collection) delete model.collection;
          model.off('all', this._onModelEvent, this);
        },
    
        // Internal method called every time a model in the set fires an event.
        // Sets need to update their indexes when models change ids. All other
        // events simply proxy through. "add" and "remove" events that originate
        // in other collections are ignored.
        _onModelEvent: function(event, model, collection, options) {
          if ((event === 'add' || event === 'remove') && collection !== this) return;
          if (event === 'destroy') this.remove(model, options);
          if (model && event === 'change:' + model.idAttribute) {
            delete this._byId[model.previous(model.idAttribute)];
            if (model.id != null) this._byId[model.id] = model;
          }
          this.trigger.apply(this, arguments);
        }
    
      });
    
      // Underscore methods that we want to implement on the Collection.
      // 90% of the core usefulness of Backbone Collections is actually implemented
      // right here:
      var methods = ['forEach', 'each', 'map', 'collect', 'reduce', 'foldl',
        'inject', 'reduceRight', 'foldr', 'find', 'detect', 'filter', 'select',
        'reject', 'every', 'all', 'some', 'any', 'include', 'contains', 'invoke',
        'max', 'min', 'toArray', 'size', 'first', 'head', 'take', 'initial', 'rest',
        'tail', 'drop', 'last', 'without', 'difference', 'indexOf', 'shuffle',
        'lastIndexOf', 'isEmpty', 'chain', 'sample'
      ];
    
      // Mix in each Underscore method as a proxy to `Collection#models`.
      _.each(methods, function(method) {
        Collection.prototype[method] = function() {
          var args = slice.call(arguments);
          args.unshift(this.models);
          return _[method].apply(_, args);
        };
      });
    
      // Underscore methods that take a property name as an argument.
      var attributeMethods = ['groupBy', 'countBy', 'sortBy', 'indexBy'];
    
      // Use attributes instead of properties.
      _.each(attributeMethods, function(method) {
        Collection.prototype[method] = function(value, context) {
          var iterator = _.isFunction(value) ? value : function(model) {
            return model.get(value);
          };
          return _[method](this.models, iterator, context);
        };
      });
    
      // Backbone.View
      // -------------
    
      // Backbone Views are almost more convention than they are actual code. A View
      // is simply a JavaScript object that represents a logical chunk of UI in the
      // DOM. This might be a single item, an entire list, a sidebar or panel, or
      // even the surrounding frame which wraps your whole app. Defining a chunk of
      // UI as a **View** allows you to define your DOM events declaratively, without
      // having to worry about render order ... and makes it easy for the view to
      // react to specific changes in the state of your models.
    
      // Creating a Backbone.View creates its initial element outside of the DOM,
      // if an existing element is not provided...
      var View = Backbone.View = function(options) {
        this.cid = _.uniqueId('view');
        options || (options = {});
        _.extend(this, _.pick(options, viewOptions));
        this._ensureElement();
        this.initialize.apply(this, arguments);
        this.delegateEvents();
      };
    
      // Cached regex to split keys for `delegate`.
      var delegateEventSplitter = /^(\S+)\s*(.*)$/;
    
      // List of view options to be merged as properties.
      var viewOptions = ['model', 'collection', 'el', 'id', 'attributes', 'className', 'tagName', 'events'];
    
      // Set up all inheritable **Backbone.View** properties and methods.
      _.extend(View.prototype, Events, {
    
        // The default `tagName` of a View's element is `"div"`.
        tagName: 'div',
    
        // jQuery delegate for element lookup, scoped to DOM elements within the
        // current view. This should be preferred to global lookups where possible.
        $: function(selector) {
          return this.$el.find(selector);
        },
    
        // Initialize is an empty function by default. Override it with your own
        // initialization logic.
        initialize: function() {},
    
        // **render** is the core function that your view should override, in order
        // to populate its element (`this.el`), with the appropriate HTML. The
        // convention is for **render** to always return `this`.
        render: function() {
          return this;
        },
    
        // Remove this view by taking the element out of the DOM, and removing any
        // applicable Backbone.Events listeners.
        remove: function() {
          this.$el.remove();
          this.stopListening();
          return this;
        },
    
        // Change the view's element (`this.el` property), including event
        // re-delegation.
        setElement: function(element, delegate) {
          if (this.$el) this.undelegateEvents();
          this.$el = element instanceof Backbone.$ ? element : Backbone.$(element);
          this.el = this.$el[0];
          if (delegate !== false) this.delegateEvents();
          return this;
        },
    
        // Set callbacks, where `this.events` is a hash of
        //
        // *{"event selector": "callback"}*
        //
        //     {
        //       'mousedown .title':  'edit',
        //       'click .button':     'save',
        //       'click .open':       function(e) { ... }
        //     }
        //
        // pairs. Callbacks will be bound to the view, with `this` set properly.
        // Uses event delegation for efficiency.
        // Omitting the selector binds the event to `this.el`.
        // This only works for delegate-able events: not `focus`, `blur`, and
        // not `change`, `submit`, and `reset` in Internet Explorer.
        delegateEvents: function(events) {
          if (!(events || (events = _.result(this, 'events')))) return this;
          this.undelegateEvents();
          for (var key in events) {
            var method = events[key];
            if (!_.isFunction(method)) method = this[events[key]];
            if (!method) continue;
    
            var match = key.match(delegateEventSplitter);
            var eventName = match[1],
              selector = match[2];
            method = _.bind(method, this);
            eventName += '.delegateEvents' + this.cid;
            if (selector === '') {
              this.$el.on(eventName, method);
            } else {
              this.$el.on(eventName, selector, method);
            }
          }
          return this;
        },
    
        // Clears all callbacks previously bound to the view with `delegateEvents`.
        // You usually don't need to use this, but may wish to if you have multiple
        // Backbone views attached to the same DOM element.
        undelegateEvents: function() {
          this.$el.off('.delegateEvents' + this.cid);
          return this;
        },
    
        // Ensure that the View has a DOM element to render into.
        // If `this.el` is a string, pass it through `$()`, take the first
        // matching element, and re-assign it to `el`. Otherwise, create
        // an element from the `id`, `className` and `tagName` properties.
        _ensureElement: function() {
          if (!this.el) {
            var attrs = _.extend({}, _.result(this, 'attributes'));
            if (this.id) attrs.id = _.result(this, 'id');
            if (this.className) attrs['class'] = _.result(this, 'className');
            var $el = Backbone.$('<' + _.result(this, 'tagName') + '>').attr(attrs);
            this.setElement($el, false);
          } else {
            this.setElement(_.result(this, 'el'), false);
          }
        }
    
      });
    
      // Backbone.sync
      // -------------
    
      // Override this function to change the manner in which Backbone persists
      // models to the server. You will be passed the type of request, and the
      // model in question. By default, makes a RESTful Ajax request
      // to the model's `url()`. Some possible customizations could be:
      //
      // * Use `setTimeout` to batch rapid-fire updates into a single request.
      // * Send up the models as XML instead of JSON.
      // * Persist models via WebSockets instead of Ajax.
      //
      // Turn on `Backbone.emulateHTTP` in order to send `PUT` and `DELETE` requests
      // as `POST`, with a `_method` parameter containing the true HTTP method,
      // as well as all requests with the body as `application/x-www-form-urlencoded`
      // instead of `application/json` with the model in a param named `model`.
      // Useful when interfacing with server-side languages like **PHP** that make
      // it difficult to read the body of `PUT` requests.
      Backbone.sync = function(method, model, options) {
        var type = methodMap[method];
    
        // Default options, unless specified.
        _.defaults(options || (options = {}), {
          emulateHTTP: Backbone.emulateHTTP,
          emulateJSON: Backbone.emulateJSON
        });
    
        // Default JSON-request options.
        var params = {
          type: type,
          dataType: 'json'
        };
    
        // Ensure that we have a URL.
        if (!options.url) {
          params.url = _.result(model, 'url') || urlError();
        }
    
        // Ensure that we have the appropriate request data.
        if (options.data == null && model && (method === 'create' || method === 'update' || method === 'patch')) {
          params.contentType = 'application/json';
          params.data = JSON.stringify(options.attrs || model.toJSON(options));
        }
    
        // For older servers, emulate JSON by encoding the request into an HTML-form.
        if (options.emulateJSON) {
          params.contentType = 'application/x-www-form-urlencoded';
          params.data = params.data ? {
            model: params.data
          } : {};
        }
    
        // For older servers, emulate HTTP by mimicking the HTTP method with `_method`
        // And an `X-HTTP-Method-Override` header.
        if (options.emulateHTTP && (type === 'PUT' || type === 'DELETE' || type === 'PATCH')) {
          params.type = 'POST';
          if (options.emulateJSON) params.data._method = type;
          var beforeSend = options.beforeSend;
          options.beforeSend = function(xhr) {
            xhr.setRequestHeader('X-HTTP-Method-Override', type);
            if (beforeSend) return beforeSend.apply(this, arguments);
          };
        }
    
        // Don't process data on a non-GET request.
        if (params.type !== 'GET' && !options.emulateJSON) {
          params.processData = false;
        }
    
        // If we're sending a `PATCH` request, and we're in an old Internet Explorer
        // that still has ActiveX enabled by default, override jQuery to use that
        // for XHR instead. Remove this line when jQuery supports `PATCH` on IE8.
        if (params.type === 'PATCH' && noXhrPatch) {
          params.xhr = function() {
            return new ActiveXObject("Microsoft.XMLHTTP");
          };
        }
    
        // Make the request, allowing the user to override any Ajax options.
        var xhr = options.xhr = Backbone.ajax(_.extend(params, options));
        model.trigger('request', model, xhr, options);
        return xhr;
      };
    
      var noXhrPatch =
        typeof window !== 'undefined' && !!window.ActiveXObject &&
        !(window.XMLHttpRequest && (new XMLHttpRequest).dispatchEvent);
    
      // Map from CRUD to HTTP for our default `Backbone.sync` implementation.
      var methodMap = {
        'create': 'POST',
        'update': 'PUT',
        'patch': 'PATCH',
        'delete': 'DELETE',
        'read': 'GET'
      };
    
      // Set the default implementation of `Backbone.ajax` to proxy through to `$`.
      // Override this if you'd like to use a different library.
      Backbone.ajax = function() {
        return Backbone.$.ajax.apply(Backbone.$, arguments);
      };
    
      // Backbone.Router
      // ---------------
    
      // Routers map faux-URLs to actions, and fire events when routes are
      // matched. Creating a new one sets its `routes` hash, if not set statically.
      var Router = Backbone.Router = function(options) {
        options || (options = {});
        if (options.routes) this.routes = options.routes;
        this._bindRoutes();
        this.initialize.apply(this, arguments);
      };
    
      // Cached regular expressions for matching named param parts and splatted
      // parts of route strings.
      var optionalParam = /\((.*?)\)/g;
      var namedParam = /(\(\?)?:\w+/g;
      var splatParam = /\*\w+/g;
      var escapeRegExp = /[\-{}\[\]+?.,\\\^$|#\s]/g;
    
      // Set up all inheritable **Backbone.Router** properties and methods.
      _.extend(Router.prototype, Events, {
    
        // Initialize is an empty function by default. Override it with your own
        // initialization logic.
        initialize: function() {},
    
        // Manually bind a single named route to a callback. For example:
        //
        //     this.route('search/:query/p:num', 'search', function(query, num) {
        //       ...
        //     });
        //
        route: function(route, name, callback) {
          if (!_.isRegExp(route)) route = this._routeToRegExp(route);
          if (_.isFunction(name)) {
            callback = name;
            name = '';
          }
          if (!callback) callback = this[name];
          var router = this;
          Backbone.history.route(route, function(fragment) {
            var args = router._extractParameters(route, fragment);
            router.execute(callback, args);
            router.trigger.apply(router, ['route:' + name].concat(args));
            router.trigger('route', name, args);
            Backbone.history.trigger('route', router, name, args);
          });
          return this;
        },
    
        // Execute a route handler with the provided parameters.  This is an
        // excellent place to do pre-route setup or post-route cleanup.
        execute: function(callback, args) {
          if (callback) callback.apply(this, args);
        },
    
        // Simple proxy to `Backbone.history` to save a fragment into the history.
        navigate: function(fragment, options) {
          Backbone.history.navigate(fragment, options);
          return this;
        },
    
        // Bind all defined routes to `Backbone.history`. We have to reverse the
        // order of the routes here to support behavior where the most general
        // routes can be defined at the bottom of the route map.
        _bindRoutes: function() {
          if (!this.routes) return;
          this.routes = _.result(this, 'routes');
          var route, routes = _.keys(this.routes);
          while ((route = routes.pop()) != null) {
            this.route(route, this.routes[route]);
          }
        },
    
        // Convert a route string into a regular expression, suitable for matching
        // against the current location hash.
        _routeToRegExp: function(route) {
          route = route.replace(escapeRegExp, '\\$&')
            .replace(optionalParam, '(?:$1)?')
            .replace(namedParam, function(match, optional) {
              return optional ? match : '([^/?]+)';
            })
            .replace(splatParam, '([^?]*?)');
          return new RegExp('^' + route + '(?:\\?([\\s\\S]*))?$');
        },
    
        // Given a route, and a URL fragment that it matches, return the array of
        // extracted decoded parameters. Empty or unmatched parameters will be
        // treated as `null` to normalize cross-browser behavior.
        _extractParameters: function(route, fragment) {
          var params = route.exec(fragment).slice(1);
          return _.map(params, function(param, i) {
            // Don't decode the search params.
            if (i === params.length - 1) return param || null;
            return param ? decodeURIComponent(param) : null;
          });
        }
    
      });
    
      // Backbone.History
      // ----------------
    
      // Handles cross-browser history management, based on either
      // [pushState](http://diveintohtml5.info/history.html) and real URLs, or
      // [onhashchange](https://developer.mozilla.org/en-US/docs/DOM/window.onhashchange)
      // and URL fragments. If the browser supports neither (old IE, natch),
      // falls back to polling.
      var History = Backbone.History = function() {
        this.handlers = [];
        _.bindAll(this, 'checkUrl');
    
        // Ensure that `History` can be used outside of the browser.
        if (typeof window !== 'undefined') {
          this.location = window.location;
          this.history = window.history;
        }
      };
    
      // Cached regex for stripping a leading hash/slash and trailing space.
      var routeStripper = /^[#\/]|\s+$/g;
    
      // Cached regex for stripping leading and trailing slashes.
      var rootStripper = /^\/+|\/+$/g;
    
      // Cached regex for detecting MSIE.
      var isExplorer = /msie [\w.]+/;
    
      // Cached regex for removing a trailing slash.
      var trailingSlash = /\/$/;
    
      // Cached regex for stripping urls of hash.
      var pathStripper = /#.*$/;
    
      // Has the history handling already been started?
      History.started = false;
    
      // Set up all inheritable **Backbone.History** properties and methods.
      _.extend(History.prototype, Events, {
    
        // The default interval to poll for hash changes, if necessary, is
        // twenty times a second.
        interval: 50,
    
        // Are we at the app root?
        atRoot: function() {
          return this.location.pathname.replace(/[^\/]$/, '$&/') === this.root;
        },
    
        // Gets the true hash value. Cannot use location.hash directly due to bug
        // in Firefox where location.hash will always be decoded.
        getHash: function(window) {
          var match = (window || this).location.href.match(/#(.*)$/);
          return match ? match[1] : '';
        },
    
        // Get the cross-browser normalized URL fragment, either from the URL,
        // the hash, or the override.
        getFragment: function(fragment, forcePushState) {
          if (fragment == null) {
            if (this._hasPushState || !this._wantsHashChange || forcePushState) {
              fragment = decodeURI(this.location.pathname + this.location.search);
              var root = this.root.replace(trailingSlash, '');
              if (!fragment.indexOf(root)) fragment = fragment.slice(root.length);
            } else {
              fragment = this.getHash();
            }
          }
          return fragment.replace(routeStripper, '');
        },
    
        // Start the hash change handling, returning `true` if the current URL matches
        // an existing route, and `false` otherwise.
        start: function(options) {
          if (History.started) throw new Error("Backbone.history has already been started");
          History.started = true;
    
          // Figure out the initial configuration. Do we need an iframe?
          // Is pushState desired ... is it available?
          this.options = _.extend({
            root: '/'
          }, this.options, options);
          this.root = this.options.root;
          this._wantsHashChange = this.options.hashChange !== false;
          this._wantsPushState = !!this.options.pushState;
          this._hasPushState = !!(this.options.pushState && this.history && this.history.pushState);
          var fragment = this.getFragment();
          var docMode = document.documentMode;
          var oldIE = (isExplorer.exec(navigator.userAgent.toLowerCase()) && (!docMode || docMode <= 7));
    
          // Normalize root to always include a leading and trailing slash.
          this.root = ('/' + this.root + '/').replace(rootStripper, '/');
    
          if (oldIE && this._wantsHashChange) {
            var frame = Backbone.$('<iframe src="javascript:0" tabindex="-1">');
            this.iframe = frame.hide().appendTo('body')[0].contentWindow;
            this.navigate(fragment);
          }
    
          // Depending on whether we're using pushState or hashes, and whether
          // 'onhashchange' is supported, determine how we check the URL state.
          if (this._hasPushState) {
            Backbone.$(window).on('popstate', this.checkUrl);
          } else if (this._wantsHashChange && ('onhashchange' in window) && !oldIE) {
            Backbone.$(window).on('hashchange', this.checkUrl);
          } else if (this._wantsHashChange) {
            this._checkUrlInterval = setInterval(this.checkUrl, this.interval);
          }
    
          // Determine if we need to change the base url, for a pushState link
          // opened by a non-pushState browser.
          this.fragment = fragment;
          var loc = this.location;
    
          // Transition from hashChange to pushState or vice versa if both are
          // requested.
          if (this._wantsHashChange && this._wantsPushState) {
    
            // If we've started off with a route from a `pushState`-enabled
            // browser, but we're currently in a browser that doesn't support it...
            if (!this._hasPushState && !this.atRoot()) {
              this.fragment = this.getFragment(null, true);
              this.location.replace(this.root + '#' + this.fragment);
              // Return immediately as browser will do redirect to new url
              return true;
    
              // Or if we've started out with a hash-based route, but we're currently
              // in a browser where it could be `pushState`-based instead...
            } else if (this._hasPushState && this.atRoot() && loc.hash) {
              this.fragment = this.getHash().replace(routeStripper, '');
              this.history.replaceState({}, document.title, this.root + this.fragment);
            }
    
          }
    
          if (!this.options.silent) return this.loadUrl();
        },
    
        // Disable Backbone.history, perhaps temporarily. Not useful in a real app,
        // but possibly useful for unit testing Routers.
        stop: function() {
          Backbone.$(window).off('popstate', this.checkUrl).off('hashchange', this.checkUrl);
          if (this._checkUrlInterval) clearInterval(this._checkUrlInterval);
          History.started = false;
        },
    
        // Add a route to be tested when the fragment changes. Routes added later
        // may override previous routes.
        route: function(route, callback) {
          this.handlers.unshift({
            route: route,
            callback: callback
          });
        },
    
        // Checks the current URL to see if it has changed, and if it has,
        // calls `loadUrl`, normalizing across the hidden iframe.
        checkUrl: function(e) {
          var current = this.getFragment();
          if (current === this.fragment && this.iframe) {
            current = this.getFragment(this.getHash(this.iframe));
          }
          if (current === this.fragment) return false;
          if (this.iframe) this.navigate(current);
          this.loadUrl();
        },
    
        // Attempt to load the current URL fragment. If a route succeeds with a
        // match, returns `true`. If no defined routes matches the fragment,
        // returns `false`.
        loadUrl: function(fragment) {
          fragment = this.fragment = this.getFragment(fragment);
          return _.any(this.handlers, function(handler) {
            if (handler.route.test(fragment)) {
              handler.callback(fragment);
              return true;
            }
          });
        },
    
        // Save a fragment into the hash history, or replace the URL state if the
        // 'replace' option is passed. You are responsible for properly URL-encoding
        // the fragment in advance.
        //
        // The options object can contain `trigger: true` if you wish to have the
        // route callback be fired (not usually desirable), or `replace: true`, if
        // you wish to modify the current URL without adding an entry to the history.
        navigate: function(fragment, options) {
          if (!History.started) return false;
          if (!options || options === true) options = {
            trigger: !!options
          };
    
          var url = this.root + (fragment = this.getFragment(fragment || ''));
    
          // Strip the hash for matching.
          fragment = fragment.replace(pathStripper, '');
    
          if (this.fragment === fragment) return;
          this.fragment = fragment;
    
          // Don't include a trailing slash on the root.
          if (fragment === '' && url !== '/') url = url.slice(0, -1);
    
          // If pushState is available, we use it to set the fragment as a real URL.
          if (this._hasPushState) {
            this.history[options.replace ? 'replaceState' : 'pushState']({}, document.title, url);
    
            // If hash changes haven't been explicitly disabled, update the hash
            // fragment to store history.
          } else if (this._wantsHashChange) {
            this._updateHash(this.location, fragment, options.replace);
            if (this.iframe && (fragment !== this.getFragment(this.getHash(this.iframe)))) {
              // Opening and closing the iframe tricks IE7 and earlier to push a
              // history entry on hash-tag change.  When replace is true, we don't
              // want this.
              if (!options.replace) this.iframe.document.open().close();
              this._updateHash(this.iframe.location, fragment, options.replace);
            }
    
            // If you've told us that you explicitly don't want fallback hashchange-
            // based history, then `navigate` becomes a page refresh.
          } else {
            return this.location.assign(url);
          }
          if (options.trigger) return this.loadUrl(fragment);
        },
    
        // Update the hash location, either replacing the current entry, or adding
        // a new one to the browser history.
        _updateHash: function(location, fragment, replace) {
          if (replace) {
            var href = location.href.replace(/(javascript:|#).*$/, '');
            location.replace(href + '#' + fragment);
          } else {
            // Some browsers require that `hash` contains a leading #.
            location.hash = '#' + fragment;
          }
        }
    
      });
    
      // Create the default Backbone.history.
      Backbone.history = new History;
    
      // Helpers
      // -------
    
      // Helper function to correctly set up the prototype chain, for subclasses.
      // Similar to `goog.inherits`, but uses a hash of prototype properties and
      // class properties to be extended.
      var extend = function(protoProps, staticProps) {
        var parent = this;
        var child;
    
        // The constructor function for the new subclass is either defined by you
        // (the "constructor" property in your `extend` definition), or defaulted
        // by us to simply call the parent's constructor.
        if (protoProps && _.has(protoProps, 'constructor')) {
          child = protoProps.constructor;
        } else {
          child = function() {
            return parent.apply(this, arguments);
          };
        }
    
        // Add static properties to the constructor function, if supplied.
        _.extend(child, parent, staticProps);
    
        // Set the prototype chain to inherit from `parent`, without calling
        // `parent`'s constructor function.
        var Surrogate = function() {
          this.constructor = child;
        };
        Surrogate.prototype = parent.prototype;
        child.prototype = new Surrogate;
    
        // Add prototype properties (instance properties) to the subclass,
        // if supplied.
        if (protoProps) _.extend(child.prototype, protoProps);
    
        // Set a convenience property in case the parent's prototype is needed
        // later.
        child.__super__ = parent.prototype;
    
        return child;
      };
    
      // Set up inheritance for the model, collection, router, view and history.
      Model.extend = Collection.extend = Router.extend = View.extend = History.extend = extend;
    
      // Throw an error when a URL is needed, and none is supplied.
      var urlError = function() {
        throw new Error('A "url" property or function must be specified');
      };
    
      // Wrap an optional error callback with a fallback error event.
      var wrapError = function(model, options) {
        var error = options.error;
        options.error = function(resp) {
          if (error) error(model, resp, options);
          model.trigger('error', model, resp, options);
        };
      };
    
      root.Backbone = Backbone;
      return Backbone;
    });
    
    
    
    
    define('lib/backbone.nested',function() {
      
      var _ = require('lib/underscore'),
        $ = require('lib/jquery'),
        Backbone = require('lib/backbone'),
        _delayedTriggers = [],
        nestedChanges;
    
      Backbone.NestedModel = Backbone.Model.extend({
    
        get: function(attrStrOrPath) {
          return Backbone.NestedModel.walkThenGet(this.attributes, attrStrOrPath);
        },
    
        previous: function(attrStrOrPath) {
          return Backbone.NestedModel.walkThenGet(this._previousAttributes, attrStrOrPath);
        },
    
        has: function(attr) {
          // for some reason this is not how Backbone.Model is implemented - it accesses the attributes object directly
          var result = this.get(attr);
          return !(result === null || _.isUndefined(result));
        },
    
        set: function(key, value, opts) {
          var newAttrs = Backbone.NestedModel.deepClone(this.attributes),
            attrPath,
            unsetObj,
            validated;
    
          if (_.isString(key)) {
            // Backbone 0.9.0+ syntax: `model.set(key, val)` - convert the key to an attribute path
            attrPath = Backbone.NestedModel.attrPath(key);
          } else if (_.isArray(key)) {
            // attribute path
            attrPath = key;
          }
    
          if (attrPath) {
            opts = opts || {};
            this._setAttr(newAttrs, attrPath, value, opts);
          } else { // it's an Object
            opts = value || {};
            var attrs = key;
            for (var _attrStr in attrs) {
              if (attrs.hasOwnProperty(_attrStr)) {
                this._setAttr(newAttrs,
                  Backbone.NestedModel.attrPath(_attrStr),
                  opts.unset ? void 0 : attrs[_attrStr],
                  opts);
              }
            }
          }
    
          nestedChanges = Backbone.NestedModel.__super__.changedAttributes.call(this);
    
          if (opts.unset && attrPath && attrPath.length === 1) { // assume it is a singular attribute being unset
            // unsetting top-level attribute
            unsetObj = {};
            unsetObj[key] = void 0;
            nestedChanges = _.omit(nestedChanges, _.keys(unsetObj));
            validated = Backbone.NestedModel.__super__.set.call(this, unsetObj, opts);
          } else {
            unsetObj = newAttrs;
    
            // normal set(), or an unset of nested attribute
            if (opts.unset && attrPath) {
              // make sure Backbone.Model won't unset the top-level attribute
              opts = _.extend({}, opts);
              delete opts.unset;
            } else if (opts.unset && _.isObject(key)) {
              unsetObj = key;
            }
            nestedChanges = _.omit(nestedChanges, _.keys(unsetObj));
            validated = Backbone.NestedModel.__super__.set.call(this, unsetObj, opts);
          }
    
    
          if (!validated) {
            // reset changed attributes
            this.changed = {};
            nestedChanges = {};
            return false;
          }
    
    
          this._runDelayedTriggers();
          return this;
        },
    
        unset: function(attr, options) {
          return this.set(attr, void 0, _.extend({}, options, {
            unset: true
          }));
        },
    
        clear: function(options) {
          nestedChanges = {};
    
          // Mostly taken from Backbone.Model.set, modified to work for NestedModel.
          options = options || {};
          // clone attributes so validate method can't mutate it from underneath us.
          var attrs = _.clone(this.attributes);
          if (!options.silent && this.validate && !this.validate(attrs, options)) {
            return false; // Should maybe return this instead?
          }
    
          var changed = this.changed = {};
          var model = this;
    
          var setChanged = function(obj, prefix, options) {
            // obj will be an Array or an Object
            _.each(obj, function(val, attr) {
              var changedPath = prefix;
              if (_.isArray(obj)) {
                // assume there is a prefix
                changedPath += '[' + attr + ']';
              } else if (prefix) {
                changedPath += '.' + attr;
              } else {
                changedPath = attr;
              }
    
              val = obj[attr];
              if (_.isObject(val)) { // clear child attrs
                setChanged(val, changedPath, options);
              }
              if (!options.silent) model._delayedChange(changedPath, null, options);
              changed[changedPath] = null;
            });
          };
          setChanged(this.attributes, '', options);
    
          this.attributes = {};
    
          // Fire the `"change"` events.
          if (!options.silent) this._delayedTrigger('change');
    
          this._runDelayedTriggers();
          return this;
        },
    
        add: function(attrStr, value, opts) {
          var current = this.get(attrStr);
          if (!_.isArray(current)) throw new Error('current value is not an array');
          return this.set(attrStr + '[' + current.length + ']', value, opts);
        },
    
        remove: function(attrStr, opts) {
          opts = opts || {};
    
          var attrPath = Backbone.NestedModel.attrPath(attrStr),
            aryPath = _.initial(attrPath),
            val = this.get(aryPath),
            i = _.last(attrPath);
    
          if (!_.isArray(val)) {
            throw new Error("remove() must be called on a nested array");
          }
    
          // only trigger if an element is actually being removed
          var trigger = !opts.silent && (val.length >= i + 1),
            oldEl = val[i];
    
          // remove the element from the array
          val.splice(i, 1);
          opts.silent = true; // Triggers should only be fired in trigger section below
          this.set(aryPath, val, opts);
    
          if (trigger) {
            attrStr = Backbone.NestedModel.createAttrStr(aryPath);
            this.trigger('remove:' + attrStr, this, oldEl);
            for (var aryCount = aryPath.length; aryCount >= 1; aryCount--) {
              attrStr = Backbone.NestedModel.createAttrStr(_.first(aryPath, aryCount));
              this.trigger('change:' + attrStr, this, oldEl);
            }
            this.trigger('change', this, oldEl);
          }
    
          return this;
        },
    
        changedAttributes: function(diff) {
          var backboneChanged = Backbone.NestedModel.__super__.changedAttributes.call(this, diff);
          if (_.isObject(backboneChanged)) {
            return _.extend({}, nestedChanges, backboneChanged);
          }
          return false;
        },
    
        toJSON: function() {
          return Backbone.NestedModel.deepClone(this.attributes);
        },
    
    
        // private
        _delayedTrigger: function(  ) {
          _delayedTriggers.push(arguments);
        },
    
        _delayedChange: function(attrStr, newVal, options) {
          this._delayedTrigger('change:' + attrStr, this, newVal, options);
    
          // Check if `change` even *exists*, as it won't when the model is
          // freshly created.
          if (!this.changed) {
            this.changed = {};
          }
    
          this.changed[attrStr] = newVal;
        },
    
        _runDelayedTriggers: function() {
          while (_delayedTriggers.length > 0) {
            this.trigger.apply(this, _delayedTriggers.shift());
          }
        },
    
        // note: modifies `newAttrs`
        _setAttr: function(newAttrs, attrPath, newValue, opts) {
          opts = opts || {};
    
          var fullPathLength = attrPath.length;
          var model = this;
    
          Backbone.NestedModel.walkPath(newAttrs, attrPath, function(val, path, next) {
            var attr = _.last(path);
            var attrStr = Backbone.NestedModel.createAttrStr(path);
    
            // See if this is a new value being set
            var isNewValue = !_.isEqual(val[attr], newValue);
    
            if (path.length === fullPathLength) {
              // reached the attribute to be set
    
              if (opts.unset) {
                // unset the value
                delete val[attr];
    
                // Trigger Remove Event if array being set to null
                if (_.isArray(val)) {
                  var parentPath = Backbone.NestedModel.createAttrStr(_.initial(attrPath));
                  model._delayedTrigger('remove:' + parentPath, model, val[attr]);
                }
              } else {
                // Set the new value
                val[attr] = newValue;
              }
    
              // Trigger Change Event if new values are being set
              if (!opts.silent && _.isObject(newValue) && isNewValue) {
                var visited = [];
                var checkChanges = function(obj, prefix) {
                  // Don't choke on circular references
                  if (_.indexOf(visited, obj) > -1) {
                    return;
                  } else {
                    visited.push(obj);
                  }
    
                  var nestedAttr, nestedVal;
                  for (var a in obj) {
                    if (obj.hasOwnProperty(a)) {
                      nestedAttr = prefix + '.' + a;
                      nestedVal = obj[a];
                      if (!_.isEqual(model.get(nestedAttr), nestedVal)) {
                        model._delayedChange(nestedAttr, nestedVal, opts);
                      }
                      if (_.isObject(nestedVal)) {
                        checkChanges(nestedVal, nestedAttr);
                      }
                    }
                  }
                };
                checkChanges(newValue, attrStr);
    
              }
    
    
            } else if (!val[attr]) {
              if (_.isNumber(next)) {
                val[attr] = [];
              } else {
                val[attr] = {};
              }
            }
    
            if (!opts.silent) {
              // let the superclass handle change events for top-level attributes
              if (path.length > 1 && isNewValue) {
                model._delayedChange(attrStr, val[attr], opts);
              }
    
              if (_.isArray(val[attr])) {
                model._delayedTrigger('add:' + attrStr, model, val[attr]);
              }
            }
          });
        }
    
      }, {
        // class methods
    
        attrPath: function(attrStrOrPath) {
          var path;
    
          if (_.isString(attrStrOrPath)) {
            // TODO this parsing can probably be more efficient
            path = (attrStrOrPath === '') ? [''] : attrStrOrPath.match(/[^\.\[\]]+/g);
            path = _.map(path, function(val) {
              // convert array accessors to numbers
              return val.match(/^\d+$/) ? parseInt(val, 10) : val;
            });
          } else {
            path = attrStrOrPath;
          }
    
          return path;
        },
    
        createAttrStr: function(attrPath) {
          var attrStr = attrPath[0];
          _.each(_.rest(attrPath), function(attr) {
            attrStr += _.isNumber(attr) ? ('[' + attr + ']') : ('.' + attr);
          });
    
          return attrStr;
        },
    
        deepClone: function(obj) {
          return $.extend(true, {}, obj);
        },
    
        walkPath: function(obj, attrPath, callback, scope) {
          var val = obj,
            childAttr;
    
          // walk through the child attributes
          for (var i = 0; i < attrPath.length; i++) {
            callback.call(scope || this, val, attrPath.slice(0, i + 1), attrPath[i + 1]);
    
            childAttr = attrPath[i];
            val = val[childAttr];
            if (!val) break; // at the leaf
          }
        },
    
        walkThenGet: function(attributes, attrStrOrPath) {
          var attrPath = Backbone.NestedModel.attrPath(attrStrOrPath),
            result;
    
          Backbone.NestedModel.walkPath(attributes, attrPath, function(val, path) {
            var attr = _.last(path);
            if (path.length === attrPath.length) {
              // attribute found
              result = val[attr];
            }
          });
    
          return result;
        }
    
      });
    
      return Backbone;
    });
    
    define('models/lineCol',function() {
    	var BackboneNest = require('lib/backbone.nested'),
    		LineColModel;
    
    
    	
    	LineColModel = BackboneNest.NestedModel.extend({
    		defaults: {
    			
    			sort: 0,
    			
    			alias: '',
    			
    			left: 0,
    			
    			width: 71,
    			
    			originalWidth: 71,
    			
    			isRightAjacentHide: false,
    			
    			isleftAjacentHide: false,
    			
    			displayName: '',
    			
    			activeState: false,
    			
    			hidden: false,
    			
    			isView: true,
    			
    			operProp: {}
    		},
    		
    		destoryView: function() {
    			this.set('isView', false);
    		}
    	});
    	return LineColModel;
    });
    //attention bug, those name didn't significance
    
    define('models/selectRegion',function() {
    	var BackboneNest = require('lib/backbone.nested'),
    		SelectRegion;
    
    	
    	SelectRegion = BackboneNest.NestedModel.extend({
    		defaults: {
    			
    			tempPosi: {
    				
    				initColIndex: 0,
    				
    				initRowIndex: 0,
    				
    				mouseColIndex: 0,
    				
    				mouseRowIndex: 0
    			},
    			
    			physicsBox: {
    				
    				width: 71,
    				
    				height: 19,
    				
    				top: 0,
    				
    				left: 0,
    			},
    			//current box start,end postion index value (complete)
    			
    			wholePosi: {
    				
    				startX: 0,
    				
    				startY: 0,
    				
    				endX: 0,
    				
    				endY: 0
    			},
    			selectType: 'selected', // 'datasource','drag' , 'clip' , 'highlight','rulesource'
    		}
    	});
    	return SelectRegion;
    });
    
    define('collections/selectRegion',function() {
    	var Backbone = require('lib/backbone'),
    		config = require('spreadsheet/config'),
    		SelectRegionModel = require('models/selectRegion'),
    		SelectRegions;
    
    
    	
    	SelectRegions = Backbone.Collection.extend({
    		
    		model: SelectRegionModel,
    		url: 'select',
    		
    		getAdjacent: function(direction) {
    			var initPosiIndex = this.models[0].get('initPosi'),
    				physicsBox = this.models[0].get('physicsBox'),
    				wholePosiIndex = this.models[0].get('wholePosi'),
    				initPosiRowIndex = initPosiIndex.startX,
    				wholePosiStartRowIndex = wholePosiIndex.startX,
    				wholePosiEndRowIndex = wholePosiIndex.endX,
    				model = {};
    			switch (direction) {
    				case 'LEFT':
    					model.initPosi = {};
    					model.wholePosi = {};
    					model.physicsBox = {};
    					model.physicsBox = {};
    					model.initPosi.startX = initPosiRowIndex - 1;
    					model.wholePosi.startX = wholePosiStartRowIndex - 1;
    					model.wholePosi.endX = wholePosiEndRowIndex - 1;
    					model.physicsBox.left = physicsBox.left - config.User.cellWidth;
    					this.models[0].set(model);
    					break;
    				case 'RIGHT':
    
    					model.initPosi = {};
    					model.wholePosi = {};
    					model.physicsBox = {};
    					model.physicsBox = {};
    					model.initPosi.startX = initPosiRowIndex + 1;
    					model.wholePosi.startX = wholePosiStartRowIndex + 1;
    					model.wholePosi.endX = wholePosiEndRowIndex + 1;
    					model.physicsBox.left = physicsBox.left + config.User.cellWidth;
    					this.models[0].set(model);
    					break;
    				case 'UP':
    					break;
    				case 'DOWN':
    					break;
    			}
    		},
    		
    		getModelByType: function(type) {
    			return this.findWhere({
    				selectType: type
    			});
    		}
    	});
    	return new SelectRegions();
    });
    
    define('collections/headItemCol',function() {
    	var _ = require('lib/underscore'),
    		Backbone = require('lib/backbone'),
    		binary = require('basic/util/binary'),
    		LineColModel = require('models/lineCol'),
    		selectRegions = require('collections/selectRegion');
    	
    	var HeadItemCols = Backbone.Collection.extend({
    		
    		model: LineColModel,
    		url: 'itemcol',
    		
    		getModelInitSelectRegion: function() {
    			return this.models[selectRegions.models[0].toJSON().initPosi.startX];
    		},
    		
    		getModelListByWholeSelectRegion: function() {
    			var modelList = [],
    				selectRegion,
    				between,
    				startIndexCol,
    				endIndexCol,
    				i = 0;
    
    			selectRegion = selectRegions.models[0];
    			startIndexCol = selectRegion.get('wholePosi').startX;
    			endIndexCol = selectRegion.get('wholePosi').endX;
    			between = endIndexCol - startIndexCol + 1;
    			for (; i < between; i++) {
    				modelList.push(this.models[startIndexCol + i]);
    			}
    			return modelList;
    		},
    		getIndexBySort: function(sort) {
    			if (sort === 'MAX') {
    				return 'MAX';
    			}
    			return binary.indexAttrBinary(sort, this.models, 'sort');
    		},
    		getAliasBySort: function(sort) {
    			var index;
    			if (sort === 'MAX') {
    				return 'MAX';
    			}
    			index = binary.indexAttrBinary(sort, this.models, 'sort');
    			if (index === -1) {
    				return -1;
    			}
    			return this.models[index].get('alias');
    		},
    		getIndexByDisplayname: function(displayName) {
    			var model = this.findWhere({
    				'displayName': displayName
    			});
    			return _.indexOf(this.models, model);
    		},
    		
    		getModelListByIndex: function(startColIndex, endColIndex) {
    			var i, modelList = [];
    			for (i = startColIndex; i < endColIndex + 1; i++) {
    				modelList.push(this.models[i]);
    			}
    			return modelList;
    		},
    
    		
    		getMaxDistanceWidth: function() {
    			var currentModel = this.models[this.models.length - 1];
    			return currentModel.get('left') + currentModel.get('width');
    		},
    		
    		getIndexByAlias: function(alias) {
    			var i, len, modelList = this.models;
    			if (alias === 'MAX') {
    				return 'MAX';
    			} else {
    				for (i = 0, len = this.length; i < len; i++) {
    					if (modelList[i].attributes.alias === alias) {
    						return i;
    					}
    				}
    			}
    			return -1;
    		},
    		
    		getModelByAlias: function(alias) {
    			return this.findWhere({
    				'alias': alias
    			});
    		},
    		
    		getModelByPosition: function(posi) {
    			var currentIndex = binary.newModelBinary(posi, this.models, 'left', 'width', 0, this.models.length - 1);
    			return this.models[currentIndex];
    		},
    		
    		getNeighborModelByAlias: function(alias, redirction) {
    			var modelList = this.models,
    				len = modelList.length,
    				currentIndex;
    			//toward to right
    			if (redirction === 'RIGHT') {
    				currentIndex = this.getIndexByAlias(alias);
    				if (currentIndex === len - 1) {
    					return null;
    				}
    				return modelList[currentIndex + 1];
    			}
    			// toward to left
    			if (redirction === 'LEFT') {
    				currentIndex = this.getIndexByAlias(alias);
    				if (currentIndex === 0) {
    					return null;
    				}
    				return modelList[currentIndex - 1];
    			}
    			return null;
    		}
    	});
    	return new HeadItemCols();
    });
    
    define('models/lineRow',function() {
    
    	var BackboneNest = require('lib/backbone.nested'),
    		LineRowModel;
    
    	
    	LineRowModel = BackboneNest.NestedModel.extend({
    		defaults: {
    			
    			sort: 0,
    			
    			alias: '',
    			
    			top: 0,
    			
    			height: 19,
    			
    			displayName: '',
    			
    			activeState: false,
    			
    			isView: true,
    			
    			operProp:{}
    		},
    		
    		destroyView: function() {
    			this.set('isView', false);
    		}
    	});
    	return LineRowModel;
    });
    
    define('collections/headItemRow',function() {
    	var _ = require('lib/underscore'),
    		Backbone = require('lib/backbone'),
    		binary = require('basic/util/binary'),
    		LineRowModel = require('models/lineRow'),
    		config = require('spreadsheet/config'),
    		getDisplayName = require('basic/tools/getdisplayname'),
    		selectRegions = require('collections/selectRegion'),
    		HeadItemRows;
    	
    	HeadItemRows = Backbone.Collection.extend({
    		
    		model: LineRowModel,
    		url: 'itemrow',
    		
    		getModelInitSelectRegion: function() {
    			return this.models[selectRegions.models[0].toJSON().initPosi.startY];
    		},
    		
    		getModelListByIndex: function(startRowIndex, endRowIndex) {
    			var i, modelList = [];
    			for (i = startRowIndex; i < endRowIndex + 1; i++) {
    				modelList.push(this.models[i]);
    			}
    			return modelList;
    		},
    		
    		getModelListByWholeSelectRegion: function() {
    			var modelList = [],
    				selectRegion,
    				between,
    				startIndexRow,
    				endIndexRow,
    				i = 0;
    
    			selectRegion = selectRegions.models[0];
    			startIndexRow = selectRegion.get('wholePosi').startY;
    			endIndexRow = selectRegion.get('wholePosi').endY;
    			between = endIndexRow - startIndexRow + 1;
    			for (; i < between; i++) {
    				modelList.push(this.models[startIndexRow + i]);
    			}
    			return modelList;
    		},
    		getIndexByDisplayname: function(displayName) {
    			return _.findIndex(this.toJSON(), {
    				'displayName': displayName
    			});
    		},
    		
    		getMaxDistanceHeight: function() {
    			var currentModel = this.models[this.models.length - 1];
    			return currentModel.get('top') + currentModel.get('height');
    		},
    		
    		getModelByAlias: function(alias) {
    			return this.findWhere({
    				'alias': alias
    			});
    		},
    		
    		getModelByPosition: function(posi) {
    			var currentIndex = binary.newModelBinary(posi, this.models, 'top', 'height', 0, this.models.length - 1);
    			return this.models[currentIndex];
    		},
    		getIndexByPosi: function(posi) {
    			return binary.newModelBinary(posi, this.models, 'top', 'height');
    		},
    		getIndexBySort: function(sort) {
    			if (sort === 'MAX') {
    				return 'MAX';
    			}
    			return binary.indexAttrBinary(sort, this.models, 'sort');
    		},
    		getAliasBySort: function(sort) {
    			var index;
    			if (sort === 'MAX') {
    				return 'MAX';
    			}
    			index = binary.indexAttrBinary(sort, this.models, 'sort');
    			if (index === -1) {
    				return -1;
    			}
    			return this.models[index].get('alias');
    		},
    		
    		getIndexByAlias: function(alias) {
    			var i, len, modelList = this.models;
    			if (alias === 'MAX') {
    				return 'MAX';
    			} else {
    				for (i = 0, len = this.length; i < len; i++) {
    					if (modelList[i].attributes.alias === alias) {
    						return i;
    					}
    				}
    			}
    			return -1;
    		},
    		getNextAliasByAlias: function(alias) {
    			var index,
    				model;
    			model = this.findWhere({
    				'alias': alias
    			});
    			index = _.indexOf(this.models, model);
    			return this.models[index + 1].get('alias');
    		},
    		
    		getNeighborModelByAlias: function(alias, redirction) {
    			var modelList = this.models,
    				len = modelList.length,
    				currentIndex;
    			//toward to right
    			if (redirction === 'RIGHT') {
    				currentIndex = this.getIndexByAlias(alias);
    				if (currentIndex === len - 1) {
    					return null;
    				}
    				return modelList[currentIndex + 1];
    			}
    			// toward to left
    			if (redirction === 'LEFT') {
    				currentIndex = this.getIndexByAlias(alias);
    				if (currentIndex === 0) {
    					return null;
    				}
    				return modelList[currentIndex - 1];
    			}
    			return null;
    		},
    		
    		generate: function(len) {
    			var lastModel,
    				startPosi,
    				startSort,
    				i;
    			if (typeof len === 'undefined') {
    				len = 1;
    			}
    			lastModel = this.models[this.length - 1];
    			startSort = lastModel.get('sort') + 1;
    			startPosi = lastModel.get('height') + lastModel.get('top') + 1;
    
    			for (i = 0; i < len; i++) {
    				if (startSort + 2 > config.User.maxRowNum) {
    					break;
    				}
    				this.add({
    					sort: startSort,
    					alias: (startSort + 1).toString(),
    					top: startPosi,
    					height: config.User.cellHeight - 1,
    					displayName: getDisplayName.getRowDisplayName(startSort)
    				});
    				startSort++;
    				startPosi = startPosi + config.User.cellHeight;
    			}
    		}
    	});
    	return new HeadItemRows();
    });
    
    define('models/siderLineCol',function() {
    	var BackboneNest = require('lib/backbone.nested'),
    		SiderLineColModel;
    
    
    	
    	SiderLineColModel = BackboneNest.NestedModel.extend({
    		defaults: {
    			
    			left: 0,
    			
    			width: 69
    		}
    	});
    	return SiderLineColModel;
    });
    
    define('collections/siderLineCol',function() {
    	var Backbone = require('lib/backbone'),
    		SiderLineColModel = require('models/siderLineCol'),
    		SiderLineCols;
    	
    	SiderLineCols = Backbone.Collection.extend({
    		
    		model: SiderLineColModel,
    		url: 'sidercol'
    	});
    	return new SiderLineCols();
    });
    
    define('models/siderLineRow',function() {
    	var BackboneNest = require('lib/backbone.nested'),
    		SiderLineRowModel;
    	
    	
    	SiderLineRowModel = BackboneNest.NestedModel.extend({
    		defaults: {
    			
    			top: 0,
    			
    			height: 17
    		}
    	});
    	return SiderLineRowModel;
    });
    
    define('collections/siderLineRow',function() {
    	var Backbone = require('lib/backbone'),
    		SiderLineRowModel = require('models/siderLineRow'),
    		SiderLineRows;
    
    	
    	SiderLineRows = Backbone.Collection.extend({
    		
    		model: SiderLineRowModel,
    		url: 'siderrow'
    	});
    	return new SiderLineRows();
    });
    define('models/sheet',function() {
        
        var Backbone = require('lib/backbone'),
            SheetModel;
        SheetModel = Backbone.Model.extend({
            defaults: {
                name: 'book',
                sort: 0
            }
        });
        return SheetModel;
    });
    
    define('collections/sheets',function() {
    	var Backbone = require('lib/backbone'),
    		SheetModel = require('models/sheet');
    
    
    	
    	var Sheets = Backbone.Collection.extend({
    		
    		model: SheetModel
    	});
    	return new Sheets();
    });
    //attention bug, this `models` need to `Models` , this is error 
    //, secound phease correction
    //attention bug, remarket lack isn't exist `remarket` property .
    //attention bug, showState is or not exist value ?
    
    define('models/cell',function() {
    	var BackboneNest = require('lib/backbone.nested'),
    		CellModel;
    	
    	CellModel = BackboneNest.NestedModel.extend({
    		defaults: {
    			
    			physicsBox: {
    				
    				top: 0,
    				
    				left: 0,
    				
    				width: 71,
    				
    				height: 19
    			},
    			
    			occupy: {
    				
    				x: [],
    				
    				y: []
    			},
    			
    			content: {
    				
    				size: '11',
    				
    				family: 'SimSun',
    				
    				bd: false,
    				
    				underline: false,
    				
    				italic: false,
    
    				
    				color: 'rgb(0, 0, 0)',
    				
    				alignRow: '',
    				
    				alignCol: 'middle',
    				
    				texts: '',
    				
    				displayTexts: ''
    			},
    			wordWrap: false,
    			
    			border: {
    				
    				top: false,
    				
    				right: false,
    				
    				bottom: false,
    				
    				left: false
    			},
    			
    			format: {
    				
    				type: 'normal',
    				
    				isValid: true,
    				
    				decimal: null,
    				
    				thousands: null,
    				
    				dateFormat: null,
    				
    				currencySign: null,
    				
    				currencyValid: true
    			},
    			
    			customProp: {
    				
    				background: 'rgb(255, 255, 255)',
    				
    				comment: null
    			},
    			locked: true,
    			
    			showState: true,
    			
    			hidden: false,
    			
    			isDestroy: false,
    			
    			highlight: false,
    		},
    		
    		hide: function() {
    			this.set('showState', false);
    		},
    		
    
    	});
    	return CellModel;
    });
    
    define('collections/cells',function() {
    	var Backbone = require('lib/backbone'),
    		cache = require('basic/tools/cache'),
    		binary = require('basic/util/binary'),
    		CellModel = require('models/cell'),
    		headItemCols = require('collections/headItemCol'),
    		headItemRows = require('collections/headItemRow'),
    		selectRegions = require('collections/selectRegion'),
    		rowList = headItemRows.models,
    		colList = headItemCols.models;
    	
    	var Cells = Backbone.Collection.extend({
    		
    		model: CellModel,
    		url: '/cell.htm',
    		
    		createCellModel: function(startColIndex, startRowIndex,
    			endColIndex, endRowIndex, prop) {
    			var rowLen, colLen, i, j,
    				occupyCol = [],
    				occupyRow = [],
    				cell,
    				width = 0,
    				height = 0,
    				top,
    				left,
    				temp;
    
    			if (endColIndex === undefined) {
    				endColIndex = startColIndex;
    				endRowIndex = startRowIndex;
    			} else if (typeof endColIndex === 'object') {
    				prop = endColIndex;
    				endColIndex = startColIndex;
    				endRowIndex = startRowIndex;
    			}
    			left = colList[startColIndex].get('left');
    			top = rowList[startRowIndex].get('top');
    
    			rowLen = endRowIndex - startRowIndex + 1;
    			colLen = endColIndex - startColIndex + 1;
    
    			cell = new CellModel();
    			
    			if (prop !== undefined) {
    				setProp(cell, prop);
    			} else if (!isEmptyObject(temp = colList[startColIndex].get('operProp'))) {
    				setProp(cell, temp);
    			} else if (!isEmptyObject(temp = rowList[startRowIndex].get('operProp'))) {
    				setProp(cell, temp);
    			}
    			//获取occupy信息
    			for (i = 0; i < colLen; i++) {
    				occupyCol.push(colList[startColIndex + i].get('alias'));
    				width += colList[startColIndex + i].get('width') + 1;
    			}
    			for (i = 0; i < rowLen; i++) {
    				occupyRow.push(rowList[startRowIndex + i].get('alias'));
    				height += rowList[startRowIndex + i].get('height') + 1;
    			}
    			for (i = 0; i < rowLen; i++) {
    				for (j = 0; j < colLen; j++) {
    					cache.cachePosition(rowList[startRowIndex + i].get('alias'),
    						colList[startColIndex + j].get('alias'),
    						this.length);
    				}
    			}
    
    			cell.set('occupy', {
    				x: occupyCol,
    				y: occupyRow
    			});
    			cell.set('physicsBox', {
    				top: top,
    				left: left,
    				width: width - 1,
    				height: height - 1
    			});
    
    			this.add(cell);
    
    			function setProp(cell, prop) {
    				var parentKey,
    					childKey;
    				for (parentKey in prop) {
    					if (typeof prop[parentKey] === 'object') {
    						for (childKey in prop[parentKey]) {
    							cell.set(parentKey + '.' + childKey, prop[parentKey][childKey]);
    						}
    					} else {
    						cell.set(parentKey, prop[parentKey]);
    					}
    				}
    			}
    
    			function isEmptyObject(obj) {
    				var prop;
    				for (prop in obj) {
    					return false;
    				}
    				return true;
    			}
    			return cell;
    		},
    		
    		getCellByVertical: function(startColIndex, startRowIndex, endColIndex, endRowIndex) {
    			var result = [],
    				strandX,
    				index,
    				tempObj = {},
    				i, j,
    				len1, len2,
    				rowAlias,
    				colAlias,
    				region;
    
    			if (typeof startColIndex === 'object') {
    				region = startColIndex;
    				startColIndex = region.startColIndex;
    				startRowIndex = region.startRowIndex;
    				endColIndex = region.endColIndex;
    				endRowIndex = region.endRowIndex;
    			}
    			if (endRowIndex === undefined) {
    				endRowIndex = startRowIndex;
    			}
    			if (endColIndex === undefined) {
    				endColIndex = startColIndex;
    			}
    			if (endRowIndex === 'MAX') {
    				endRowIndex = headItemRows.length - 1;
    			}
    			if (endColIndex === 'MAX') {
    				endColIndex = headItemCols.length - 1;
    			}
    			strandX = cache.CellsPosition.strandX;
    			for (i = startColIndex, len1 = endColIndex + 1; i < len1; i++) {
    				colAlias = headItemCols.models[i].get('alias');
    				if (typeof strandX[colAlias] !== 'undefined') {
    					for (j = startRowIndex, len2 = endRowIndex + 1; j < len2; j++) {
    						rowAlias = headItemRows.models[j].get('alias');
    						if (typeof strandX[colAlias][rowAlias] !== 'undefined') {
    							index = strandX[colAlias][rowAlias];
    							if (!tempObj[index]) {
    								result.push(this.at(index));
    								tempObj[index] = 1;
    
    							}
    						}
    					}
    				}
    			}
    			return result;
    		},
    		
    		getCellByTransverse: function(startIndexRow, startIndexCol, endIndexRow, endIndexCol) {
    			var result = [],
    				strandY,
    				index,
    				tempObj = {},
    				i, j,
    				len1, len2,
    				rowAlias,
    				colAlias;
    
    			if (endIndexRow === undefined) {
    				endIndexRow = startIndexRow;
    			}
    			if (endIndexCol === undefined) {
    				endIndexCol = startIndexCol;
    			}
    			if (endIndexRow === 'MAX') {
    				endIndexRow = headItemRows.length - 1;
    			}
    			if (endIndexCol === 'MAX') {
    				endIndexCol = headItemCols.length - 1;
    			}
    			strandY = cache.CellsPosition.strandY;
    			for (i = startIndexRow, len1 = endIndexRow + 1; i < len1; i++) {
    				rowAlias = headItemRows.models[i].get('alias');
    				if (typeof strandY[rowAlias] !== 'undefined') {
    					for (j = startIndexCol, len2 = endIndexCol + 1; j < len2; j++) {
    						colAlias = headItemCols.models[j].get('alias');
    						if (typeof strandY[rowAlias][colAlias] !== 'undefined') {
    							index = strandY[rowAlias][colAlias];
    							if (!tempObj[index]) {
    								result.push(this.at(index));
    								tempObj[index] = 1;
    							}
    						}
    					}
    				}
    			}
    			return result;
    		},
    		
    		getCellByRow: function(startIndex, endIndex) {
    			return this.getCellByTransverse(startIndex, 0, endIndex, 'MAX');
    		},
    		
    		
    		getRegionCells: function(startIndexCol, startIndexRow, endIndexCol, endIndexRow) {
    			if (endIndexCol === undefined) {
    				endIndexCol = startIndexCol;
    			}
    			if (endIndexRow === undefined) {
    				endIndexRow = startIndexRow;
    			}
    			var cellList = [],
    				i = 0,
    				j = 0,
    				aliasCol,
    				aliasRow,
    				betweenRow = endIndexRow - startIndexRow + 1,
    				betweenCol = endIndexCol - startIndexCol + 1,
    				gridModelListRow = headItemRows.models,
    				gridModelListCol = headItemCols.models,
    				cellsPositionX = cache.CellsPosition.strandX;
    
    			for (; i < betweenRow; i++) {
    				for (j = 0; j < betweenCol; j++) {
    					aliasRow = gridModelListRow[startIndexRow + i].get('alias');
    					aliasCol = gridModelListCol[startIndexCol + j].get('alias');
    					if (cellsPositionX[aliasCol] !== undefined && cellsPositionX[aliasCol][aliasRow] !== undefined) {
    						cellList.push(this.models[cellsPositionX[aliasCol][aliasRow]]);
    					} else {
    						cellList.push(null);
    					}
    				}
    
    			}
    			return cellList;
    		},
    		
    		getCellsByWholeSelectRegion: function() {
    			var cellList = [],
    				i,
    				j,
    				rowLen,
    				colLen,
    				select = selectRegions.models[0].get('wholePosi'),
    				headRowList = headItemRows.models,
    				headColList = headItemCols.models,
    				startColIndex,
    				startRowIndex,
    				endColIndex,
    				endRowIndex,
    				cellsPositionX = cache.CellsPosition.strandX,
    				aliasRow,
    				aliasCol;
    
    			startColIndex = headItemCols.getIndexByAlias(select.startX);
    			startRowIndex = headItemRows.getIndexByAlias(select.startY);
    			endColIndex = headItemCols.getIndexByAlias(select.endX);
    			endRowIndex = headItemRows.getIndexByAlias(select.endY);
    
    			rowLen = endColIndex - startColIndex + 1;
    			colLen = endRowIndex - startRowIndex + 1;
    			for (i = 0; i < rowLen; i++) {
    				for (j = 0; j < colLen; j++) {
    					aliasRow = headRowList[startRowIndex + i].get('alias');
    					aliasCol = headColList[startColIndex + j].get('alias');
    					if (cellsPositionX[aliasCol] !== undefined && cellsPositionX[aliasCol][aliasRow] !== undefined) {
    						cellList.push(this.models[cellsPositionX[aliasCol][aliasRow]]);
    					} else {
    						cellList.push(null);
    					}
    				}
    			}
    			return cellList;
    		},
    		
    		getCellsBySiderSelectRegion: function() {
    			var verticalModelList,
    				transverModelList,
    				cellModelList = {};
    			verticalModelList = this.getCellsByVerticalSiderSelectRegion();
    			transverModelList = this.getCellsByTransverSiderSelectRegion();
    
    			cellModelList.vertical = verticalModelList;
    			cellModelList.transver = transverModelList;
    			return cellModelList;
    		},
    		
    		getCellsByVerticalSiderSelectRegion: function() {
    			var modelList = {
    					left: [],
    					right: []
    				},
    				aliasCol,
    				aliasRow,
    				headLineColModelList,
    				headLineRowModelList,
    				colLen,
    				rowLen,
    				i, j,
    				cellsPositionX;
    			cellsPositionX = cache.CellsPosition.strandX;
    			headLineColModelList = headItemCols.getModelListByWholeSelectRegion();
    			headLineRowModelList = headItemRows.getModelListByWholeSelectRegion();
    			colLen = headLineColModelList.length;
    			rowLen = headLineRowModelList.length;
    			for (i = 0; i < rowLen; i++) {
    				for (j = 0; j < colLen; j++) {
    					if (j === 0) {
    						aliasRow = headLineRowModelList[i].get('alias');
    						aliasCol = headLineColModelList[j].get('alias');
    						if (cellsPositionX[aliasCol] !== undefined && cellsPositionX[aliasCol][aliasRow] !== undefined) {
    							modelList.left.push(this.models[cellsPositionX[aliasCol][aliasRow]]);
    						} else {
    							modelList.left.push(null);
    						}
    					}
    					if (j === colLen - 1) {
    						aliasRow = headLineRowModelList[i].get('alias');
    						aliasCol = headLineColModelList[j].get('alias');
    						if (cellsPositionX[aliasCol] !== undefined && cellsPositionX[aliasCol][aliasRow] !== undefined) {
    							modelList.right.push(this.models[cellsPositionX[aliasCol][aliasRow]]);
    						} else {
    							modelList.right.push(null);
    						}
    					}
    				}
    			}
    			return modelList;
    		},
    		
    		getCellsByTransverSiderSelectRegion: function() {
    			var modelList = {
    					top: [],
    					bottom: []
    				},
    				aliasCol,
    				aliasRow,
    				headLineColModelList,
    				headLineRowModelList,
    				colLen,
    				rowLen,
    				i, j,
    				cellsPositionX;
    
    			cellsPositionX = cache.CellsPosition.strandX;
    			headLineColModelList = headItemCols.getModelListByWholeSelectRegion();
    			headLineRowModelList = headItemRows.getModelListByWholeSelectRegion();
    			colLen = headLineColModelList.length;
    			rowLen = headLineRowModelList.length;
    			for (i = 0; i < colLen; i++) {
    				for (j = 0; j < rowLen; j++) {
    					if (j === 0) {
    						aliasRow = headLineRowModelList[j].get('alias');
    						aliasCol = headLineColModelList[i].get('alias');
    						if (cellsPositionX[aliasCol] !== undefined && cellsPositionX[aliasCol][aliasRow] !== undefined) {
    							modelList.top.push(this.models[cellsPositionX[aliasCol][aliasRow]]);
    						} else {
    							modelList.top.push(null);
    						}
    					}
    					if (j === rowLen - 1) {
    						aliasRow = headLineRowModelList[j].get('alias');
    						aliasCol = headLineColModelList[i].get('alias');
    						if (cellsPositionX[aliasCol] !== undefined && cellsPositionX[aliasCol][aliasRow] !== undefined) {
    							modelList.bottom.push(this.models[cellsPositionX[aliasCol][aliasRow]]);
    						} else {
    							modelList.bottom.push(null);
    						}
    					}
    				}
    			}
    			return modelList;
    		},
    		
    		getHeadModelByWholeSelectRegion: function() {
    			var partModelList = [],
    				partModel,
    				headLineColModelList,
    				headLineRowModelList,
    				colLen,
    				rowLen,
    				i, j;
    
    			headLineColModelList = headItemCols.getModelListByWholeSelectRegion();
    			headLineRowModelList = headItemRows.getModelListByWholeSelectRegion();
    			colLen = headLineColModelList.length;
    			rowLen = headLineRowModelList.length;
    			for (i = 0; i < rowLen; i++) {
    				for (j = 0; j < colLen; j++) {
    					partModel = {
    						wholePosi: {
    							startX: selectRegions.models[0].get('wholePosi').startX + j,
    							startY: selectRegions.models[0].get('wholePosi').startY + i
    						},
    						occupy: {
    							x: headLineColModelList[j].get('alias'),
    							y: headLineRowModelList[i].get('alias')
    						},
    						physicsBox: {
    							top: headLineRowModelList[i].get('top'),
    							left: headLineColModelList[j].get('left'),
    							width: headLineColModelList[j].get('width'),
    							height: headLineRowModelList[i].get('height'),
    						}
    					};
    					partModelList.push(partModel);
    				}
    			}
    			return partModelList;
    		},
    		
    		getHeadModelBySiderSelectRegion: function() {
    			var verticalModelList,
    				transverModelList,
    				siderModelList = {};
    			verticalModelList = this.getHeadModelByVerticalSiderSelectRegion();
    			transverModelList = this.getHeadModelByTransverSiderSelectRegion();
    			siderModelList.vertical = verticalModelList;
    			siderModelList.transverse = transverModelList;
    			return siderModelList;
    		},
    		
    		getHeadModelByVerticalSiderSelectRegion: function() {
    			var partModelList = {
    					left: [],
    					right: []
    				},
    				partModel,
    				headLineColModelList,
    				headLineRowModelList,
    				colLen,
    				rowLen,
    				i, j;
    
    			headLineColModelList = headItemCols.getModelListByWholeSelectRegion();
    			headLineRowModelList = headItemRows.getModelListByWholeSelectRegion();
    			colLen = headLineColModelList.length;
    			rowLen = headLineRowModelList.length;
    			for (i = 0; i < rowLen; i++) {
    				for (j = 0; j < colLen; j++) {
    					if (j === 0) {
    						partModel = {
    							wholePosi: {
    								startX: selectRegions.models[0].get('wholePosi').startX + j,
    								startY: selectRegions.models[0].get('wholePosi').startY + i
    							},
    							occupy: {
    								x: headLineColModelList[j].get('alias'),
    								y: headLineRowModelList[i].get('alias')
    							},
    							physicsBox: {
    								top: headLineRowModelList[i].get('top'),
    								left: headLineColModelList[j].get('left'),
    								width: headLineColModelList[j].get('width'),
    								height: headLineRowModelList[i].get('height'),
    							}
    						};
    						partModelList.left.push(partModel);
    					}
    					if (j === colLen - 1) {
    						partModel = {
    							wholePosi: {
    								startX: selectRegions.models[0].get('wholePosi').startX + j,
    								startY: selectRegions.models[0].get('wholePosi').startY + i
    							},
    							occupy: {
    								x: headLineColModelList[j].get('alias'),
    								y: headLineRowModelList[i].get('alias')
    							},
    							physicsBox: {
    								top: headLineRowModelList[i].get('top'),
    								left: headLineColModelList[j].get('left'),
    								width: headLineColModelList[j].get('width'),
    								height: headLineRowModelList[i].get('height'),
    							}
    						};
    						partModelList.right.push(partModel);
    					}
    				}
    			}
    			return partModelList;
    		},
    		
    		getHeadModelByTransverSiderSelectRegion: function() {
    			var partModelList = {
    					top: [],
    					bottom: []
    				},
    				partModel,
    				headLineColModelList,
    				headLineRowModelList,
    				colLen,
    				rowLen,
    				i, j;
    
    			headLineColModelList = headItemCols.getModelListByWholeSelectRegion();
    			headLineRowModelList = headItemRows.getModelListByWholeSelectRegion();
    			colLen = headLineColModelList.length;
    			rowLen = headLineRowModelList.length;
    			for (i = 0; i < colLen; i++) {
    				for (j = 0; j < rowLen; j++) {
    					if (j === 0) {
    						partModel = {
    							wholePosi: {
    								startX: selectRegions.models[0].get('wholePosi').startX + i,
    								startY: selectRegions.models[0].get('wholePosi').startY + j
    							},
    							occupy: {
    								x: headLineColModelList[i].get('alias'),
    								y: headLineRowModelList[j].get('alias')
    							},
    							physicsBox: {
    								top: headLineRowModelList[j].get('top'),
    								left: headLineColModelList[i].get('left'),
    								width: headLineColModelList[i].get('width'),
    								height: headLineRowModelList[j].get('height'),
    							}
    						};
    						partModelList.top.push(partModel);
    					}
    					if (j === rowLen - 1) {
    						partModel = {
    							wholePosi: {
    								startX: selectRegions.models[0].get('wholePosi').startX + i,
    								startY: selectRegions.models[0].get('wholePosi').startY + j
    							},
    							occupy: {
    								x: headLineColModelList[i].get('alias'),
    								y: headLineRowModelList[j].get('alias')
    							},
    							physicsBox: {
    								top: headLineRowModelList[j].get('top'),
    								left: headLineColModelList[i].get('left'),
    								width: headLineColModelList[i].get('width'),
    								height: headLineRowModelList[j].get('height'),
    							}
    						};
    						partModelList.bottom.push(partModel);
    					}
    				}
    			}
    			return partModelList;
    		},
    		
    		operLeftHeadModel: function(startColIndex, startRowIndex, endColIndex, endRowIndex, fn) {
    			var headItemRowList = headItemRows.models,
    				headItemColList = headItemCols.models,
    				cellsPosition,
    				tempObj = {},
    				tempCell,
    				aliasCol,
    				aliasRow,
    				i;
    
    			if (endColIndex === undefined) {
    				endColIndex = startColIndex;
    			}
    			if (endRowIndex === undefined) {
    				endRowIndex = startRowIndex;
    			}
    			aliasCol = headItemColList[startColIndex].get('alias');
    			cellsPosition = cache.CellsPosition.strandX[aliasCol];
    			for (i = startRowIndex; i < endRowIndex + 1; i++) {
    				aliasRow = headItemRowList[i].get('alias');
    				if (cellsPosition !== undefined && cellsPosition[aliasRow] !== undefined) {
    					if (!tempObj[cellsPosition[aliasRow]]) {
    						tempCell = this.models[cellsPosition[aliasRow]];
    					} else {
    						tempObj[cellsPosition[aliasCol]] = 1;
    						continue;
    					}
    				} else {
    					tempCell = this.createCellModel(startColIndex, i);
    				}
    				fn(tempCell, headItemColList[startColIndex].get('sort'), headItemRowList[i].get('sort'));
    			}
    		},
    		
    		operRightHeadModel: function(startColIndex, startRowIndex, endColIndex, endRowIndex, fn) {
    			var headItemRowList = headItemRows.models,
    				headItemColList = headItemCols.models,
    				cellsPosition,
    				tempObj = {},
    				tempCell,
    				aliasCol,
    				aliasRow,
    				i;
    			if (endColIndex === undefined) {
    				endColIndex = startColIndex;
    			}
    			if (endRowIndex === undefined) {
    				endRowIndex = startRowIndex;
    			}
    			aliasCol = headItemColList[endColIndex].get('alias');
    			cellsPosition = cache.CellsPosition.strandX[aliasCol];
    
    			for (i = startRowIndex; i < endRowIndex + 1; i++) {
    				aliasRow = headItemRowList[i].get('alias');
    				if (cellsPosition !== undefined && cellsPosition[aliasRow] !== undefined) {
    					if (!tempObj[cellsPosition[aliasRow]]) {
    						tempCell = this.models[cellsPosition[aliasRow]];
    					} else {
    						tempObj[cellsPosition[aliasCol]] = 1;
    						continue;
    					}
    				} else {
    					tempCell = this.createCellModel(endColIndex, i);
    				}
    				fn(tempCell, headItemColList[endColIndex].get('sort'), headItemRowList[i].get('sort'));
    			}
    		},
    		
    		operTopHeadModel: function(startColIndex, startRowIndex, endColIndex, endRowIndex, fn) {
    			var headItemRowList = headItemRows.models,
    				headItemColList = headItemCols.models,
    				cellsPosition,
    				tempObj = {},
    				tempCell,
    				aliasCol,
    				aliasRow,
    				i;
    			if (endColIndex === undefined) {
    				endColIndex = startColIndex;
    			}
    			if (endRowIndex === undefined) {
    				endRowIndex = startRowIndex;
    			}
    
    			aliasRow = headItemRowList[startRowIndex].get('alias');
    			cellsPosition = cache.CellsPosition.strandY[aliasRow];
    
    			for (i = startColIndex; i < endColIndex + 1; i++) {
    				aliasCol = headItemColList[i].get('alias');
    				if (cellsPosition !== undefined && cellsPosition[aliasCol] !== undefined) {
    					if (!tempObj[cellsPosition[aliasCol]]) {
    						tempCell = this.models[cellsPosition[aliasCol]];
    					} else {
    						tempObj[cellsPosition[aliasCol]] = 1;
    						continue;
    					}
    				} else {
    					tempCell = this.createCellModel(i, startRowIndex);
    				}
    				fn(tempCell, headItemColList[i].get('sort'), headItemRowList[startRowIndex].get('sort'));
    			}
    		},
    		
    		operBottomHeadModel: function(startColIndex, startRowIndex, endColIndex, endRowIndex, fn) {
    			var headItemRowList = headItemRows.models,
    				headItemColList = headItemCols.models,
    				cellsPosition,
    				tempObj = {},
    				tempCell,
    				aliasCol,
    				aliasRow,
    				i;
    			if (endColIndex === undefined) {
    				endColIndex = startColIndex;
    			}
    			if (endRowIndex === undefined) {
    				endRowIndex = startRowIndex;
    			}
    			aliasRow = headItemRowList[endRowIndex].get('alias');
    			cellsPosition = cache.CellsPosition.strandY[aliasRow];
    
    			for (i = startColIndex; i < endColIndex + 1; i++) {
    				aliasCol = headItemColList[i].get('alias');
    				if (cellsPosition !== undefined && cellsPosition[aliasCol] !== undefined) {
    					if (!tempObj[cellsPosition[aliasCol]]) {
    						tempCell = this.models[cellsPosition[aliasCol]];
    					} else {
    						tempObj[cellsPosition[aliasCol]] = 1;
    						continue;
    					}
    				} else {
    					tempCell = this.createCellModel(i, endRowIndex);
    				}
    				fn(tempCell, headItemColList[i].get('sort'), headItemRowList[endRowIndex].get('sort'));
    			}
    		},
    		operOuterHeadModel: function(startColIndex, startRowIndex, endColIndex, endRowIndex, fn) {
    			this.operBottomHeadModel(startColIndex, startRowIndex, endColIndex, endRowIndex, fn);
    			this.operTopHeadModel(startColIndex, startRowIndex, endColIndex, endRowIndex, fn);
    			this.operLeftHeadModel(startColIndex, startRowIndex, endColIndex, endRowIndex, fn);
    			this.operRightHeadModel(startColIndex, startRowIndex, endColIndex, endRowIndex, fn);
    		},
    		
    		getAdjacent: function(currentModel, direction) {
    			var gridLineRowModelList,
    				gridLineColModelList,
    				modelIndexRow,
    				modelIndexCol,
    				modelCelllList,
    				modelJSON = currentModel.toJSON();
    
    			gridLineColModelList = headItemCols.models;
    			gridLineRowModelList = headItemRows.models;
    
    			//currentModel, direction models or null object
    
    			modelIndexRow = binary.modelBinary(modelJSON.physicsBox.top, gridLineRowModelList, 'top', 'height', 0, gridLineRowModelList.length - 1);
    			modelIndexCol = binary.modelBinary(modelJSON.physicsBox.left, gridLineColModelList, 'left', 'width', 0, gridLineColModelList.length - 1);
    			switch (direction) {
    				case 'LEFT':
    					modelCelllList = this.getSelectRegionCells(modelIndexCol - 1, modelIndexRow);
    					break;
    				case 'RIGHT':
    					modelCelllList = this.getSelectRegionCells(modelIndexCol + 1, modelIndexRow);
    					break;
    				case 'UP':
    					modelCelllList = this.getSelectRegionCells(modelIndexCol, modelIndexRow - 1);
    					break;
    				case 'DOWN':
    					modelCelllList = this.getSelectRegionCells(modelIndexCol, modelIndexRow + 1);
    					break;
    			}
    			return modelCelllList[0];
    		},
    		
    		getFillCellsByRegion: function(startIndexRow, startIndexCol, endIndexRow, endIndexCol) {
    			if (endIndexCol === undefined) {
    				endIndexCol = startIndexCol;
    			}
    			if (endIndexRow === undefined) {
    				endIndexRow = startIndexRow;
    			}
    			var cellList = [],
    				i = 0,
    				j = 0,
    				aliasCol,
    				aliasRow,
    				betweenRow = endIndexRow - startIndexRow + 1,
    				betweenCol = endIndexCol - startIndexCol + 1,
    				gridModelListRow = headItemRows.models,
    				gridModelListCol = headItemCols.models,
    				cellsPositionX = cache.CellsPosition.strandX;
    
    			for (; i < betweenRow; i++) {
    				for (j = 0; j < betweenCol; j++) {
    					aliasRow = gridModelListRow[startIndexRow + i].get('alias');
    					aliasCol = gridModelListCol[startIndexCol + j].get('alias');
    					if (cellsPositionX[aliasCol] !== undefined && cellsPositionX[aliasCol][aliasRow] !== undefined) {
    						cellList.push(this.models[cellsPositionX[aliasCol][aliasRow]]);
    					} else {
    						cellList.push(this.createCellModel(startIndexCol + j, startIndexRow + i));
    					}
    				}
    
    			}
    			return cellList;
    		},
    		
    		getInitCellBySelectRegion: function() {
    			var headLineColModelList,
    				headLineRowModelList,
    				modelSelectRegion,
    				modelJSON,
    				aliasRow,
    				aliasCol,
    				initCellIndex,
    				cellsPositionX;
    
    			modelSelectRegion = selectRegions.models[0];
    			modelJSON = modelSelectRegion.toJSON();
    
    			headLineColModelList = headItemCols.models;
    			headLineRowModelList = headItemRows.models;
    
    			aliasRow = headLineRowModelList[modelJSON.initPosi.startY].get('alias');
    			aliasCol = headLineColModelList[modelJSON.initPosi.startX].get('alias');
    
    			cellsPositionX = cache.CellsPosition.strandX;
    			if (cellsPositionX[aliasCol] === undefined || cellsPositionX[aliasCol][aliasRow] === undefined) {
    				initCellIndex = -1;
    			} else {
    				initCellIndex = cellsPositionX[aliasCol][aliasRow];
    			}
    			if (initCellIndex !== -1) {
    				return this.models[initCellIndex];
    			}
    			return null;
    		},
    		
    		getCellsByColIndex: function(startColIndex, endColIndex) {
    			return this.getCellByVertical(startColIndex, 0, endColIndex, 'MAX');
    		},
    		
    		getCellByAlias: function(aliasCol, aliasRow) {
    			var tempCellIndex;
    			if (cache.CellsPosition.strandY[aliasRow] === undefined ||
    				cache.CellsPosition.strandY[aliasRow][aliasCol] === undefined) {
    				return null;
    			}
    			tempCellIndex = cache.CellsPosition.strandY[aliasRow][aliasCol];
    			return this.models[tempCellIndex];
    		},
    		
    		getCellsInStartRowRegion: function(startRowIndex, endRowIndex) {
    			var tempRowObj,
    				tempAttr,
    				cacheCellArray,
    				cachePosition,
    				cellModelList,
    				aliasRow,
    				tempCell,
    				cellStartRowIndex,
    				i = 0;
    
    			cacheCellArray = [];
    			cellModelList = this.models;
    			cachePosition = cache.CellsPosition.strandY;
    
    			//遍历cache.CellsPosition中符合索引，生成cells[]集合
    			for (i = startRowIndex; i < endRowIndex + 1; i++) {
    
    				if (headItemRows.models[i] !== undefined) {
    					aliasRow = headItemRows.models[i].get('alias');
    					if (cachePosition[aliasRow] !== undefined) {
    						tempRowObj = cachePosition[aliasRow];
    						for (tempAttr in tempRowObj) {
    							//判断cell是否超出区域
    							tempCell = cellModelList[tempRowObj[tempAttr]];
    							cellStartRowIndex = headItemRows.getIndexByAlias(tempCell.get('occupy').y[0]);
    							if (cellStartRowIndex >= startRowIndex && cacheCellArray.indexOf(tempCell) === -1) {
    								cacheCellArray.push(tempCell);
    							}
    
    						}
    					}
    				}
    			}
    			return cacheCellArray;
    		},
    		
    		getCellsInStartColRegion: function(startColIndex, endColIndex) {
    			var tempColObj,
    				tempAttr,
    				cacheCellArray,
    				cachePosition,
    				cellModelList,
    				aliasCol,
    				tempCell,
    				cellStartColIndex,
    				i = 0;
    
    			cacheCellArray = [];
    			cellModelList = this.models;
    			cachePosition = cache.CellsPosition.strandX;
    
    			//遍历cache.CellsPosition中符合索引，生成cells[]集合
    			for (; i < endColIndex - startColIndex + 1; i++) {
    
    				if (headItemCols.models[startColIndex + i] !== undefined) {
    
    					aliasCol = headItemCols.models[startColIndex + i].get('alias');
    					if (cachePosition[aliasCol] !== undefined) {
    						tempColObj = cachePosition[aliasCol];
    						for (tempAttr in tempColObj) {
    							//判断cell是否超出区域
    							tempCell = cellModelList[tempColObj[tempAttr]];
    							cellStartColIndex = headItemCols.getIndexByAlias(tempCell.get('occupy').x[0]);
    							if (cellStartColIndex >= startColIndex && cacheCellArray.indexOf(tempCell) === -1) {
    								cacheCellArray.push(tempCell);
    							}
    
    						}
    					}
    				}
    			}
    			return cacheCellArray;
    		},
    		
    		oprCellsByRegion: function(region, fn, key, value) {
    			var tempCell,
    				headItemRowList = headItemRows.models,
    				headItemColList = headItemCols.models,
    				cellsPositionX = cache.CellsPosition.strandX,
    				startColIndex = region.startColIndex,
    				startRowIndex = region.startRowIndex,
    				endColIndex = region.endColIndex,
    				endRowIndex = region.endRowIndex,
    				rowLen,
    				colLen,
    				aliasRow,
    				aliasCol,
    				i = 0,
    				j;
    			if (endColIndex === undefined || endColIndex === null) {
    				endColIndex = startColIndex;
    			}
    			if (endRowIndex === undefined || endRowIndex === null) {
    				endRowIndex = startRowIndex;
    			}
    			colLen = endColIndex - startColIndex;
    			rowLen = endRowIndex - startRowIndex;
    			for (; i < rowLen + 1; i++) {
    				for (j = 0; j < colLen + 1; j++) {
    					aliasRow = headItemRowList[startRowIndex + i].get('alias');
    					aliasCol = headItemColList[startColIndex + j].get('alias');
    					if (cellsPositionX[aliasCol] !== undefined && cellsPositionX[aliasCol][aliasRow] !== undefined) {
    						tempCell = this.models[cellsPositionX[aliasCol][aliasRow]];
    					} else {
    						tempCell = this.createCellModel(startColIndex + j, startRowIndex + i);
    					}
    					fn(tempCell, headItemColList[startColIndex + j].get('sort'), headItemRowList[startRowIndex + i].get('sort'), key, value);
    				}
    			}
    		},
    		
    		getFullOperationRegion: function(startColIndex, startRowIndex, endColIndex, endRowIndex) {
    			var cellList,
    				cellStartColIndex,
    				cellStartRowIndex,
    				cellEndColIndex,
    				cellEndRowIndex,
    				temp,
    				flag = true,
    				i, len;
    
    			endColIndex = endColIndex !== undefined ? endColIndex : startColIndex;
    			endRowIndex = endRowIndex !== undefined ? endRowIndex : startRowIndex;
    			if (startColIndex === 'MAX' || endColIndex === 'MAX') {
    				if (startRowIndex > endRowIndex) {
    					temp = startRowIndex;
    					startRowIndex = endRowIndex;
    					endRowIndex = temp;
    				}
    				return {
    					startRowIndex: startRowIndex,
    					startColIndex: 0,
    					endRowIndex: endRowIndex,
    					endColIndex: headItemCols.length - 1
    				};
    			}
    			if (startRowIndex === 'MAX' || endRowIndex === 'MAX') {
    				if (startColIndex > endColIndex) {
    					temp = startColIndex;
    					startColIndex = endColIndex;
    					endColIndex = temp;
    				}
    				return {
    					startRowIndex: 0,
    					startColIndex: startColIndex,
    					endColIndex: endColIndex,
    					endRowIndex: headItemRows.length - 1
    				};
    			}
    			if (startColIndex > endColIndex) {
    				temp = startColIndex;
    				startColIndex = endColIndex;
    				endColIndex = temp;
    			}
    			if (startRowIndex > endRowIndex) {
    				temp = startRowIndex;
    				startRowIndex = endRowIndex;
    				endRowIndex = temp;
    			}
    
    			while (flag) {
    				flag = false;
    				cellList = this.getCellByVertical(startColIndex, startRowIndex, endColIndex, endRowIndex);
    
    				for (i = 0, len = cellList.length; i < len; i++) {
    					temp = cellList[i].get('physicsBox');
    					cellStartRowIndex = binary.modelBinary(temp.top, rowList, 'top', 'height');
    					cellStartColIndex = binary.modelBinary(temp.left, colList, 'left', 'width');
    					cellEndRowIndex = binary.modelBinary(temp.top + temp.height, rowList, 'top', 'height');
    					cellEndColIndex = binary.modelBinary(temp.left + temp.width, colList, 'left', 'width');
    					if (cellStartColIndex < startColIndex) {
    						startColIndex = cellStartColIndex;
    						flag = true;
    					}
    					if (cellStartRowIndex < startRowIndex) {
    						startRowIndex = cellStartRowIndex;
    						flag = true;
    					}
    					if (cellEndRowIndex > endRowIndex) {
    						endRowIndex = cellEndRowIndex;
    						flag = true;
    					}
    					if (cellEndColIndex > endColIndex) {
    						endColIndex = cellEndColIndex;
    						flag = true;
    					}
    				}
    			}
    			return {
    				startRowIndex: startRowIndex,
    				startColIndex: startColIndex,
    				endRowIndex: endRowIndex,
    				endColIndex: endColIndex
    			};
    		},
    	});
    	return new Cells();
    });
    
    define('basic/tools/strandmap',function() {
    	var colPos = {},
    		rowPos = {},
    		operate,
    		max = 'MAX';
    
    	operate = {
    		
    		addPointRecord: function(colAlias, rowAlias, type, value) {
    			this._addPointRecord(colAlias, rowAlias, colPos, type, value);
    			this._addPointRecord(rowAlias, colAlias, rowPos, type, value);
    		},
    		getPointRecord: function(colAlias, rowAlias, type) {
    			var temp;
    			if (colPos[colAlias] && (temp = colPos[colAlias][rowAlias])) {
    				if (typeof type !== 'undefined' && typeof temp[type] !== 'undefined') {
    					return temp[type];
    				} else {
    					return temp;
    				}
    			}
    			return;
    		},
    		deletePointRecord: function(colAlias, rowAlias, type) {
    			var temp;
    			if (type) {
    				if (colPos[colAlias] && (temp = colPos[colAlias][rowAlias])) {
    					delete temp[type];
    					temp = rowPos[rowAlias][colAlias];
    					delete temp[type];
    				}
    			} else {
    				if (temp = colPos[colAlias]) {
    					delete temp[rowAlias];
    				}
    				if (temp = rowPos[rowAlias]) {
    					delete temp[colAlias];
    				}
    			}
    		},
    
    		
    		calcPointRecord: function(colAlias, rowAlias, type) {
    			var temp;
    			if (colPos[colAlias] && (temp = colPos[colAlias][rowAlias])) {
    				if (typeof temp[type] !== 'undefined') {
    					return temp[type];
    				}
    			}
    			if (colPos[colAlias] && (temp = colPos[colAlias][max])) {
    				if (typeof temp[type] !== 'undefined') {
    					return temp[type];
    				}
    			}
    			if (rowPos[rowAlias] && (temp = rowPos[rowAlias][max])) {
    				if (typeof temp[type] !== 'undefined') {
    					return temp[type];
    				}
    			}
    			return;
    		},
    		getVerticalRecord: function(colAlias, type) {
    			var result = [],
    				key,
    				temp;
    
    			if ((temp = colPos[colAlias])) {
    				for (key in temp) {
    					if (temp[key] !== undefined && temp[key][type] !== undefined) {
    						result.push(temp[key][type]);
    					}
    				}
    			}
    			return result;
    		},
    		getTransverseRecord: function(rowAlias, type) {
    			var result = [],
    				key,
    				temp;
    
    			if ((temp = rowPos[rowAlias])) {
    				for (key in temp) {
    					if (temp[key] !== undefined && temp[key][type] !== undefined) {
    						result.push(temp[key][type]);
    					}
    				}
    			}
    			return result;
    		},
    		addColRecord: function(colAlias, type, value) {
    			this._addRecord(colAlias, colPos, rowPos, type, value);
    		},
    		addRowRecord: function(rowAlias, type, value) {
    			this._addRecord(rowAlias, rowPos, colPos, type, value);
    		},
    		getColRecord: function(colAlias, type) {
    			return this._getRecord(colAlias, colPos, type);
    		},
    		getRowRecord: function(rowAlias, type) {
    			return this._getRecord(rowAlias, rowPos, type);
    		},
    		insertRowUpdateRecord: function(rowIndex) {
    			this._insert(rowPos, rowIndex);
    		},
    		insertColUpdateRecord: function(colIndex) {
    			this._insert(colPos, colIndex);
    		},
    		_addPointRecord: function(alias, reverseAlias, pos, type, value) {
    			var temp;
    
    			if (typeof value === 'undefined') {
    				value = type;
    				type = null;
    			}
    			if (!pos[alias]) {
    				pos[alias] = {};
    			}
    			if (type) {
    				if (!pos[alias][reverseAlias]) {
    					temp = pos[alias][reverseAlias] = {};
    				} else {
    					temp = pos[alias][reverseAlias];
    				}
    				temp[type] = value;
    			} else {
    				pos[alias][reverseAlias] = value;
    			}
    		},
    		_insert: function(pos, index) {
    			var temp, key;
    			for (key in pos) {
    				if (temp = pos[key][max] && temp[index] >= index) {
    					temp[index]++;
    				}
    			}
    		},
    		_getRecord: function(alias, pos, type) {
    			var temp;
    			if (!pos[alias] || !(temp = pos[alias][max]) ||
    				typeof(temp = temp[type]) === undefined) {
    				return;
    			}
    			return temp;
    		},
    		_getRecordList: function(pos, type) {
    			var temp,
    				result = {},
    				key;
    			for (key in pos) {
    				if ((temp = pos[key][max]) && temp[type]) {
    					result[key] = temp[type];
    				}
    			}
    			return result;
    		},
    		_addRecord: function(alias, pos, reversePos, type, value) {
    			var temp,
    				recordList,
    				reverseAlias;
    			if (!pos[alias]) {
    				pos[alias] = {};
    			}
    			if (!pos[alias][max]) {
    				temp = pos[alias][max] = {};
    			} else {
    				temp = pos[alias][max];
    			}
    
    			recordList = this._getRecordList(reversePos, type);
    			for (reverseAlias in recordList) {
    				this._addPointRecord(alias, reverseAlias, pos, type, value);
    				this._addPointRecord(reverseAlias, alias, reversePos, type, value);
    			}
    
    			for (reverseAlias in pos[alias]) {
    				if (reverseAlias !== max) {
    					this._addPointRecord(alias, reverseAlias, pos, type, value);
    					this._addPointRecord(reverseAlias, alias, reversePos, type, value);
    				}
    			}
    			temp[type] = value;
    		}
    	};
    	return operate;
    });
    define('basic/tools/original',function() {
    	
    	var $ = require('lib/jquery'),
    		config = require('spreadsheet/config'),
    		binary = require('basic/util/binary'),
    		cache = require('basic/tools/cache'),
    		send = require('basic/tools/send'),
    		text2sort = require('basic/tools/text2sort'),
    		loadRecorder = require('basic/tools/loadrecorder'),
    		getDisplayName = require('basic/tools/getdisplayname'),
    		headItemCols = require('collections/headItemCol'),
    		headItemRows = require('collections/headItemRow'),
    		siderLineCols = require('collections/siderLineCol'),
    		siderLineRows = require('collections/siderLineRow'),
    		selectRegions = require('collections/selectRegion'),
    		sheets = require('collections/sheets'),
    		cells = require('collections/cells'),
    		strandMap = require('basic/tools/strandmap'),
    		headItemColList = headItemCols.models,
    		headItemRowList = headItemRows.models;
    
    	
    	return {
    		
    		bulidNewExcel: function() {
    			var i,
    				j,
    				lenCol,
    				lenRow,
    				currentObject;
    			lenCol = config.User.initColNum;
    			lenRow = config.User.initRowNum;
    
    			for (i = 0; i < lenCol; i++) {
    				currentObject = {
    					sort: i,
    					alias: (i + 1).toString(),
    					left: i * config.User.cellWidth,
    					width: config.User.cellWidth - 1,
    					displayName: getDisplayName.getColDisplayName(i)
    				};
    				headItemCols.add(currentObject);
    			}
    			for (j = 0; j < lenRow; j++) {
    				currentObject = {
    					sort: j,
    					alias: (j + 1).toString(),
    					top: j * config.User.cellHeight,
    					height: config.User.cellHeight - 1,
    					displayName: getDisplayName.getRowDisplayName(j)
    				};
    				headItemRows.add(currentObject);
    			}
    			this.restoreSelectRegion();
    		},
    		
    		analysisRowData: function(rows, startRowSort) {
    			var tempHeadRow,
    				index, //插入Rows中的索引值
    				i;
    			for (i = 0; i < rows.length; i++) {
    				index = binary.indexModelBinary(rows[i].top, headItemRows.models, 'top', 'height');
    				//待修改：判定是否已存在加载类，应使用二分查询进行判定
    				if (headItemRows.getIndexByAlias(rows[i].aliasY) !== -1) {
    					index++;
    					continue;
    				}
    				tempHeadRow = {
    					sort: startRowSort + i,
    					top: rows[i].top,
    					height: rows[i].height,
    					alias: rows[i].aliasY,
    					operProp: rows[i].operProp,
    					displayName: getDisplayName.getRowDisplayName(startRowSort + i)
    				};
    				headItemRows.push(tempHeadRow, {
    					at: index
    				});
    			}
    
    		},
    		
    		analysisColData: function(cols, startColSort) {
    
    			//隐藏列还原
    			var tempHeadCol, i, j, len, collen;
    			for (i = 0; i < cols.length; i++) {
    				//待修改：判定是否已存在加载类，应使用二分查询进行判定
    				if (headItemCols.getIndexByAlias(cols[i].aliasY) !== -1) {
    					continue;
    				}
    				tempHeadCol = {
    					sort: startColSort + i,
    					left: cols[i].left,
    					width: cols[i].width,
    					alias: cols[i].aliasX,
    					hidden: cols[i].hidden,
    					originalWidth: cols[i].originWidth,
    					operProp: {}
    				};
    				if (!isEmptyObject(cols[i].operProp.content)) {
    					tempHeadCol.operProp.content = cols[i].operProp.content;
    				}
    				if (!isEmptyObject(cols[i].operProp.customProp)) {
    					tempHeadCol.operProp.customProp = cols[i].operProp.customProp;
    				}
    				if (!isEmptyObject(cols[i].operProp.border)) {
    					tempHeadCol.operProp.border = cols[i].operProp.border;
    				}
    				tempHeadCol.displayName = getDisplayName.getColDisplayName(startColSort + i);
    				if (cols[i].hidden && i > 0) {
    					headItemCols.models[i - 1].set('isRightAjacentHide', true);
    				}
    				if (i > 0 && cols[i - 1].hidden) {
    					tempHeadCol.isLeftAjacentHide = true;
    				}
    				headItemCols.add(tempHeadCol);
    			}
    
    
    			if (headItemCols.length < config.User.initColNum) {
    				len = config.User.initColNum - headItemCols.length;
    				collen = headItemCols.length;
    				for (j = 0; j < len; j++) {
    					tempHeadCol = {
    						sort: collen + j,
    						left: headItemCols.models[collen + j - 1].get('left') + headItemCols.models[collen + j - 1].get('width') + 1,
    						width: config.User.cellWidth,
    						alias: (headItemCols.length + 1).toString(),
    						displayName: getDisplayName.getColDisplayName(collen + j),
    					};
    					headItemCols.add(tempHeadCol);
    				}
    			}
    
    			function isEmptyObject(obj) {
    				var prop;
    				for (prop in obj) {
    					return false;
    				}
    				return true;
    			}
    		},
    		
    		analysisCellData: function(cellsData) {
    			var j, k, //循环变量
    				tempCell = null,
    				limitRowIndex = headItemRows.length - 1,
    				cellAttributes, //cell模型属性 
    				physicsBox = {},
    				gridAliasColList, //cell列索引list
    				gridAliasRowList, //cell行索引list
    				cellStartRowIndex, //cell起始row索引
    				cellStartColIndex, //cell起始col索引
    				cellEndRowIndex, //cell结束row索引
    				cellEndColIndex, //cell结束row索引
    				cellsPositionX = cache.CellsPosition.strandX,
    				colSort, rowSort,
    				width = 0,
    				height = 0,
    				i,
    				model; //gridrow加载数量
    
    
    			//解析cell
    			for (i = 0; i < cellsData.length; i++) {
    				cellAttributes = cellsData[i];
    				if (cellAttributes === null) {
    					continue;
    				}
    
    				gridAliasColList = cellAttributes.occupy.x;
    				gridAliasRowList = cellAttributes.occupy.y;
    				colSort = cellAttributes.occupy.col;
    				rowSort = cellAttributes.occupy.row;
    				delete cellAttributes.occupy.col;
    				delete cellAttributes.occupy.row;
    
    				cellStartRowIndex = binary.indexAttrBinary(rowSort, headItemRowList, 'sort');
    				cellEndRowIndex = cellStartRowIndex + gridAliasRowList.length - 1;
    				if (cellEndRowIndex > limitRowIndex) {
    					cellEndRowIndex = limitRowIndex;
    				}
    				if (cellStartRowIndex === -1) {
    					continue;
    				}
    				cellStartColIndex = binary.indexAttrBinary(colSort, headItemColList, 'sort');
    				cellEndColIndex = cellStartColIndex + gridAliasColList.length - 1;
    
    				//判断cell模型是否已加载
    				if (cellsPositionX[gridAliasColList[0]] &&
    					cellsPositionX[gridAliasColList[0]][gridAliasRowList[0]] !== undefined) {
    					tempCell = cells.models[cellsPositionX[gridAliasColList[0]][gridAliasRowList[0]]];
    				}
    
    				//计算cell模型宽高
    				for (j = cellStartColIndex; j < cellEndColIndex + 1; j++) {
    					model = headItemColList[j];
    					if (!model.get('hidden')) {
    						width += model.get('width') + 1;
    					}
    				}
    				for (j = cellStartRowIndex; j < cellEndRowIndex + 1; j++) {
    					model = headItemRowList[j];
    					height += model.get('height') + 1;
    				}
    				physicsBox = {
    					top: headItemRowList[cellStartRowIndex].get('top'),
    					left: headItemColList[cellStartColIndex].get('left'),
    					width: width - 1,
    					height: height - 1
    				};
    				if (tempCell !== null) {
    					//重新渲染cell模型宽高
    					tempCell.set('physicsBox', physicsBox);
    				} else {
    					cellAttributes.physicsBox = physicsBox;
    					cells.add(cellAttributes);
    					//维护postion
    					for (j = 0; j < gridAliasColList.length; j++) {
    						for (k = 0; k < gridAliasRowList.length; k++) {
    							cache.cachePosition(gridAliasRowList[k], gridAliasColList[j], cells.length - 1);
    						}
    					}
    				}
    				tempCell = null;
    				width = 0;
    				height = 0;
    			}
    		},
    		analysisSheetData: function(sheetsData) {
    			var i;
    			for (i = 0; i < sheetsData.length; i++) {
    				sheets.add({
    					name: sheetsData[i],
    					sort: i
    				});
    			}
    		},
    		
    		restoreSelectRegion: function() {
    			var headItemRowModel,
    				headItemColModel,
    				rowAlias,
    				colAlias,
    				colIndex,
    				endRowAlias,
    				endColAlias,
    				endColIndex,
    				endRowIndex,
    				startColIndex,
    				startRowIndex,
    				cellsPositionX,
    				cell,
    				len, i,
    				selectRegionModel;
    
    			rowAlias = cache.UserView.rowAlias;
    			colAlias = cache.UserView.colAlias;
    
    			headItemRowModel = headItemRows.getModelByAlias(rowAlias);
    			colIndex = headItemCols.getIndexByAlias(colAlias);
    
    
    			headItemColModel = headItemCols.models[colIndex];
    
    			len = headItemCols.length;
    			for (i = colIndex; i < len; i++) {
    				if (headItemColModel.get('hidden')) {
    					headItemColModel = headItemCols.models[++colIndex];
    					colAlias = headItemColModel.get('alias');
    				} else {
    					break;
    				}
    			}
    
    			cellsPositionX = cache.CellsPosition.strandX;
    
    			if (cellsPositionX[colAlias] !== undefined &&
    				cellsPositionX[colAlias][rowAlias] !== undefined) {
    				cell = cells.models[cellsPositionX[colAlias][rowAlias]];
    			}
    			if (cell !== undefined) {
    				endRowAlias = cell.get('occupy').y;
    				endRowAlias = endRowAlias[endRowAlias.length - 1];
    				endColAlias = cell.get('occupy').x;
    				endColAlias = endColAlias[endColAlias.length - 1];
    
    				endColIndex = headItemCols.getIndexByAlias(endColAlias);
    				endRowIndex = headItemRows.getIndexByAlias(endRowAlias);
    				startColIndex = headItemCols.getIndexByAlias(colAlias);
    				startRowIndex = headItemRows.getIndexByAlias(rowAlias);
    
    				selectRegionModel = {
    					physicsBox: {
    						top: cell.get('physicsBox').top,
    						left: cell.get('physicsBox').left,
    						width: cell.get('physicsBox').width,
    						height: cell.get('physicsBox').height
    					},
    					wholePosi: {
    						startX: colAlias,
    						startY: rowAlias,
    						endX: endColAlias,
    						endY: endRowAlias
    					}
    				};
    				selectRegions.add(selectRegionModel);
    				siderLineCols.add({
    					left: cell.get('physicsBox').left,
    					width: cell.get('physicsBox').width
    				});
    				siderLineRows.add({
    					top: cell.get('physicsBox').top,
    					height: cell.get('physicsBox').height
    				});
    
    
    				len = headItemRows.length;
    
    				for (i = 0; i < len; i++) {
    					headItemRows.models[i].set({
    						activeState: false
    					});
    				}
    
    				len = headItemCols.length;
    				for (i = 0; i < len; i++) {
    					headItemCols.models[i].set({
    						activeState: false
    					});
    				}
    				for (i = 0; i < endColIndex - startColIndex + 1; i++) {
    					headItemCols.models[startColIndex + i].set({
    						activeState: true
    					});
    				}
    				for (i = 0; i < endRowIndex - startRowIndex + 1; i++) {
    					headItemRows.models[startRowIndex + i].set({
    						activeState: true
    					});
    				}
    			} else {
    				selectRegionModel = {
    					physicsBox: {
    						width: headItemColModel.get('width'),
    						height: headItemRowModel.get('height'),
    						top: headItemRowModel.get('top'),
    						left: headItemColModel.get('left')
    					},
    					wholePosi: {
    						startX: colAlias,
    						startY: rowAlias,
    						endX: colAlias,
    						endY: rowAlias
    					}
    				};
    				selectRegions.add(selectRegionModel);
    				siderLineCols.add({
    					left: headItemColModel.get('left'),
    					width: headItemColModel.get('width')
    				});
    				siderLineRows.add({
    					top: headItemRowModel.get('top'),
    					height: headItemRowModel.get('height')
    				});
    			}
    
    		},
    		analysisValidateRule: function(rules) {
    			var currentRule,
    				formula1,
    				ranges,
    				rule,
    				ruleIndex,
    				startRow,
    				startCol,
    				endRow,
    				endCol,
    				i, j, k, h,
    				len1, len2;
    
    			if (!(rules instanceof Array)) {
    				rules = [rules];
    			}
    
    			for (i = 0, len1 = rules.length; i < len1; i++) {
    				currentRule = rules[i];
    				rule = {};
    				ranges = currentRule.coordinate || [];
    				rule.validationType = currentRule.rule.validationType;
    				formula1 = rule.formula1 = currentRule.rule.formula1;
    				rule.formula2 = currentRule.rule.formula2;
    				ruleIndex = currentRule.rule.index;
    				startRow,
    				startCol,
    				endRow,
    				endCol;
    
    
    				for (j = 0, len2 = ranges.length; j < len2; j++) {
    					startCol = ranges[j].startCol;
    					startRow = ranges[j].startRow;
    					endCol = ranges[j].endCol;
    					endRow = ranges[j].endRow;
    					if (endRow === -1) {
    						for (k = startCol; k < endCol + 1; k++) {
    							strandMap.addColRecord((k + 1).toString(), 'validate', ruleIndex);
    						}
    					} else if (endCol === -1) {
    						for (k = startRow; k < endRow + 1; k++) {
    							strandMap.addRowRecord((k + 1).toString(), 'validate', ruleIndex);
    						}
    					} else {
    						for (k = startCol; k < endCol + 1; k++) {
    							for (h = startRow; h < endRow + 1; h++) {
    								strandMap.addPointRecord((k + 1).toString(), (h + 1).toString(), 'validate', ruleIndex);
    							}
    						}
    					}
    				}
    				if (typeof cache.validate[ruleIndex] === 'undefined') {
    					if (rule.validationType === config.validationType.sequenceType) {
    						this.insertSequenceRule(rule, ruleIndex);
    					} else {
    						cache.validate[ruleIndex] = rule;
    					}
    				}
    			}
    		},
    		insertSequenceRule: function(rule, ruleIndex) {
    			var sourceRegion,
    				startRowAlias,
    				endRowAlias,
    				startColAlias,
    				endColAlias;
    
    			if (rule.formula1.indexOf('=') !== 0) {
    				cache.validate[ruleIndex] = rule;
    				return;
    			}
    			sourceRegion = text2sort(rule.formula1);
    			startRowAlias = headItemRows.getAliasBySort(sourceRegion.startRowSort);
    			endRowAlias = headItemRows.getAliasBySort(sourceRegion.endRowSort);
    			startColAlias = headItemCols.getAliasBySort(sourceRegion.startColSort);
    			endColAlias = headItemCols.getAliasBySort(sourceRegion.endColSort);
    
    			if (startRowAlias !== -1 && endRowAlias !== -1 &&
    				startColAlias !== -1 && endColAlias !== -1 &&
    				endColAlias !== 'MAX' && endRowAlias !== 'MAX') {
    				rule.formula1 = {
    					startRowAlias: startRowAlias,
    					endRowAlias: endRowAlias,
    					startColAlias: startColAlias,
    					endColAlias: endColAlias
    				};
    				cache.validate[ruleIndex] = rule;
    			}
    		},
    		
    		restoreExcel: function(domId) {
    			var build = window.SPREADSHEET_BUILD_STATE,
    				startRowSort,
    				startColSort,
    				sheetNames = [],
    				self = this;
    
    			if (build === 'true' || build === undefined) {
    				this.bulidNewExcel();
    				cache.localRowPosi = 0;
    				return;
    			}
    
    			//containerHeight,通知后台,加载高度
    			send.PackAjax({
    				url: config.url.table.reload,
    				async: false,
    				isPublic: false,
    				data: JSON.stringify({
    					top: 0,
    					bottom: $('#' + domId).height() + config.System.prestrainHeight
    				}),
    				dataType: 'json',
    				success: function() {
    					fillData.apply(this, arguments);
    				}
    			});
    
    			function fillData(data) {
    				var sheetData,
    					headItemColList,
    					headItemRowList,
    					colLen,
    					rowLen;
    
    				if (!data) {
    					return;
    				}
    
    				if (!data.returndata) {
    					return;
    				}
    				cache.UserView.rowAlias = data.displayRowStartAlias;
    				cache.UserView.colAlias = data.displayColStartAlias;
    				cache.protectState = data.protect;
    				startRowSort = data.dataRowStartIndex;
    				startColSort = data.dataColStartIndex;
    
    				cache.localRowPosi = data.maxPixel;
    
    				cache.aliasRowCounter = data.aliasRowCounter;
    				cache.aliasColCounter = data.aliasColCounter;
    
    				data = data.returndata;
    
    
    
    				if (data.spreadSheet && data.spreadSheet[0] &&
    					(sheetData = data.spreadSheet[0].sheet)) {
    
    
    					sheetNames.push(data.spreadSheet[0].name);
    
    					var cellModels = sheetData.cells;
    					var rows = sheetData.glY;
    					var cols = sheetData.glX;
    
    					self.analysisSheetData(sheetNames);
    					self.analysisRowData(rows, startRowSort);
    					self.analysisColData(cols, startColSort);
    					self.analysisCellData(cellModels);
    					self.restoreSelectRegion();
    					self.analysisValidateRule(data.spreadSheet[0].validate.rules);
    					cache.validateCounter = data.spreadSheet[0].validate.total;
    					headItemColList = headItemCols.models;
    					headItemRowList = headItemRows.models;
    
    					cache.TempProp.colAlias = headItemColList[0].get('alias');
    					cache.TempProp.rowAlias = headItemRowList[0].get('alias');
    					colLen = headItemCols.length;
    					rowLen = headItemRows.length;
    
    					loadRecorder.insertPosi(headItemRowList[0].get('top'),
    						headItemRowList[rowLen - 1].get('top') + headItemRowList[rowLen - 1].get('height'),
    						cache.rowRegionPosi);
    					loadRecorder.insertPosi(headItemRowList[0].get('top'),
    						headItemRowList[rowLen - 1].get('top') + headItemRowList[rowLen - 1].get('height'),
    						cache.cellRegionPosi.vertical);
    				}
    			}
    		}
    	};
    });
    
    define('basic/util/listener',function() {
    	var cache = require('basic/tools/cache'),
    		listenerList = cache.listenerList,
    		listener;
    
    	listener = {
    		addEventListener: function(event, callback) {
    			var key;
    			if (event.indexOf('on') !== 0) {
    				event = 'on' + event;
    			}
    
    			listenerList = listenerList || {};
    			listenerList[event] = listenerList[event] || {};
    
    			if (callback.listener === undefined) {
    				callback.listener = [];
    			}
    			if (typeof callback === 'function') {
    				key = Object.getOwnPropertyNames(listenerList[event]).length;
    				callback.listener.push(key);
    				listenerList[event][key] = callback;
    			}
    		},
    		removeEventListener: function(event, callback) {
    			if (event.indexOf('on') !== 0) {
    				event = 'on' + event;
    			}
    			if (callback === undefined) {
    				delete listenerList[event];
    				return;
    			}
    			if (callback.listener !== undefined && listenerList[event] !== undefined) {
    				for (var key in callback.listener) {
    					if (listenerList[event][key] !== undefined) {
    						delete listenerList[event][key];
    					}
    				}
    			}
    
    		},
    		excute: function(event, e) {
    			if (event.indexOf('on') !== 0) {
    				event = 'on' + event;
    			}
    			if (listenerList[event] !== undefined) {
    				for (var i in listenerList[event]) {
    					listenerList[event][i](e);
    				}
    			}
    		}
    	};
    	return listener;
    });
    
    define('basic/tools/parselabel',function() {
    	
    	var analysisLabel = function(regionLabel) {
    		var temp,
    			reg = /^[A-Z]+[1-9]+[0-9]*$/,
    			startColSort, //后台Excel对象存储的正确索引值
    			endColSort,
    			startRowSort,
    			endRowSort,
    			startColDisplayName,
    			startRowDisplayName,
    			endColDisplayName,
    			endRowDisplayName;
    
    
    		//解析
    		if (regionLabel instanceof Array) {
    			//判断数组长度
    			if (regionLabel.length !== 2) {
    				throw new Error('Parameter format error');
    			}
    			//匹配数据格式
    			if (!reg.test(regionLabel[0]) && !reg.test(regionLabel[1])) {
    				throw new Error('Parameter format error');
    			}
    
    			startColDisplayName = getDisplayName(regionLabel[0], 'col');
    			startRowDisplayName = getDisplayName(regionLabel[0], 'row');
    			endColDisplayName = getDisplayName(regionLabel[1], 'col');
    			endRowDisplayName = getDisplayName(regionLabel[1], 'row');
    
    			startColSort = colSignToSort(startColDisplayName);
    			endColSort = colSignToSort(endColDisplayName);
    			startRowSort = rowSignToSort(startRowDisplayName);
    			endRowSort = rowSignToSort(endRowDisplayName);
    
    		} else if (/^[A-Z]+$/.test(regionLabel)) { //整列操作
    			startRowSort = 0;
    			endRowSort = -1;
    			startColSort = endColSort = colSignToSort(regionLabel);
    
    		} else if (/^[1-9]+[0-9]*$/.test(regionLabel)) { //整行操作
    			startColSort = 0;
    			endColSort = -1;
    			startRowSort = endRowSort = rowSignToSort(regionLabel);
    
    		} else if (reg.test(regionLabel)) {
    			startRowDisplayName = getDisplayName(regionLabel, 'row');
    			startColDisplayName = getDisplayName(regionLabel, 'col');
    			startColSort = endColSort = colSignToSort(startColDisplayName);
    			startRowSort = endRowSort = rowSignToSort(startRowDisplayName);
    		} else {
    			throw new Error('Parameter format error');
    		}
    		//交换位置
    
    		if (startRowSort > endRowSort && endRowSort !== -1) {
    			temp = startRowSort;
    			startRowSort = endRowSort;
    			endRowSort = temp;
    		}
    		if (startColSort > endColSort && endColSort !== -1) {
    			temp = startColSort;
    			startColSort = endRowSort;
    			endRowSort = temp;
    		}
    		return {
    			startRowSort: startRowSort,
    			endRowSort: endRowSort,
    			startColSort: startColSort,
    			endColSort: endColSort
    		};
    
    		function getDisplayName(regionLabel, lineType) {
    			var result = '',
    				len = 0;
    			if (/[A-Z]/i.test(regionLabel)) {
    				len = regionLabel.match(/[A-Z]/ig).length;
    			}
    			if (lineType === 'col') {
    				result = regionLabel.substring(0, len);
    			} else if (lineType === 'row') {
    				result = regionLabel.substring(len);
    			}
    			return result;
    		}
    
    		function colSignToSort(sign) {
    			var i = 0,
    				sort = 0,
    				len = sign.length,
    				letter = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'],
    				index;
    
    			if (sign === 'MAX') {
    				return 'MAX';
    			}
    			for (; i < len; i++) {
    				index = letter.indexOf(sign[i]) + 1;
    				sort += index * (Math.pow(26, (len - i - 1)));
    			}
    			return sort - 1;
    		}
    
    		function rowSignToSort(sign) {
    			if (sign === 'MAX') {
    				return 'MAX';
    			}
    			return parseInt(sign) - 1;
    		}
    	};
    	return analysisLabel;
    });
    
    define('basic/tools/getoperregion',function() {
    	var binary = require('basic/util/binary'),
    		parseLabel = require('basic/tools/parselabel'),
    		cols = require('collections/headItemCol'),
    		rows = require('collections/headItemRow'),
    		selects = require('collections/selectRegion'),
    		getOperRegion;
    	
    	getOperRegion = function(label) {
    		var select,
    			region,
    			wholePosi,
    			startRowIndex,
    			startColIndex,
    			endRowIndex,
    			endColIndex,
    			startRowSort,
    			startColSort,
    			endRowSort,
    			endColSort,
    			colList = cols.models,
    			rowList = rows.models;
    
    		if (!label) {
    			select = selects.getModelByType('selected');
    			wholePosi = select.get('wholePosi');
    			startColIndex = cols.getIndexByAlias(wholePosi.startX);
    			endColIndex = cols.getIndexByAlias(wholePosi.endX);
    			startRowIndex = rows.getIndexByAlias(wholePosi.startY);
    			endRowIndex = rows.getIndexByAlias(wholePosi.endY);
    
    			startColSort = colList[startColIndex].get('sort');
    			startRowSort = rowList[startRowIndex].get('sort');
    
    			if (endRowIndex === 'MAX') {
    				endRowSort = -1;
    			} else {
    				endRowSort = rowList[endRowIndex].get('sort');
    			}
    			if (endColIndex === 'MAX') {
    				endColSort = -1;
    			} else {
    				endColSort = colList[endColIndex].get('sort');
    			}
    		} else {
    			region = parseLabel(label);
    			startColSort = region.startColSort;
    			startRowSort = region.startRowSort;
    			endRowSort = region.endRowSort;
    			endColSort = region.endColSort;
    
    			startColIndex = binary.indexAttrBinary(startColSort, colList, 'sort');
    			startRowIndex = binary.indexAttrBinary(startRowSort, rowList, 'sort');
    
    			if (endColSort !== -1) {
    				endColIndex = binary.indexAttrBinary(endColSort, colList, 'sort');
    			} else {
    				endColIndex = 'MAX';
    			}
    			if (endRowSort !== -1) {
    				endRowIndex = binary.indexAttrBinary(endRowSort, rowList, 'sort');
    			} else {
    				endRowIndex = 'MAX';
    			}
    
    			//备注：excel暂时只由顶端起始向下加载，所以只判断结尾坐标是否加载
    			//开始坐标，由调用方法进行判断，开始坐标未加载，不进行内部操作，只向后台发送请求
    			if (endRowIndex === -1) {
    				endRowIndex = rows.length - 1;
    			}
    			if (endColIndex === -1) {
    				endColIndex = cols.length - 1;
    			}
    		}
    
    		return {
    			sendRegion: {
    				startCol: startColSort,
    				endCol: endColSort,
    				startRow: startRowSort,
    				endRow: endRowSort
    			},
    			operRegion: {
    				startColIndex: startColIndex,
    				startRowIndex: startRowIndex,
    				endRowIndex: endRowIndex,
    				endColIndex: endColIndex
    			}
    		};
    	};
    	return getOperRegion;
    });
    
    define('basic/tools/history',function() {
    	var historyList = [],
    		historyIndex = -1,
    		history;
    
    	history = {
    		next: function() {
    			if (historyIndex === historyList.length - 1) {
    				return false;
    			}
    			return historyList[++historyIndex];
    		},
    		previous: function() {
    			var result;
    			if (historyList.length === 0) {
    				return false;
    			}
    			result = historyList[historyIndex--];
    			return result;
    		},
    		addAction: function(obj) {
    			historyList = historyList.slice(0, historyIndex + 1);
    			historyList.push(obj);
    			historyIndex = historyList.length - 1;
    		},
    		
    		getCellPropUpdateAction: function(propName, propValue, region, originalData) {
    			return {
    				region: region,
    				type: 'updateCellProp',
    				propName: propName,
    				propValue: propValue,
    				originalData: originalData
    			};
    		},
    		
    		getCellCoverAction: function(currentModelIndexs, originalModelIndexs) {
    			return {
    				type: 'coverCellModel',
    				currentModelIndexs: currentModelIndexs,
    				originalModelIndexs: originalModelIndexs,
    			};
    		},
    		getValidateUpdateAction: function(region, currentRuleIndex, originalData) {
    			return {
    				type: 'updateValidateRule',
    				region: region,
    				currentRuleIndex: currentRuleIndex,
    				originalData: originalData
    			};
    		},
    		getValidateCoverAction: function(currentData, originalData) {
    			return {
    				type: 'coverValidateRule',
    				currentData: currentData,
    				originalData: originalData
    			};
    		},
    		
    		clear: function() {
    			historyIndex = 0;
    			historyList = [];
    		}
    	};
    	return history;
    });
    
    define('entrance/row/rowoperation',function() {
    	var Cell = require('models/cell'),
    		cache = require('basic/tools/cache'),
    		headItemRows = require('collections/headItemRow'),
    		headItemCols = require('collections/headItemCol'),
    		cells = require('collections/cells');
    
    	return {
    		
    		rowPropOper: function(start, end, prop, value, fn) {
    			var parentProp,
    				childProp,
    				headRowModel,
    				headRowProp,
    				defaultProp,
    				startColIndex,
    				endColIndex,
    				rowAlias,
    				colAlias,
    				cellList,
    				cellModel,
    				currentStrandX,
    				props,
    				len, colLen, i, j;
    
    			props = prop.split('.');
    			if (props.length > 1) {
    				childProp = props[1];
    			}
    			parentProp = props[0];
    			defaultProp = (new Cell()).toJSON();
    			colLen = headItemRows.length;
    			currentStrandX = cache.CellsPosition.strandX;
    
    			for (i = start; i < end + 1; i++) {
    				//维护行对象operProp属性
    				headRowModel = headItemRows.models[i];
    				headRowProp = headRowModel.get('operProp');
    
    				if (headRowProp[parentProp] !== undefined &&
    					headRowProp[parentProp][childProp] !== undefined) {
    					if (defaultProp[parentProp][childProp] === value) {
    						delete headRowProp[parentProp][childProp];
    						if (!Object.getOwnPropertyNames(headRowProp[parentProp]).length) {
    							delete headRowProp[parentProp];
    						}
    					} else {
    						headRowProp[parentProp][childProp] = value;
    					}
    				} else {
    					if (defaultProp[parentProp][childProp] !== value) {
    						if (!headRowProp[parentProp]) {
    							headRowProp[parentProp] = {};
    						}
    						headRowProp[parentProp][childProp] = value;
    					}
    				}
    				headRowModel.set('operProp', headRowProp);
    				cellList = cells.getCellByTransverse(i, 0, i, headItemCols.length - 1);
    				len = cellList.length;
    				for (j = 0; j < len; j++) {
    					if (cellList[j].get('occupy').y.length === 1) {
    						cellList[j].set(prop, value);
    						if (typeof fn === 'function') {
    							fn(cellList[j]);
    						}
    					}
    				}
    				startColIndex = 0;
    				endColIndex = headItemCols.length - 1;
    
    				for (j = startColIndex; j < endColIndex + 1; j++) {
    					rowAlias = headItemRows.models[i].get('alias');
    					colAlias = headItemCols.models[j].get('alias');
    					if (!currentStrandX[colAlias] ||
    						currentStrandX[colAlias][rowAlias] === undefined) {
    						cellModel = cells.createCellModel(j, i);
    						cellModel.set(prop, value);
    					}
    				}
    			}
    		},
    	};
    });
    
    define('entrance/col/coloperation',function() {
    	var Cell = require('models/cell'),
    		cache = require('basic/tools/cache'),
    		binary = require('basic/util/binary'),
    		headItemRows = require('collections/headItemRow'),
    		headItemCols = require('collections/headItemCol'),
    		cells = require('collections/cells'),
    		headItemColList = headItemCols.models,
    		headItemRowList = headItemRows.models;
    
    	return {
    		
    		colPropOper: function(start, end, prop, value, fn) {
    			var parentProp,
    				childProp,
    				operAlias,
    				rowAlias,
    				headColModel,
    				headColProp,
    				defaultProp,
    				startRowIndex,
    				endRowIndex,
    				cellModel,
    				existCellList,
    				currentStrandX,
    				props, len, i, j, rowLen;
    
    			props = prop.split('.');
    			if (props.length > 1) {
    				childProp = props[1];
    			}
    			parentProp = props[0];
    			defaultProp = (new Cell()).toJSON();
    			rowLen = headItemRows.length;
    
    			for (i = start; i < end + 1; i++) {
    				headColModel = headItemCols.models[i];
    				headColProp = headColModel.toJSON().operProp;
    
    				if (headColProp[parentProp] !== undefined &&
    					headColProp[parentProp][childProp] !== undefined) {
    					if (defaultProp[parentProp][childProp] === value) {
    						delete headColProp[parentProp][childProp];
    						if (!Object.getOwnPropertyNames(headColProp[parentProp]).length) {
    							delete headColProp[parentProp];
    						}
    					} else {
    						headColProp[parentProp][childProp] = value;
    					}
    				} else {
    					if (defaultProp[parentProp][childProp] !== value) {
    						if (!headColProp[parentProp]) {
    							headColProp[parentProp] = {};
    						}
    						headColProp[parentProp][childProp] = value;
    					}
    				}
    				headColModel.set('operProp', headColProp);
    
    				operAlias = headItemColList[i].get('alias');
    				//获取显示区域
    				startRowIndex = binary.indexModelBinary(cache.viewRegion.top, headItemRowList, 'top', 'height');
    				endRowIndex = binary.indexModelBinary(cache.viewRegion.bottom, headItemRowList, 'top', 'height');
    
    				currentStrandX = cache.CellsPosition.strandX;
    				existCellList = cells.getCellByTransverse(0, i, rowLen - 1, i);
    				len = existCellList.length;
    				for (j = 0; j < len; j++) {
    					existCellList[j].set(prop, value);
    					if (typeof fn === 'function') {
    						fn(existCellList[j]);
    					}
    				}
    				for (j = startRowIndex; j < endRowIndex + 1; j++) {
    					rowAlias = headItemRowList[j].get('alias');
    					if (currentStrandX[operAlias] === undefined ||
    						currentStrandX[operAlias][rowAlias] === undefined) {
    						cellModel = cells.createCellModel(i, j);
    						cellModel.set(prop, value);
    					}
    				}
    			}
    		},
    	};
    });
    
    define('entrance/tool/setfontcolor',function() {
    	var Backbone = require('lib/backbone'),
    		send = require('basic/tools/send'),
    		cache = require('basic/tools/cache'),
    		config = require('spreadsheet/config'),
    		selectRegions = require('collections/selectRegion'),
    		headItemCols = require('collections/headItemCol'),
    		headItemRows = require('collections/headItemRow'),
    		getOperRegion = require('basic/tools/getoperregion'),
    		history = require('basic/tools/history'),
    		cells = require('collections/cells'),
    		rowOperate = require('entrance/row/rowoperation'),
    		colOperate = require('entrance/col/coloperation');
    
    
    	var setFontColor = function(sheetId, color, label) {
    		var clip,
    			region,
    			operRegion,
    			sendRegion,
    			headItemRowList = headItemRows.models,
    			headItemColList = headItemCols.models,
    			changeModelList = [];
    
    		clip = selectRegions.getModelByType('clip');
    		if (clip !== undefined) {
    			cache.clipState = 'null';
    			clip.destroy();
    		}
    		if (cache.protectState) {
    			Backbone.trigger('event:showMsgBar:show', '保护状态，不能进行该操作');
    			return;
    		}
    		region = getOperRegion(label);
    		operRegion = region.operRegion;
    		sendRegion = region.sendRegion;
    
    		if (operRegion.startColIndex === -1 || operRegion.startRowIndex === -1) {
    			sendData();
    			return;
    		}
    		if (operRegion.endColIndex === 'MAX') { //整行操作
    			rowOperate.rowPropOper(operRegion.startRowIndex, operRegion.endRowIndex, 'content.color', color);
    		} else if (operRegion.endRowIndex === 'MAX') {
    			colOperate.colPropOper(operRegion.startColIndex, operRegion.endColIndex, 'content.color', color);
    		} else {
    			cells.oprCellsByRegion(operRegion, function(cell, colSort, rowSort) {
    				if (cell.get('content').color !== color) {
    					changeModelList.push({
    						colSort: colSort,
    						rowSort: rowSort,
    						value: cell.get('content').color
    					});
    					cell.set('content.color', color);
    				}
    			});
    			history.addAction(history.getCellPropUpdateAction('content.color', color, {
    				startColSort: headItemColList[operRegion.startColIndex].get('sort'),
    				startRowSort: headItemRowList[operRegion.startRowIndex].get('sort'),
    				endColSort: headItemColList[operRegion.endColIndex].get('sort'),
    				endRowSort: headItemRowList[operRegion.endRowIndex].get('sort')
    			}, changeModelList));
    		}
    		sendData();
    
    		function sendData() {
    			send.PackAjax({
    				url: config.url.cell.fontColor,
    				data: JSON.stringify({
    					sheetId: '1',
    					coordinate: sendRegion,
    					color: color
    				})
    			});
    		}
    	};
    	return setFontColor;
    });
    define('entrance/tool/setfillcolor',function() {
    	
    	var Backbone = require('lib/backbone'),
    		send = require('basic/tools/send'),
    		config = require('spreadsheet/config'),
    		cache = require('basic/tools/cache'),
    		cells = require('collections/cells'),
    		history = require('basic/tools/history'),
    		headItemCols = require('collections/headItemCol'),
    		headItemRows = require('collections/headItemRow'),
    		selectRegions = require('collections/selectRegion'),
    		getOperRegion = require('basic/tools/getoperregion'),
    		rowOperate = require('entrance/row/rowoperation'),
    		colOperate = require('entrance/col/coloperation');
    
    	
    	var setFillColor = function(sheetId, color, arrOpr) {
    		var clip,
    			region,
    			operRegion,
    			sendRegion,
    			headItemRowList = headItemRows.models,
    			headItemColList = headItemCols.models,
    			changeModelList = [],
    			action;
    
    		clip = selectRegions.getModelByType('clip');
    		if (clip !== undefined) {
    			cache.clipState = 'null';
    			clip.destroy();
    		}
    		if (cache.protectState) {
    			Backbone.trigger('event:showMsgBar:show', '保护状态，不能进行该操作');
    			return;
    		}
    		if (!color) {
    			color = sheetId;
    		}
    		region = getOperRegion(arrOpr);
    		operRegion = region.operRegion;
    		sendRegion = region.sendRegion;
    
    		if (operRegion.endColIndex === 'MAX') { //整行操作
    			rowOperate.rowPropOper(operRegion.startRowIndex, operRegion.endRowIndex, 'customProp.background', color);
    		} else if (operRegion.endRowIndex === 'MAX') {
    			colOperate.colPropOper(operRegion.startColIndex, operRegion.endColIndex, 'customProp.background', color);
    		} else {
    			cells.oprCellsByRegion(operRegion, function(cell, colSort, rowSort) {
    				if (cell.get('customProp').background !== color) {
    					changeModelList.push({
    						colSort: colSort,
    						rowSort: rowSort,
    						value: cell.get('customProp').background
    					});
    					cell.set('customProp.background', color);
    				}
    			});
    
    			action = history.getCellPropUpdateAction('customProp.background', color, {
    				startColSort: headItemColList[operRegion.startColIndex].get('sort'),
    				startRowSort: headItemRowList[operRegion.startRowIndex].get('sort'),
    				endColSort: headItemColList[operRegion.endColIndex].get('sort'),
    				endRowSort: headItemRowList[operRegion.endRowIndex].get('sort')
    			}, changeModelList);
    			
    			history.addAction(action);
    		}
    		send.PackAjax({
    			url: config.url.cell.bg,
    			data: JSON.stringify({
    				coordinate: sendRegion,
    				color: color
    			})
    		});
    	};
    	return setFillColor;
    });
    
    define('entrance/tool/setfontfamily',function() {
    	var Backbone = require('lib/backbone'),
    		send = require('basic/tools/send'),
    		cells = require('collections/cells'),
    		cache = require('basic/tools/cache'),
    		config = require('spreadsheet/config'),
    		history = require('basic/tools/history'),
    		headItemCols = require('collections/headItemCol'),
    		headItemRows = require('collections/headItemRow'),
    		selectRegions = require('collections/selectRegion'),
    		getOperRegion = require('basic/tools/getoperregion'),
    		colOperate = require('entrance/col/coloperation'),
    		rowOperate = require('entrance/row/rowoperation');
    
    	var setFontFamily = function(sheetId, fontFamily, label) {
    		var clip,
    			region,
    			operRegion,
    			sendRegion,
    			headItemRowList = headItemRows.models,
    			headItemColList = headItemCols.models,
    			changeModelList = [];
    		clip = selectRegions.getModelByType('clip');
    		if (clip !== undefined) {
    			cache.clipState = 'null';
    			clip.destroy();
    		}
    		if (cache.protectState) {
    			Backbone.trigger('event:showMsgBar:show','保护状态，不能进行该操作');
    			return;
    		}
    		region = getOperRegion(label);
    		operRegion = region.operRegion;
    		sendRegion = region.sendRegion;
    
    		if (operRegion.startColIndex === -1 || operRegion.startRowIndex === -1) {
    			sendData();
    			return;
    		}
    
    		if (operRegion.endColIndex === 'MAX') { //整行操作
    			rowOperate.rowPropOper(operRegion.startRowIndex, operRegion.endRowIndex, 'content.family', fontFamily);
    		} else if (operRegion.endRowIndex === 'MAX') {
    			colOperate.colPropOper(operRegion.startColIndex, operRegion.endColIndex, 'content.family', fontFamily);
    		} else {
    			cells.oprCellsByRegion(operRegion, function(cell, colSort, rowSort) {
    				if (cell.get('content').family !== fontFamily) {
    					changeModelList.push({
    						colSort: colSort,
    						rowSort: rowSort,
    						value: cell.get('content').family
    					});
    					cell.set('content.family', fontFamily);
    				}
    			});
    			history.addAction(history.getCellPropUpdateAction('content.family', fontFamily, {
    				startColSort: headItemColList[operRegion.startColIndex].get('sort'),
    				startRowSort: headItemRowList[operRegion.startRowIndex].get('sort'),
    				endColSort: headItemColList[operRegion.endColIndex].get('sort'),
    				endRowSort: headItemRowList[operRegion.endRowIndex].get('sort')
    			}, changeModelList));
    		}
    		sendData();
    
    		function sendData() {
    			send.PackAjax({
    				url: config.url.cell.fontFamily,
    				data: JSON.stringify({
    					coordinate: sendRegion,
    					family: fontFamily
    				})
    			});
    		}
    	};
    	return setFontFamily;
    });
    
    define('entrance/cell/setcellheight',function() {
    	var Backbone = require('lib/backbone'),
    		headItemRows = require('collections/headItemRow'),
    		cache = require('basic/tools/cache');
    
    
    	var setCellHeight = function(sheetId, rowLabel, height) {
    		var index;
    		if (cache.TempProp.isFrozen === true) {
    			return;
    		}
    		index = headItemRows.getIndexByDisplayname(rowLabel);
    		if (index > -1) {
    			// adjustHeight = height - headItemRows.models[index].get('height');
    			Backbone.trigger('event:rowHeightAdjust', index, height);
    		}
    
    	};
    	return setCellHeight;
    });
    
    define('entrance/cell/setcellwidth',function() {
    
    
    	var Backbone = require('lib/backbone'),
    		headItemCols = require('collections/headItemCol'),
    		cache = require('basic/tools/cache');
    
    
    	var setCellWidth = function(sheetId, colLable, width) {
    		var index;
    		if (cache.TempProp.isFrozen === true) {
    			return;
    		}
    		index = headItemCols.getIndexByDisplayname(colLable);
    		if (index > -1) {
    			Backbone.trigger('event:colWidthAdjust', index, width);
    		}
    	};
    	return setCellWidth;
    });
    
    define('entrance/tool/mergecell',function() {
    	var Backbone = require('lib/backbone'),
    		send = require('basic/tools/send'),
    		cache = require('basic/tools/cache'),
    		strandMap = require('basic/tools/strandmap'),
    		config = require('spreadsheet/config'),
    		selectRegions = require('collections/selectRegion'),
    		history = require('basic/tools/history'),
    		cells = require('collections/cells'),
    		Cell = require('models/cell'),
    		headItemCols = require('collections/headItemCol'),
    		headItemRows = require('collections/headItemRow'),
    		getOperRegion = require('basic/tools/getoperregion'),
    		colList = headItemCols.models,
    		rowList = headItemRows.models,
    		cellList = cells.models,
    		mergeCell;
    
    	mergeCell = function(sheetId, label) {
    		var cellStrand = cache.CellsPosition.strandX,
    			startRowIndex,
    			startColIndex,
    			endRowIndex,
    			endColIndex,
    			region,
    			operRegion,
    			sendRegion,
    			clip,
    			originalCellsIndex = [],
    			originalRuleIndex = [],
    			firstCell,
    			firstRuleIndex,
    			tempCell,
    			tempIndex,
    			ruleIndex,
    			occupyX = [],
    			occupyY = [],
    			aliasCol,
    			aliasRow,
    			width = 0,
    			height = 0,
    			modelAction,
    			validateAction,
    			i, j;
    
    		clip = selectRegions.getModelByType('clip');
    		if (clip !== undefined) {
    			cache.clipState = 'null';
    			clip.destroy();
    		}
    
    		region = getOperRegion(label);
    		operRegion = region.operRegion;
    		sendRegion = region.sendRegion;
    		if (cache.protectState) {
    			Backbone.trigger('event:showMsgBar:show', '保护状态，不能进行该操作');
    			return;
    		}
    
    		if (operRegion.startColIndex === -1 || operRegion.startRowIndex === -1) {
    			send.PackAjax({
    				url: config.url.cell.merge,
    				data: JSON.stringify({
    					coordinate: sendRegion
    				}),
    			});
    			return;
    		}
    		if (operRegion.endColIndex === 'MAX' || operRegion.endRowIndex === 'MAX') {
    			return;
    		}
    
    		startRowIndex = operRegion.startRowIndex;
    		startColIndex = operRegion.startColIndex;
    		endRowIndex = operRegion.endRowIndex;
    		endColIndex = operRegion.endColIndex;
    
    		aliasCol = colList[startColIndex].get('alias');
    		aliasRow = rowList[startRowIndex].get('alias');
    		firstCell = cells.getCellByTransverse(startRowIndex, startColIndex)[0];
    		firstCell = firstCell ? firstCell.clone() : new Cell();
    		firstRuleIndex = strandMap.getPointRecord(aliasCol, aliasRow, 'validate');
    
    		for (i = startRowIndex; i < endRowIndex + 1; i++) {
    			for (j = startColIndex; j < endColIndex + 1; j++) {
    				aliasCol = colList[j].get('alias');
    				aliasRow = rowList[i].get('alias');
    				if (!tempCell) {
    					tempCell = cells.getCellByTransverse(i, j)[0];
    					tempCell = tempCell && tempCell.get('content').texts !== '' ? tempCell.clone() : null;
    					if (tempCell) {
    						ruleIndex = strandMap.getPointRecord(aliasCol, aliasRow, 'validate');
    					}
    				}
    				if (cellStrand[aliasCol] && (tempIndex = cellStrand[aliasCol][aliasRow]) !== undefined) {
    					originalCellsIndex.push(tempIndex);
    					cellList[tempIndex].set('isDestroy', true);
    				}
    				originalRuleIndex.push({
    					colSort: colList[j].get('sort'),
    					rowSort: rowList[i].get('sort'),
    					originalIndex: strandMap.getPointRecord(aliasCol, aliasRow, 'validate')
    				});
    				
    				cache.cachePosition(aliasRow, aliasCol, cells.length);
    			}
    		}
    
    		if (!tempCell && firstCell) {
    			tempCell = firstCell;
    			ruleIndex = firstRuleIndex;
    		} else if (!tempCell) {
    			tempCell = new Cell();
    		}
    
    		//获取occupy信息
    		for (i = 0; i < endColIndex - startColIndex + 1; i++) {
    			occupyX.push(colList[startColIndex + i].get('alias'));
    			width += colList[startColIndex + i].get('width') + 1;
    		}
    		for (i = 0; i < endRowIndex - startRowIndex + 1; i++) {
    			occupyY.push(rowList[startRowIndex + i].get('alias'));
    			height += rowList[startRowIndex + i].get('height') + 1;
    		}
    		tempCell.set('physicsBox', {
    			top: rowList[startRowIndex].get('top'),
    			left: colList[startColIndex].get('left'),
    			width: width - 1,
    			height: height - 1
    		});
    		tempCell.set('occupy', {
    			x: occupyX,
    			y: occupyY
    		});
    		cells.add(tempCell);
    
    
    
    		for (i = startRowIndex; i < endRowIndex + 1; i++) {
    			for (j = startColIndex; j < endColIndex + 1; j++) {
    				aliasCol = colList[j].get('alias');
    				aliasRow = rowList[i].get('alias');
    				if (ruleIndex !== undefined) {
    					strandMap.addPointRecord(aliasCol, aliasRow, 'validate', ruleIndex);
    				} else {
    					strandMap.deletePointRecord(aliasCol, aliasRow, 'validate');
    				}
    			}
    		}
    
    
    		modelAction = history.getCellCoverAction([cells.length - 1], originalCellsIndex);
    		validateAction = history.getValidateUpdateAction({
    			startRowSort: rowList[startRowIndex].get('sort'),
    			endRowSort: rowList[endRowIndex].get('sort'),
    			startColSort: colList[startColIndex].get('sort'),
    			endColSort: colList[endColIndex].get('sort')
    		}, ruleIndex, originalRuleIndex);
    		
    		history.addAction([modelAction, validateAction]);
    
    		send.PackAjax({
    			url: config.url.cell.merge,
    			data: JSON.stringify({
    				coordinate: sendRegion
    			}),
    		});
    
    	};
    
    
    	return mergeCell;
    });
    
    define('entrance/tool/splitcell',function() {
    	var _ = require('lib/underscore'),
    		Backbone = require('lib/backbone'),
    		send = require('basic/tools/send'),
    		cache = require('basic/tools/cache'),
    		config = require('spreadsheet/config'),
    		selectRegions = require('collections/selectRegion'),
    		getOperRegion = require('basic/tools/getoperregion'),
    		history = require('basic/tools/history'),
    		cells = require('collections/cells'),
    		cols = require('collections/headItemCol'),
    		rows = require('collections/headItemRow'),
    		colList = cols.models,
    		rowList = rows.models,
    		splitCell;
    
    	splitCell = function(sheetId, label) {
    		var region,
    			operRegion,
    			sendRegion,
    			strand = cache.CellsPosition.strandX,
    			startColIndex,
    			startRowIndex,
    			endColIndex,
    			endRowIndex,
    			selectCells,
    			occupyCol,
    			occupyRow,
    			originalCellIndexs = [],
    			currentCellIndexs = [],
    			clip,
    			i, j, len,
    			aliasCol,
    			aliasRow,
    			currentCell,
    			attributes,
    			action;
    		//选中区域内开始坐标，结束坐标
    		clip = selectRegions.getModelByType('clip');
    		if (clip !== undefined) {
    			cache.clipState = 'null';
    			clip.destroy();
    		}
    		if (cache.protectState) {
    			Backbone.trigger('event:showMsgBar:show', '保护状态，不能进行该操作');
    			return;
    		}
    		region = getOperRegion(label);
    		operRegion = region.operRegion;
    		sendRegion = region.sendRegion;
    		if (operRegion.endColIndex === 'MAX' || operRegion.endRowIndex === 'MAX') {
    			return;
    		}
    		if (operRegion.startColIndex === -1 || operRegion.startRowIndex === -1) {
    			sendData();
    			return;
    		}
    		startColIndex = operRegion.startColIndex;
    		startRowIndex = operRegion.startRowIndex;
    		endColIndex = operRegion.endColIndex;
    		endRowIndex = operRegion.endRowIndex;
    
    		//选中区域内所有单元格对象
    		selectCells = cells.getCellByVertical(startColIndex, startRowIndex, endColIndex, endRowIndex);
    
    		for (i = startColIndex; i < endColIndex + 1; i++) {
    			for (j = startRowIndex; j < endRowIndex + 1; j++) {
    				aliasCol = colList[i].get('alias');
    				aliasRow = rowList[j].get('alias');
    				currentCell = cells.getCellByVertical(i, j)[0];
    				if (currentCell) {
    					attributes = _.clone(currentCell.attributes);
    					occupyCol = attributes.occupy.x[0];
    					occupyRow = attributes.occupy.y[0];
    					if (occupyCol !== aliasCol || occupyRow !== aliasRow) {
    						attributes.content.texts = '';
    						attributes.content.displayTexts = '';
    					} else {
    						originalCellIndexs.push(strand[occupyCol][occupyRow]);
    					}
    					cache.cachePosition(aliasRow, aliasCol, cells.length);
    					currentCellIndexs.push(cells.length);
    					cells.createCellModel(i, j, attributes);
    				}
    			}
    		}
    
    
    		for (i = 0, len = selectCells.length; i < len; i++) {
    			selectCells[i].set('isDestroy', true);
    		}
    		action = history.getCellCoverAction(currentCellIndexs, originalCellIndexs);
    		history.addAction(action);
    		sendData();
    
    		function sendData() {
    			send.PackAjax({
    				url: config.url.cell.split,
    				data: JSON.stringify({
    					coordinate: sendRegion
    				}),
    			});
    		}
    	};
    	return splitCell;
    });
    define('basic/util/aspect',function() {
    	
    	var aspect = {
    		before: function(target, methodName, filter) {
    			return this._aspect('before', target, methodName, filter);
    		},
    		after: function(target, methodName, filter) {
    			return this._aspect('after', target, methodName, filter);
    		},
    		_aspect: function(type, target, methodName, filter) {
    			var fn,
    				result,
    				orignal,
    				self = this;
    
    			if (typeof target === 'function') {
    				fn = target;
    				target = null;
    				filter = methodName;
    			} else {
    				fn = target[methodName];
    			}
    			orignal = fn.orignal || fn;
    
    			orignal[type] = orignal[type] || [];
    
    			orignal[type].push(filter);
    
    			if (orignal === fn) {
    				if (target) {
    					result = target[methodName] = function() {
    						return self._execute(arguments, target, orignal);
    					};
    				} else {
    					result = function() {
    						return self._execute(arguments, target, orignal);
    					};
    				}
    			} else {
    				result = fn;
    			}
    			result.orignal = orignal;
    			return result;
    		},
    		_execute: function(args, target, orignal) {
    			var i, len, befores, afters;
    			befores = orignal.before || [];
    			afters = orignal.after || [];
    			for (i = 0, len = befores.length; i < len; i++) {
    				if (!befores[i].apply(target, args)) {
    					return false;
    				}
    			}
    			orignal.apply(target, args);
    			for (i = afters.length - 1; i > -1; i--) {
    				if (!afters[i].apply(target, args)) {
    					return false;
    				}
    			}
    			return true;
    		}
    	};
    	return aspect;
    });
    define('entrance/tool/protect',function() {
    	
    	var Backbone = require('lib/backbone'),
    		send = require('basic/tools/send'),
    		config = require('spreadsheet/config'),
    		cache = require('basic/tools/cache'),
    		cells = require('collections/cells'),
    		history = require('basic/tools/history'),
    		cols = require('collections/headItemCol'),
    		rows = require('collections/headItemRow'),
    		selects = require('collections/selectRegion'),
    		getOperRegion = require('basic/tools/getoperregion'),
    		rowList = rows.models,
    		colList = cols.models,
    		protect;
    
    	protect = {
    		lock: function(sheetId, arrOper) {
    			if (typeof arrOper === 'undefined') {
    				arrOper = sheetId;
    			}
    			this._toggle(true, arrOper);
    		},
    		unlock: function(sheetId, arrOper) {
    			if (typeof arrOper === 'undefined') {
    				arrOper = sheetId;
    			}
    			this._toggle(false, arrOper);
    		},
    		_toggle: function(lock, arrOper) {
    			var clip,
    				region,
    				operRegion,
    				sendRegion,
    				cellList = [],
    				i, len1, j, len2,
    				tempCell,
    				tempArr = [],
    				tempLock;
    
    			if (cache.protectState) {
    				Backbone.trigger('event:showMsgBar:show', '保护状态，不能进行该操作');
    				return;
    			}
    
    			if (clip = selects.getModelByType('clip')) {
    				cache.clipState = 'null';
    				clip.destroy();
    			}
    
    			region = getOperRegion(arrOper);
    
    			operRegion = region.operRegion;
    			sendRegion = region.sendRegion;
    			//整行操作或多行操作
    			if (operRegion.endColIndex === 'MAX') {
    				//筛选出已经进行设置过的锁定列
    				for (i = 0, len1 = colList.length; i < len1; i++) {
    					if (typeof(tempLock = colList[i].get('operProp').locked) === 'boolean' && tempLock !== lock) {
    						tempArr.push(i);
    					}
    				}
    				for (i = operRegion.startRowIndex, len1 = operRegion.endRowIndex + 1; i < len1; i++) {
    					rowList[i].set('operProp.locked', lock);
    					//交叉位置创建单元格
    					for (j = 0, len2 = tempArr.length; j < len2; j++) {
    						tempCell = cells.createCellModel(tempArr[j], i);
    						tempCell.set('locked', lock);
    					}
    				}
    				cellList = cells.getCellByVertical(operRegion);
    				for (i = 0, len1 = cellList.length; i < len1; i++) {
    					cellList[i].set('locked', lock);
    				}
    				//整列或多列操作
    			} else if (operRegion.endRowIndex === 'MAX') {
    				for (i = 0, len2 = rowList.length; i < len2; i++) {
    					if (typeof(tempLock = rowList[i].get('operProp').locked) === 'boolean' && tempLock !== lock) {
    						tempArr.push(i);
    					}
    				}
    				for (i = operRegion.startColIndex, len1 = operRegion.endColIndex + 1; i < len1; i++) {
    					colList[i].set('operProp.locked', lock);
    					//交叉位置创建单元格
    					for (j = 0, len2 = tempArr.length; j < len2; j++) {
    						tempCell = cells.createCellModel(i, tempArr[j]);
    						tempCell.set('locked', lock);
    					}
    				}
    				cellList = cells.getCellByVertical(operRegion);
    				for (i = 0, len1 = cellList.length; i < len1; i++) {
    					cellList[i].set('locked', lock);
    				}
    			} else {
    				cells.oprCellsByRegion(operRegion, function(cell) {
    					cell.set('locked', lock);
    				});
    			}
    
    			send.PackAjax({
    				url: config.url.cell.lock,
    				data: JSON.stringify({
    					coordinate: [sendRegion],
    					lock: lock
    				})
    			});
    
    		},
    		execute: function(pwd) {
    			history.clear();
    			cache.protectState = true;
    			send.PackAjax({
    				url: config.url.sheet.protect,
    				data: JSON.stringify({
    					password: pwd,
    					protect: true
    				})
    			});
    		},
    		cancel: function(pwd) {
    			var result = false;
    			send.PackAjax({
    				url: config.url.sheet.protect,
    				data: JSON.stringify({
    					password: pwd,
    					protect: false
    				}),
    				success: function(data) {
    					if (data && data.isLegal) {
    						history.clear();
    						cache.protectState = false;
    						result = true;
    					}
    				}
    			});
    			return result;
    		},
    
    		interceptor: function(region) {
    			if (!cache.protectState) {
    				return false;
    			}
    			var startColIndex = region.startColIndex,
    				endColIndex = region.endColIndex || region.startColIndex,
    				startRowIndex = region.startRowIndex,
    				endRowIndex = region.endRowIndex || region.startRowIndex,
    				strandX = cache.CellsPosition.strandX,
    				cellList = cells.models,
    				temp = {},
    				index, colLock, rowLock,
    				i, j,
    				rowAlias, colAlias;
    
    			if (endColIndex === 'MAX' || endRowIndex === 'MAX') {
    				return true;
    			}
    			for (i = startColIndex; i < endColIndex + 1; i++) {
    				colAlias = colList[i].get('alias');
    				colLock = colList[i].get('operProp').locked;
    				for (j = startRowIndex; j < endRowIndex + 1; j++) {
    					rowAlias = rowList[j].get('alias');
    					rowLock = rowList[j].get('operProp').locked;
    					if (strandX[colAlias] &&
    						typeof(index = strandX[colAlias][rowAlias]) !== 'undefined') {
    						if (temp[index]) {
    							continue;
    						}
    						if (cellList[index].get('locked')) {
    							return true;
    						}
    						temp[index] = true;
    					} else if (colLock === true || rowLock === true) {
    						return true;
    					} else if (typeof colLock === 'undefined' && typeof rowLock === 'undefined') {
    						return true;
    					}
    				}
    			}
    			return false;
    		},
    		showLockContainer: function() {
    			if (cache.protectState) {
    				Backbone.trigger('event:showMsgBar:show', '保护状态，不能进行该操作');
    				return;
    			}
    			Backbone.trigger('event:sidebarContainer:show', 'lock');
    		},
    		showProtectContainer: function() {
    			Backbone.trigger('event:sidebarContainer:show', 'protect');
    		}
    	};
    	return protect;
    });
    
    define('basic/util/observer.pattern',function() {
    	
    
    	var observer,
    		subscribers;
    
    	
    	subscribers = {};
    
    	
    	observer = {
    		
    		subscriber: {
    			
    			subscribe: function(publisherName, type, fn) {
    				var temp1,
    					temp2;
    				if (typeof(temp1 = subscribers[publisherName]) === 'undefined') {
    					temp1 = subscribers[publisherName] = {};
    				}
    				if (typeof(temp2 = temp1[type]) === 'undefined') {
    					temp2 = temp1[type] = [];
    				}
    				temp2.push({
    					fn: fn,
    					master: this
    				});
    			},
    			
    			unsubscribe: function(publisherName, type) {
    				var currentSubscribers,
    					currentSubscriber,
    					types,
    					max, i;
    
    				types = subscribers[publisherName];
    				if (types === undefined) {
    					return;
    				}
    				currentSubscribers = types[type];
    				max = currentSubscribers !== undefined ? currentSubscribers.length : 0;
    				for (i = max - 1; i >= 0; i--) {
    					currentSubscriber = currentSubscribers[i];
    					if (currentSubscriber.master === this) {
    						currentSubscribers.splice(i, 1);
    					}
    				}
    			},
    		},
    		
    		publisher: {
    			
    			publish: function(name, type) {
    				var currentSubscribers,
    					currentSubscriber,
    					max, i, callback;
    
    				currentSubscribers = subscribers[name];
    				if (currentSubscribers &&
    					(currentSubscribers = currentSubscribers[type]) !== undefined) {
    					max = currentSubscribers !== undefined ? currentSubscribers.length : 0;
    					for (i = 0; i < max; i++) {
    						currentSubscriber = currentSubscribers[i];
    						callback = currentSubscriber.master[currentSubscriber.fn];
    						callback.apply(currentSubscriber.master, [].slice.call(arguments, 2));
    					}
    				}
    			},
    		},
    		
    		buildPublisher: function(obj) {
    			for (var i in this.publisher) {
    				if (this.publisher.hasOwnProperty(i) && typeof this.publisher[i] === 'function') {
    					obj[i] = this.publisher[i];
    				}
    			}
    		},
    		buildSubscriber: function(obj) {
    			for (var i in this.subscriber) {
    				if (this.subscriber.hasOwnProperty(i) && typeof this.subscriber[i] === 'function') {
    					obj[i] = this.subscriber[i];
    				}
    			}
    		},
    		clearSubscriber: function() {
    			subscribers = {};
    		}
    	};
    	return observer;
    });
    define('entrance/tool/validate',function() {
    	
    	var Backbone = require('lib/backbone'),
    		config = require('spreadsheet/config'),
    		cache = require('basic/tools/cache'),
    		send = require('basic/tools/send'),
    		original = require('basic/tools/original'),
    		observerPattern = require('basic/util/observer.pattern'),
    		strandMap = require('basic/tools/strandmap'),
    		cols = require('collections/headItemCol'),
    		rows = require('collections/headItemRow'),
    		cells = require('collections/cells'),
    		colList = cols.models,
    		rowList = rows.models,
    		index2Type = [],
    		validate;
    
    
    	index2Type[config.validationType.intType] = 'intType';
    	index2Type[config.validationType.decimalType] = 'decimalType';
    	index2Type[config.validationType.sequenceType] = 'sequenceType';
    	index2Type[config.validationType.textType] = 'textType';
    
    
    	validate = {
    		validate: function(value, colAlias, rowAlias, colIndex, rowIndex) {
    			var ruleIndex = strandMap.calcPointRecord(colAlias, rowAlias, 'validate'),
    				validators,
    				rule, i, len;
    
    			validators = {
    				intType: [intTypeValidator, rangeValidator],
    				decimalType: [decimalTypeValidator, rangeValidator],
    				textType: [intTypeValidator, lenValidator],
    				sequenceType: [sequenceValidator]
    			};
    
    			//未输入数据或不存在规则
    			if (value === '' || typeof ruleIndex === 'undefined') {
    				return true;
    			}
    
    			rule = cache.validate[ruleIndex];
    
    			if (rule) {
    				validators = validators[index2Type[rule.validationType]];
    				for (i = 0, len = validators.length; i < len; i++) {
    					if (!validators[i](value, rule.formula1, rule.formula2)) {
    						return false;
    					}
    				}
    			} else {
    				return getSequence(value, {
    					oprCol: colList[colIndex].get('sort'),
    					oprRow: rowList[rowIndex].get('sort'),
    				});
    			}
    			return true;
    
    			function intTypeValidator(value) {
    				var reg = /^([-]){0,1}[0-9]*$/;
    				return reg.test(value);
    			}
    
    			function decimalTypeValidator(value) {
    				var reg = /^([-]){0,1}[0-9]+(.[0-9]*)?$/;
    				return reg.test(value);
    			}
    
    			function rangeValidator(value, formula1, formula2) {
    				value = parseFloat(value);
    				if (value > parseFloat(formula1) || value < parseFloat(formula2)) {
    					return false;
    				}
    				return true;
    			}
    
    			function lenValidator(value, formula1, formula2) {
    				if (value.length > parseFloat(formula1) || value.length < parseFloat(formula2)) {
    					return false;
    				}
    				return true;
    			}
    
    			function sequenceValidator(value, formula1) {
    				var arrValidate = [],
    					cellList,
    					len, i;
    
    				if (typeof formula1 === 'object') {
    					cellList = cells.getCellByVertical(cols.getIndexByAlias(formula1.startColAlias),
    						rows.getIndexByAlias(formula1.startRowAlias),
    						cols.getIndexByAlias(formula1.endColAlias),
    						rows.getIndexByAlias(formula1.endRowAlias)
    					);
    					for (i = 0, len = cellList.length; i < len; i++) {
    						arrValidate.push(cellList[i].get('content').texts);
    					}
    				} else {
    					arrValidate = formula1.split(',');
    				}
    
    				for (i = 0, len = arrValidate.length; i < len; i++) {
    					if (arrValidate[i] === value) {
    						return true;
    					}
    				}
    				return false;
    			}
    			function getSequence(value, region) {
    				var result = false;
    				send.PackAjax({
    					url: config.url.sheet.validateFull,
    					async: false,
    					isPublic: false,
    					data: JSON.stringify(region),
    					success: function(data) {
    						var rule = data.rule,
    							list = data.expResult;
    
    						rule.index = data.index;
    						original.analysisValidateRule({
    							rule: rule
    						});
    						for (i = 0, len = list.length; i < len; i++) {
    							if (list[i] === value) {
    								result = true;
    								break;
    							}
    						}
    					}
    				});
    				return result;
    			}
    		},
    		showValidateContainer: function() {
    			Backbone.trigger('event:sidebarContainer:show', 'validate');
    		},
    		deleteRowUpdateRule: function(alias, index) {
    			var arr = strandMap.getTransverseRecord(alias, 'sourceToRuleIndex'),
    				rule,
    				formula1,
    				len, i;
    
    			for (i = 0, len = arr.length; i < len; i++) {
    				rule = cache.validate[arr[i]];
    				if (rule) {
    					formula1 = rule.formula1;
    					if (formula1.startRowAlias !== formula1.endRowAlias) {
    						if (formula1.startRowAlias === alias) {
    							formula1.startRowAlias = rowList[index + 1].get('alias');
    						} else {
    							formula1.endRowAlias = rowList[index - 1].get('alias');
    						}
    					}
    				}
    			}
    		},
    
    		deleteColUpdateRule: function(alias, index) {
    			var arr = strandMap.getVerticalRecord(alias, 'sourceToRuleIndex'),
    				rule,
    				formula1,
    				len, i;
    
    			for (i = 0, len = arr.length; i < len; i++) {
    				rule = cache.validate[arr[i]];
    				if (rule) {
    					formula1 = rule.formula1;
    					if (formula1.startColAlias !== formula1.endColAlias) {
    						if (formula1.startColAlias === alias) {
    							formula1.startColAlias = colList[index + 1].get('alias');
    						} else {
    							formula1.endColAlias = colList[index - 1].get('alias');
    						}
    					}
    				}
    			}
    		},
    		init: function() {
    			observerPattern.buildSubscriber(this);
    			this.subscribe('validate', 'deleteColPublish', 'deleteColUpdateRule');
    			this.subscribe('validate', 'deleteRowPublish', 'deleteRowUpdateRule');
    		}
    	};
    	validate.init();
    	return validate;
    });
    
    define('entrance/tool/setcellcontent',function() {
    	var aspect = require('basic/util/aspect'),
    		send = require('basic/tools/send'),
    		cache = require('basic/tools/cache'),
    		history = require('basic/tools/history'),
    		getOperRegion = require('basic/tools/getoperregion'),
    		selectRegions = require('collections/selectRegion'),
    		cells = require('collections/cells'),
    		cols = require('collections/headItemCol'),
    		rows = require('collections/headItemRow'),
    		protect = require('entrance/tool/protect'),
    		validate = require('entrance/tool/validate'),
    		config = require('spreadsheet/config'),
    		colList = cols.models,
    		rowList = rows.models;
    
    	var setCellContent = function(sheetId, text, label) {
    		var clip,
    			region,
    			operRegion,
    			sendRegion,
    			changeModelList = [],
    			tempText,
    			action;
    
    		clip = selectRegions.getModelByType('clip');
    		if (clip !== undefined) {
    			cache.clipState = 'null';
    			clip.destroy();
    		}
    		if (typeof text === 'undefined') {
    			text = sheetId;
    		}
    		region = getOperRegion(label);
    		operRegion = region.operRegion;
    		sendRegion = region.sendRegion;
    
    		if (protect.interceptor({
    				startColIndex: operRegion.startColIndex,
    				startRowIndex: operRegion.startRowIndex
    			})) {
    			return;
    		}
    
    
    		operRegion.endColIndex = operRegion.startColIndex;
    		operRegion.endRowIndex = operRegion.startRowIndex;
    		sendRegion.endCol = sendRegion.startCol;
    		sendRegion.endRow = sendRegion.startRow;
    
    
    		cells.oprCellsByRegion(operRegion, function(cell, colSort, rowSort) {
    			if ((tempText = cell.get('content').texts) !== text) {
    				changeModelList.push({
    					colSort: colSort,
    					rowSort: rowSort,
    					value: tempText
    				});
    				cell.set('content.texts', text);
    			}
    		});
    		action = history.getCellPropUpdateAction('content.texts', text, {
    			startColSort: colList[operRegion.startColIndex].get('sort'),
    			startRowSort: rowList[operRegion.startRowIndex].get('sort'),
    			endColSort: colList[operRegion.endColIndex].get('sort'),
    			endRowSort: rowList[operRegion.endRowIndex].get('sort')
    		}, changeModelList);
    		history.addAction(action);
    
    		sendData();
    
    		return true;
    
    		function sendData() {
    			send.PackAjax({
    				url: config.url.cell.content,
    				data: JSON.stringify({
    					coordinate: sendRegion,
    					content: text
    				})
    			});
    		}
    	};
    
    
    	setCellContent = aspect.before(setCellContent, function(sheetId, text, label) {
    		var region,
    			operRegion,
    			colAlias,
    			rowAlias,
    			colIndex,
    			rowIndex;
    
    		if (typeof text === 'undefined') {
    			label = text;
    			text = sheetId;
    		}
    		region = getOperRegion(label);
    		operRegion = region.operRegion;
    		colIndex = operRegion.startColIndex;
    		rowIndex = operRegion.startRowIndex;
    		colAlias = colList[colIndex].get('alias');
    		rowAlias = rowList[rowIndex].get('alias');
    		if (!validate.validate(text, colAlias, rowAlias, colIndex, rowIndex)) {
    			return false;
    		} else {
    			return true;
    		}
    	});
    	return setCellContent;
    });
    
    define('entrance/tool/setcellborder',function() {
    	var Backbone = require('lib/backbone'),
    		send = require('basic/tools/send'),
    		cells = require('collections/cells'),
    		cache = require('basic/tools/cache'),
    		config = require('spreadsheet/config'),
    		history = require('basic/tools/history'),
    		headItemCols = require('collections/headItemCol'),
    		headItemRows = require('collections/headItemRow'),
    		selectRegions = require('collections/selectRegion'),
    		getOperRegion = require('basic/tools/getoperregion'),
    		rowOperate = require('entrance/row/rowoperation'),
    		colOperate = require('entrance/col/coloperation');
    
    	var setCellBorder = function(sheetId, border, label) {
    		var clip,
    			region,
    			operRegion,
    			sendRegion,
    			headItemRowList = headItemRows.models,
    			headItemColList = headItemCols.models;
    
    		clip = selectRegions.getModelByType('clip');
    		if (clip !== undefined) {
    			cache.clipState = 'null';
    			clip.destroy();
    		}
    		if (cache.protectState) {
    			Backbone.trigger('event:showMsgBar:show', '保护状态，不能进行该操作');
    			return;
    		}
    		region = getOperRegion(label);
    		operRegion = region.operRegion;
    		sendRegion = region.sendRegion;
    
    		if (operRegion.startColIndex === -1 || operRegion.startRowIndex === -1) {
    			sendData();
    			return;
    		}
    
    		switch (border) {
    			case 'bottom':
    				setBottom(true);
    				break;
    			case 'top':
    				setTop(true);
    				break;
    			case 'left':
    				setLeft(true);
    				break;
    			case 'right':
    				setRight(true);
    				break;
    			case 'none':
    				setNone();
    				break;
    			case 'all':
    				setAll();
    				break;
    			case 'outer':
    				setOuter();
    				break;
    		}
    		sendData();
    
    		function sendData() {
    			send.PackAjax({
    				url: config.url.cell.border,
    				data: JSON.stringify({
    					coordinate: sendRegion,
    					direction: border
    				})
    			});
    		}
    
    		
    		function setNone() {
    			var changeModelList = [],
    				border = {
    					left: false,
    					right: false,
    					bottom: false,
    					top: false
    				};
    			if (operRegion.endColIndex === 'MAX') {
    				rowOperate.rowPropOper(operRegion.startRowIndex, operRegion.endRowIndex, 'border', border);
    			} else if (operRegion.endRowIndex === 'MAX') {
    				colOperate.colPropOper(operRegion.startColIndex, operRegion.endColIndex, 'border', border);
    			} else {
    				cells.oprCellsByRegion(operRegion, function(cell, colSort, rowSort) {
    					changeModelList.push({
    						colSort: colSort,
    						rowSort: rowSort,
    						value: cell.get('border')
    					});
    					cell.set('border', border);
    				});
    				history.addAction(history.getCellPropUpdateAction('border', border, {
    					startColSort: headItemColList[operRegion.startColIndex].get('sort'),
    					startRowSort: headItemRowList[operRegion.startRowIndex].get('sort'),
    					endColSort: headItemColList[operRegion.endColIndex].get('sort'),
    					endRowSort: headItemRowList[operRegion.endRowIndex].get('sort')
    				}, changeModelList));
    			}
    		}
    		
    		function setAll() {
    			var changeModelList = [],
    				border = {
    					left: true,
    					right: true,
    					bottom: true,
    					top: true
    				};
    			if (operRegion.endColIndex === 'MAX') {
    				rowOperate.rowPropOper(operRegion.startRowIndex, operRegion.endRowIndex, 'border', border);
    			} else if (operRegion.endRowIndex === 'MAX') {
    				colOperate.colPropOper(operRegion.startColIndex, operRegion.endColIndex, 'border', border);
    			} else {
    				cells.oprCellsByRegion(operRegion, function(cell, colSort, rowSort) {
    					changeModelList.push({
    						colSort: colSort,
    						rowSort: rowSort,
    						value: cell.get('border')
    					});
    					cell.set('border', border);
    				});
    				history.addAction(history.getCellPropUpdateAction('border', border, {
    					startColSort: headItemColList[operRegion.startColIndex].get('sort'),
    					startRowSort: headItemRowList[operRegion.startRowIndex].get('sort'),
    					endColSort: headItemColList[operRegion.endColIndex].get('sort'),
    					endRowSort: headItemRowList[operRegion.endRowIndex].get('sort')
    				}, changeModelList));
    			}
    		}
    		
    		function setTop() {
    			var changeModelList = [];
    			if (operRegion.endColIndex === 'MAX') {
    				rowOperate.rowPropOper(operRegion.startRowIndex, operRegion.endRowIndex, 'border.top', true);
    			} else if (operRegion.endRowIndex === 'MAX') {
    				colOperate.colPropOper(operRegion.startColIndex, operRegion.endColIndex, 'border.top', true);
    			} else {
    				cells.operTopHeadModel(operRegion.startColIndex,
    					operRegion.startRowIndex,
    					operRegion.endColIndex,
    					operRegion.endRowIndex,
    					function(cell, colSort, rowSort) {
    						changeModelList.push({
    							colSort: colSort,
    							rowSort: rowSort,
    							value: cell.get('border').top
    						});
    						cell.set('border.top', true);
    					});
    				history.addAction(history.getCellPropUpdateAction('border.top', border, {
    					startColSort: headItemColList[operRegion.startColIndex].get('sort'),
    					startRowSort: headItemRowList[operRegion.startRowIndex].get('sort'),
    					endColSort: headItemColList[operRegion.endColIndex].get('sort'),
    					endRowSort: headItemRowList[operRegion.endRowIndex].get('sort')
    				}, changeModelList));
    			}
    		}
    		
    		function setLeft() {
    			var changeModelList = [];
    			if (operRegion.endColIndex === 'MAX') {
    				rowOperate.rowPropOper(operRegion.startRowIndex, operRegion.endRowIndex, 'border.left', true);
    			} else if (operRegion.endRowIndex === 'MAX') {
    				colOperate.colPropOper(operRegion.startColIndex, operRegion.endColIndex, 'border.left', true);
    			} else {
    				cells.operLeftHeadModel(operRegion.startColIndex,
    					operRegion.startRowIndex,
    					operRegion.endColIndex,
    					operRegion.endRowIndex,
    					function(cell, colSort, rowSort) {
    						changeModelList.push({
    							colSort: colSort,
    							rowSort: rowSort,
    							value: cell.get('border').left
    						});
    						cell.set('border.left', true);
    					});
    				history.addAction(history.getCellPropUpdateAction('border.left', border, {
    					startColSort: headItemColList[operRegion.startColIndex].get('sort'),
    					startRowSort: headItemRowList[operRegion.startRowIndex].get('sort'),
    					endColSort: headItemColList[operRegion.endColIndex].get('sort'),
    					endRowSort: headItemRowList[operRegion.endRowIndex].get('sort')
    				}, changeModelList));
    			}
    		}
    		
    		function setBottom() {
    			var changeModelList = [];
    			if (operRegion.endColIndex === 'MAX') {
    				rowOperate.rowPropOper(operRegion.startRowIndex, operRegion.endRowIndex, 'border.bottom', true);
    			} else if (operRegion.endRowIndex === 'MAX') {
    				colOperate.colPropOper(operRegion.startColIndex, operRegion.endColIndex, 'border.bottom', true);
    			} else {
    				cells.operBottomHeadModel(operRegion.startColIndex,
    					operRegion.startRowIndex,
    					operRegion.endColIndex,
    					operRegion.endRowIndex,
    					function(cell, colSort, rowSort) {
    						changeModelList.push({
    							colSort: colSort,
    							rowSort: rowSort,
    							value: cell.get('border').bottom
    						});
    						cell.set('border.bottom', true);
    					});
    				history.addAction(history.getCellPropUpdateAction('border.bottom', border, {
    					startColSort: headItemColList[operRegion.startColIndex].get('sort'),
    					startRowSort: headItemRowList[operRegion.startRowIndex].get('sort'),
    					endColSort: headItemColList[operRegion.endColIndex].get('sort'),
    					endRowSort: headItemRowList[operRegion.endRowIndex].get('sort')
    				}, changeModelList));
    			}
    		}
    		
    		function setRight() {
    			var changeModelList = [];
    			if (operRegion.endColIndex === 'MAX') {
    				rowOperate.rowPropOper(operRegion.startRowIndex, operRegion.endRowIndex, 'border.right', true);
    			} else if (operRegion.endRowIndex === 'MAX') {
    				colOperate.colPropOper(operRegion.startColIndex, operRegion.endColIndex, 'border.right', true);
    			} else {
    				cells.operRightHeadModel(operRegion.startColIndex,
    					operRegion.startRowIndex,
    					operRegion.endColIndex,
    					operRegion.endRowIndex,
    					function(cell, colSort, rowSort) {
    						changeModelList.push({
    							colSort: colSort,
    							rowSort: rowSort,
    							value: cell.get('border').right
    						});
    						cell.set('border.right', true);
    					});
    				history.addAction(history.getCellPropUpdateAction('border.right', border, {
    					startColSort: headItemColList[operRegion.startColIndex].get('sort'),
    					startRowSort: headItemRowList[operRegion.startRowIndex].get('sort'),
    					endColSort: headItemColList[operRegion.endColIndex].get('sort'),
    					endRowSort: headItemRowList[operRegion.endRowIndex].get('sort')
    				}, changeModelList));
    			}
    		}
    		
    		function setOuter() {
    			var changeModelList = [];
    			if (operRegion.endColIndex === 'MAX') {
    				rowOperate.rowPropOper(operRegion.startRowIndex, operRegion.endRowIndex, 'border.top', true);
    				rowOperate.rowPropOper(operRegion.startRowIndex, operRegion.endRowIndex, 'border.bottom', true);
    			} else if (operRegion.endRowIndex === 'MAX') {
    				colOperate.colPropOper(operRegion.startColIndex, operRegion.endColIndex, 'border.right', true);
    				colOperate.colPropOper(operRegion.startColIndex, operRegion.endColIndex, 'border.left', true);
    			} else {
    				cells.operOuterHeadModel(operRegion.startColIndex,
    					operRegion.startRowIndex,
    					operRegion.endColIndex,
    					operRegion.endRowIndex,
    					function(cell, colSort, rowSort) {
    						changeModelList.push({
    							colSort: colSort,
    							rowSort: rowSort,
    							value: cell.get('border')
    						});
    					});
    				cells.operRightHeadModel(operRegion.startColIndex,
    					operRegion.startRowIndex,
    					operRegion.endColIndex,
    					operRegion.endRowIndex,
    					function(cell) {
    						cell.set('border.right', true);
    					});
    				cells.operLeftHeadModel(operRegion.startColIndex,
    					operRegion.startRowIndex,
    					operRegion.endColIndex,
    					operRegion.endRowIndex,
    					function(cell) {
    						cell.set('border.left', true);
    					});
    				cells.operTopHeadModel(operRegion.startColIndex,
    					operRegion.startRowIndex,
    					operRegion.endColIndex,
    					operRegion.endRowIndex,
    					function(cell) {
    						cell.set('border.top', true);
    					});
    				cells.operBottomHeadModel(operRegion.startColIndex,
    					operRegion.startRowIndex,
    					operRegion.endColIndex,
    					operRegion.endRowIndex,
    					function(cell) {
    						cell.set('border.bottom', true);
    					});
    				history.addAction(history.getCellPropUpdateAction('border', border, {
    					startColSort: headItemColList[operRegion.startColIndex].get('sort'),
    					startRowSort: headItemRowList[operRegion.startRowIndex].get('sort'),
    					endColSort: headItemColList[operRegion.endColIndex].get('sort'),
    					endRowSort: headItemRowList[operRegion.endRowIndex].get('sort')
    				}, changeModelList));
    			}
    		}
    
    	};
    	return setCellBorder;
    });
    
    define('entrance/tool/setfontsize',function() {
    	var Backbone = require('lib/backbone'),
    		send = require('basic/tools/send'),
    		cells = require('collections/cells'),
    		cache = require('basic/tools/cache'),
    		config = require('spreadsheet/config'),
    		history = require('basic/tools/history'),
    		headItemCols = require('collections/headItemCol'),
    		headItemRows = require('collections/headItemRow'),
    		selectRegions = require('collections/selectRegion'),
    		getOperRegion = require('basic/tools/getoperregion'),
    		rowOperate = require('entrance/row/rowoperation'),
    		colOperate = require('entrance/col/coloperation');
    
    
    	var setFontSize = function(sheetId, fontSize, label) {
    		var clip,
    			region,
    			operRegion,
    			sendRegion,
    			headItemRowList = headItemRows.models,
    			headItemColList = headItemCols.models,
    			changeModelList = [];
    
    		clip = selectRegions.getModelByType('clip');
    		if (clip !== undefined) {
    			cache.clipState = 'null';
    			clip.destroy();
    		}
    		if (cache.protectState) {
    			Backbone.trigger('event:showMsgBar:show','保护状态，不能进行该操作');
    			return;
    		}
    		region = getOperRegion(label);
    		operRegion = region.operRegion;
    		sendRegion = region.sendRegion;
    
    		if (operRegion.startColIndex === -1 || operRegion.startRowIndex === -1) {
    			sendData();
    			return;
    		}
    
    		if (operRegion.endRowIndex === 'MAX') {
    			colOperate.colPropOper(operRegion.startColIndex, operRegion.endColIndex, 'content.size', fontSize);
    		} else if (operRegion.endColIndex === 'MAX') { //整行操作
    			rowOperate.rowPropOper(operRegion.startRowIndex, operRegion.endRowIndex, 'content.size', fontSize);
    		} else {
    			cells.oprCellsByRegion(operRegion, function(cell, colSort, rowSort) {
    				if (cell.get('content').size !== fontSize) {
    					changeModelList.push({
    						colSort: colSort,
    						rowSort: rowSort,
    						value: cell.get('content').size
    					});
    					cell.set('content.size', fontSize);
    				}
    			});
    			history.addAction(history.getCellPropUpdateAction('content.size', fontSize, {
    				startColSort: headItemColList[operRegion.startColIndex].get('sort'),
    				startRowSort: headItemRowList[operRegion.startRowIndex].get('sort'),
    				endColSort: headItemColList[operRegion.endColIndex].get('sort'),
    				endRowSort: headItemRowList[operRegion.endRowIndex].get('sort')
    			}, changeModelList));
    		}
    		sendData();
    
    		function sendData() {
    			send.PackAjax({
    				url: config.url.cell.fontSize,
    				data: JSON.stringify({
    					coordinate: sendRegion,
    					size: fontSize
    				})
    			});
    		}
    
    	};
    	return setFontSize;
    });
    
    define('entrance/tool/setfontweight',function() {
    	var Backbone = require('lib/backbone'),
    		send = require('basic/tools/send'),
    		cache = require('basic/tools/cache'),
    		config = require('spreadsheet/config'),
    		selectRegions = require('collections/selectRegion'),
    		getOperRegion = require('basic/tools/getoperregion'),
    		history = require('basic/tools/history'),
    		headItemCols = require('collections/headItemCol'),
    		headItemRows = require('collections/headItemRow'),
    		cells = require('collections/cells'),
    		colOperate = require('entrance/col/coloperation'),
    		rowOperate = require('entrance/row/rowoperation');
    
    	var setFontWeight = function(sheetId, bold, label) {
    		var clip,
    			region,
    			operRegion,
    			sendRegion,
    			tempCellList,
    			headItemRowList = headItemRows.models,
    			headItemColList = headItemCols.models,
    			changeModelList = [];
    		clip = selectRegions.getModelByType('clip');
    		if (clip !== undefined) {
    			cache.clipState = 'null';
    			clip.destroy();
    		}
    		if (cache.protectState) {
    			Backbone.trigger('event:showMsgBar:show','保护状态，不能进行该操作');
    			return;
    		}
    		region = getOperRegion(label);
    		operRegion = region.operRegion;
    		sendRegion = region.sendRegion;
    
    		if (operRegion.startColIndex === -1 || operRegion.startRowIndex === -1) {
    			sendData();
    			return;
    		}
    
    		clip = selectRegions.getModelByType('clip');
    		if (clip !== undefined) {
    			cache.clipState = 'null';
    			clip.destroy();
    		}
    		if (bold === 'bold') {
    			bold = true;
    		} else if (bold === 'normal') {
    			bold = false;
    		} else {
    			tempCellList = cells.getCellByVertical(operRegion.startColIndex,
    				operRegion.startRowIndex,
    				operRegion.endColIndex,
    				operRegion.endRowIndex);
    			if (tempCellList.length === 0) {
    				bold = true;
    			} else {
    				bold = !tempCellList[0].get('content').bd;
    			}
    		}
    		if (operRegion.endRowIndex === 'MAX') { //整列操作
    			colOperate.colPropOper(operRegion.startColIndex, operRegion.endColIndex, 'content.bd', bold);
    		} else if (operRegion.endColIndex === 'MAX') { //整行操作
    			rowOperate.rowPropOper(operRegion.startRowIndex, operRegion.endRowIndex, 'content.bd', bold);
    		} else {
    			cells.oprCellsByRegion(operRegion, function(cell, colSort, rowSort) {
    				if (cell.get('content').bd !== bold) {
    					changeModelList.push({
    						colSort: colSort,
    						rowSort: rowSort,
    						value: cell.get('content').bd
    					});
    					cell.set('content.bd', bold);
    				}
    			});
    
    			history.addAction(history.getCellPropUpdateAction('content.bd', bold, {
    				startColSort: headItemColList[operRegion.startColIndex].get('sort'),
    				startRowSort: headItemRowList[operRegion.startRowIndex].get('sort'),
    				endColSort: headItemColList[operRegion.endColIndex].get('sort'),
    				endRowSort: headItemRowList[operRegion.endRowIndex].get('sort')
    			}, changeModelList));
    		}
    		sendData();
    		function sendData() {
    			send.PackAjax({
    				url: config.url.cell.fontWeight,
    				data: JSON.stringify({
    					coordinate: sendRegion,
    					weight: bold
    				})
    			});
    		}
    	};
    	return setFontWeight;
    });
    
    define('entrance/tool/setfontstyle',function() {
    	var Backbone = require('lib/backbone'),
    		send = require('basic/tools/send'),
    		cache = require('basic/tools/cache'),
    		config = require('spreadsheet/config'),
    		selectRegions = require('collections/selectRegion'),
    		history = require('basic/tools/history'),
    		headItemCols = require('collections/headItemCol'),
    		headItemRows = require('collections/headItemRow'),
    		cells = require('collections/cells'),
    		getOperRegion = require('basic/tools/getoperregion'),
    		rowOperate = require('entrance/row/rowoperation'),
    		colOperate = require('entrance/col/coloperation');
    
    
    	var setFontStyle = function(sheetId, italic, label) {
    		var clip,
    			region,
    			operRegion,
    			sendRegion,
    			tempCellList,
    			headItemRowList = headItemRows.models,
    			headItemColList = headItemCols.models,
    			changeModelList = [];
    		clip = selectRegions.getModelByType('clip');
    		if (clip !== undefined) {
    			cache.clipState = 'null';
    			clip.destroy();
    		}
    		if (cache.protectState) {
    			Backbone.trigger('event:showMsgBar:show', '保护状态，不能进行该操作');
    			return;
    		}
    		region = getOperRegion(label);
    		operRegion = region.operRegion;
    		sendRegion = region.sendRegion;
    
    		if (operRegion.startColIndex === -1 || operRegion.startRowIndex === -1) {
    			sendData();
    			return;
    		}
    		if (italic === 'italic') {
    			italic = true;
    		} else if (italic === 'normal') {
    			italic = false;
    		} else {
    			tempCellList = cells.getCellByVertical(operRegion.startColIndex,
    				operRegion.startRowIndex,
    				operRegion.endColIndex,
    				operRegion.endRowIndex);
    			if (tempCellList === null || tempCellList === undefined || tempCellList.length === 0) {
    				italic = true;
    			} else {
    				italic = !tempCellList[0].get('content').italic;
    			}
    		}
    		if (operRegion.endColIndex === 'MAX') { //整行操作
    			rowOperate.rowPropOper(operRegion.startRowIndex, operRegion.endRowIndex, 'content.italic', italic);
    		} else if (operRegion.endRowIndex === 'MAX') {
    			colOperate.colPropOper(operRegion.startColIndex, operRegion.endColIndex, 'content.italic', italic);
    		} else {
    			cells.oprCellsByRegion(operRegion, function(cell, colSort, rowSort) {
    				if (cell.get('content').italic !== italic) {
    					changeModelList.push({
    						colSort: colSort,
    						rowSort: rowSort,
    						value: cell.get('content').italic
    					});
    					cell.set('content.italic', italic);
    				}
    			});
    
    			history.addAction(history.getCellPropUpdateAction('content.italic', italic, {
    				startColSort: headItemColList[operRegion.startColIndex].get('sort'),
    				startRowSort: headItemRowList[operRegion.startRowIndex].get('sort'),
    				endColSort: headItemColList[operRegion.endColIndex].get('sort'),
    				endRowSort: headItemRowList[operRegion.endRowIndex].get('sort')
    			}, changeModelList));
    		}
    		sendData();
    
    		function sendData() {
    			send.PackAjax({
    				url: config.url.cell.fontItalic,
    				data: JSON.stringify({
    					coordinate: sendRegion,
    					italic: italic
    				})
    			});
    		}
    	};
    	return setFontStyle;
    });
    
    define('entrance/sheet/setfrozen',function() {
    
    	var Backbone = require('lib/backbone'),
    		send = require('basic/tools/send'),
    		cache = require('basic/tools/cache'),
    		config = require('spreadsheet/config'),
    		selectRegions = require('collections/selectRegion'),
    		headItemCols = require('collections/headItemCol'),
    		headItemRows = require('collections/headItemRow'),
    		getOperRegion = require('basic/tools/getoperregion');
    
    
    	var setFrozen = function(sheetId, point, type) {
    		var clip,
    			region,
    			operRegion,
    			sendRegion;
    
    		clip = selectRegions.getModelByType('clip');
    		if (clip !== undefined) {
    			cache.clipState = 'null';
    			clip.destroy();
    		}
    		if (cache.protectState) {
    			Backbone.trigger('event:showMsgBar:show', '保护状态，不能进行该操作');
    			return;
    		}
    		region = getOperRegion(point);
    		operRegion = region.operRegion;
    		sendRegion = region.sendRegion;
    
    		if (operRegion.startColIndex === -1 || operRegion.startRowIndex === -1) {
    			return;
    		}
    		if (sendRegion.endColIndex === 100 || sendRegion.endRowIndex === 10000) {
    			return;
    		}
    
    		switch (type) {
    			case 'custom':
    				setCustom(operRegion);
    				break;
    			case 'row':
    				setRow();
    				break;
    			case 'col':
    				setCol();
    				break;
    			case 'unfrozen':
    				setUnfrozen();
    				break;
    			default:
    				setCustom(operRegion);
    				break;
    		}
    		Backbone.trigger('event:bodyContainer:executiveFrozen');
    	};
    
    	
    	var filterOutUserView = function(region) {
    		var userViewColIndex = headItemCols.getIndexByAlias(cache.UserView.colAlias),
    			userViewRowIndex = headItemRows.getIndexByAlias(cache.UserView.rowAlias),
    			userViewEndColIndex = headItemCols.getIndexByAlias(cache.UserView.colEndAlias),
    			userViewEndRowIndex = headItemRows.getIndexByAlias(cache.UserView.rowEndAlias);
    		//初始化，未进行滚动
    		if (userViewRowIndex === userViewEndRowIndex) {
    			return false;
    		} else if (region.startColIndex < userViewColIndex ||
    			region.startRowIndex < userViewRowIndex ||
    			region.startColIndex > userViewEndColIndex ||
    			region.startRowIndex > userViewEndRowIndex) {
    			return true;
    		} else {
    			return false;
    		}
    	};
    	
    	var setCustom = function(region) {
    		var headItemRowList = headItemRows.models,
    			headItemColList = headItemCols.models,
    			splitColAlias = headItemColList[region.startColIndex].get('alias'),
    			splitRowAlias = headItemRowList[region.startRowIndex].get('alias'),
    			splitColSort = headItemColList[region.startColIndex].get('sort'),
    			splitRowSort = headItemRowList[region.startRowIndex].get('sort');
    
    		if (filterOutUserView(region)) {
    			return;
    		}
    
    		cache.TempProp = {
    			isFrozen: true,
    			colAlias: splitColAlias,
    			rowAlias: splitRowAlias,
    			rowFrozen: true,
    			colFrozen: true
    		};
    
    		requestFrozen(splitColSort, splitRowSort);
    	};
    	
    	var setCol = function() {
    		var neighborModel = headItemCols.getNeighborModelByAlias(cache.UserView.colAlias, 'RIGHT');
    		cache.TempProp = {
    			isFrozen: true,
    			colAlias: neighborModel.get('alias'),
    			rowAlias: '1',
    			colFrozen: true
    		};
    		cache.UserView.rowAlias = '1';
    		requestFrozen(neighborModel.get('sort'), 0);
    	};
    	
    	var setRow = function() {
    		var neighborModel = headItemRows.getNeighborModelByAlias(cache.UserView.rowAlias, 'RIGHT');
    		cache.TempProp = {
    			isFrozen: true,
    			colAlias: '1',
    			rowAlias: neighborModel.get('alias'),
    			rowFrozen: true
    		};
    
    		cache.UserView.colAlias = '1';
    		requestFrozen(0, neighborModel.get('sort'));
    	};
    	
    	var setUnfrozen = function() {
    		if (cache.protectState) {
    			Backbone.trigger('event:showMsgBar:show', '保护状态，不能进行该操作');
    			return;
    		}
    		cache.TempProp = {
    			isFrozen: false,
    			colAlias: '1',
    			rowAlias: '1'
    		};
    		requestUnfrozen();
    	};
    	
    	var requestFrozen = function(frozenColSort, frozenRowSort) {
    		var startColSort = headItemCols.getModelByAlias(cache.UserView.colAlias).get('sort'),
    			startRowSort = headItemRows.getModelByAlias(cache.UserView.rowAlias).get('sort');
    		send.PackAjax({
    			url: config.url.sheet.frozen,
    			data: JSON.stringify({
    				orignalCol: frozenColSort,
    				orignalRow: frozenRowSort,
    				viewCol: startColSort,
    				viewRow: startRowSort
    			})
    		});
    	};
    	
    	var requestUnfrozen = function() {
    		send.PackAjax({
    			url: config.url.sheet.unfrozen
    		});
    	};
    	return setFrozen;
    });
    
    define('entrance/tool/setalign',function() {
    	var Backbone = require('lib/backbone'),
    		send = require('basic/tools/send'),
    		config = require('spreadsheet/config'),
    		history = require('basic/tools/history'),
    		headItemCols = require('collections/headItemCol'),
    		headItemRows = require('collections/headItemRow'),
    		selectRegions = require('collections/selectRegion'),
    		cells = require('collections/cells'),
    		cache = require('basic/tools/cache'),
    		getOperRegion = require('basic/tools/getoperregion'),
    		rowOperate = require('entrance/row/rowoperation'),
    		colOperate = require('entrance/col/coloperation');
    
    
    	var setAlign = function(sheetId, alignType, label) {
    		var url,
    			type,
    			transverse,
    			vertical,
    			clip,
    			region,
    			operRegion,
    			sendRegion,
    			propName,
    			propValue,
    			changeModelList = [],
    			headItemRowList = headItemRows.models,
    			headItemColList = headItemCols.models;
    
    		clip = selectRegions.getModelByType('clip');
    		if (clip !== undefined) {
    			cache.clipState = 'null';
    			clip.destroy();
    		}
    		if (cache.protectState) {
    			Backbone.trigger('event:showMsgBar:show', '保护状态，不能进行该操作');
    			return;
    		}
    		region = getOperRegion(label);
    		operRegion = region.operRegion;
    		sendRegion = region.sendRegion;
    
    
    		switch (alignType) {
    			case 'left':
    				url = config.url.cell.alignTransverse;
    				transverse = 'left';
    				break;
    			case 'center':
    				url = config.url.cell.alignTransverse;
    				transverse = 'center';
    				break;
    			case 'right':
    				url = config.url.cell.alignTransverse;
    				transverse = 'right';
    				break;
    			case 'top':
    				url = config.url.cell.alignVertical;
    				vertical = 'top';
    				break;
    			case 'middle':
    				url = config.url.cell.alignVertical;
    				vertical = 'middle';
    				break;
    			case 'bottom':
    				url = config.url.cell.alignVertical;
    				vertical = 'bottom';
    				break;
    			default:
    				return;
    		}
    		if (operRegion.startColIndex === -1 || operRegion.startRowIndex === -1) {
    			sendData();
    			return;
    		}
    
    		if (operRegion.endColIndex === 'MAX') { //整行操作
    			if (transverse !== undefined) {
    				rowOperate.rowPropOper(operRegion.startRowIndex, operRegion.endRowIndex, 'content.alignRow', transverse);
    			} else {
    				rowOperate.rowPropOper(operRegion.startRowIndex, operRegion.endRowIndex, 'content.alignCol', vertical);
    			}
    		} else if (operRegion.endRowIndex === 'MAX') { //整行操作
    			if (transverse !== undefined) {
    				colOperate.colPropOper(operRegion.startColIndex, operRegion.endColIndex, 'content.alignRow', transverse);
    			} else {
    				colOperate.colPropOper(operRegion.startColIndex, operRegion.endColIndex, 'content.alignCol', vertical);
    			}
    		} else {
    			cells.oprCellsByRegion(operRegion, function(cell, colSort, rowSort) {
    				if (transverse !== undefined) {
    					propName = 'content.alignRow';
    					propValue = transverse;
    					if (cell.get('content.alignRow') !== transverse) {
    						changeModelList.push({
    							colSort: colSort,
    							rowSort: rowSort,
    							value: cell.get('content').alignRow
    						});
    						cell.set('content.alignRow', transverse);
    					}
    				} else {
    					propName = 'content.alignCol';
    					propValue = vertical;
    					if (cell.get('content.alignCol') !== vertical) {
    						changeModelList.push({
    							colSort: colSort,
    							rowSort: rowSort,
    							value: cell.get('content').alignCol
    						});
    						cell.set('content.alignCol', vertical);
    					}
    				}
    
    			});
    			history.addAction(history.getCellPropUpdateAction(propName, propValue, {
    				startColSort: headItemColList[operRegion.startColIndex].get('sort'),
    				startRowSort: headItemRowList[operRegion.startRowIndex].get('sort'),
    				endColSort: headItemColList[operRegion.endColIndex].get('sort'),
    				endRowSort: headItemRowList[operRegion.endRowIndex].get('sort')
    			}, changeModelList));
    
    		}
    		type = transverse || vertical;
    		sendData();
    
    		function sendData() {
    			send.PackAjax({
    				url: url,
    				data: JSON.stringify({
    					coordinate: sendRegion,
    					align: type
    				})
    			});
    		}
    	};
    	return setAlign;
    });
    
    define('entrance/selectregion/datasourceregionoperation',function() {
    	var Backbone = require('lib/backbone'),
    		selectRegions = require('collections/selectRegion'),
    		operation;
    
    	operation = {
    		setDataSourceState: function() {
    			Backbone.trigger('event:cellsContainer:setMouseState', 'locatedState' , 'dataSourceLocatedState');
    			Backbone.trigger('event:colsHeadContainer:setMouseState', 'locatedState' , 'dataSourceLocatedState');
    			Backbone.trigger('event:rowsHeadContainer:setMouseState', 'locatedState' , 'dataSourceLocatedState');
    		},
    		setSelectState: function() {
    			Backbone.trigger('event:cellsContainer:setMouseState', 'locatedState' , 'selectLocatedState');
    			Backbone.trigger('event:colsHeadContainer:setMouseState', 'locatedState' , 'selectLocatedState');
    			Backbone.trigger('event:rowsHeadContainer:setMouseState', 'locatedState' , 'selectLocatedState');
    		},
    		destroyDataSoure: function() {
    			if (selectRegions.getModelByType('datasource') !== undefined) {
    				selectRegions.getModelByType('datasource').destroy();
    			}
    		}
    	};
    	return operation;
    });
    
    define('entrance/sheet/getpointbyposi',function() {
    	var Backbone = require('lib/backbone'),
    		getPointByPosi;
    
    	getPointByPosi = function(sheetId, mouseColPosi, mouseRowPosi) {
    		var result = {};
    		var getResult = function() {
    			return function(callback) {
    				result.point = callback;
    			};
    		};
    		Backbone.trigger('event:cellsContainer:getCoordinateDisplayName', mouseColPosi, mouseRowPosi , getResult());
    		if (result.point === undefined) {
    			result.point = {
    				col: '',
    				row: ''
    			};
    			return result;
    		} else {
    			return result;
    		}
    	};
    	return getPointByPosi;
    });
    
    define('entrance/tool/setwordwrap',function() {
    	var Backbone = require('lib/backbone'),
    		send = require('basic/tools/send'),
    		selectRegions = require('collections/selectRegion'),
    		cells = require('collections/cells'),
    		cache = require('basic/tools/cache'),
    		config = require('spreadsheet/config'),
    		history = require('basic/tools/history'),
    		headItemCols = require('collections/headItemCol'),
    		headItemRows = require('collections/headItemRow'),
    		getOperRegion = require('basic/tools/getoperregion'),
    		colOperate = require('entrance/col/coloperation'),
    		rowOperate = require('entrance/row/rowoperation');
    
    	var setWordWrap = function(sheetId, wordWrap, label) {
    		var clip,
    			region,
    			operRegion,
    			sendRegion,
    			tempCellList,
    			headItemRowList = headItemRows.models,
    			headItemColList = headItemCols.models,
    			changeModelList = [];
    		clip = selectRegions.getModelByType('clip');
    		if (clip !== undefined) {
    			cache.clipState = 'null';
    			clip.destroy();
    		}
    		if (cache.protectState) {
    			Backbone.trigger('event:showMsgBar:show', '保护状态，不能进行该操作');
    			return;
    		}
    		region = getOperRegion(label);
    		operRegion = region.operRegion;
    		sendRegion = region.sendRegion;
    
    		if (operRegion.startColIndex === -1 || operRegion.startRowIndex === -1) {
    			sendData();
    			return;
    		}
    
    		if (wordWrap === undefined) {
    			if (operRegion.endColIndex === 'MAX' || operRegion.endRowIndex === 'MAX') {
    				wordWrap = true;
    			} else {
    				tempCellList = cells.getCellByVertical(operRegion.startColIndex,
    					operRegion.startRowIndex,
    					operRegion.endColIndex,
    					operRegion.endRowIndex);
    				if (tempCellList === null || tempCellList === undefined || tempCellList.length === 0) {
    					wordWrap = true;
    				} else {
    					wordWrap = !tempCellList[0].get('wordWrap');
    				}
    			}
    		}
    
    		if (operRegion.endColIndex === 'MAX') {
    			rowOperate.rowPropOper(region.startRowIndex, 'wordWrap', wordWrap);
    		} else if (operRegion.endRowIndex === 'MAX') {
    			colOperate.colPropOper(region.startColIndex, region.endColIndex, 'wordWrap', wordWrap);
    		} else {
    			cells.oprCellsByRegion(operRegion, function(cell, colSort, rowSort) {
    				if (cell.get('wordWrap') !== wordWrap) {
    					changeModelList.push({
    						colSort: colSort,
    						rowSort: rowSort,
    						value: cell.get('wordWrap')
    					});
    					cell.set('wordWrap', wordWrap);
    				}
    			});
    			history.addAction(history.getCellPropUpdateAction('wordWrap', wordWrap, {
    				startColSort: headItemColList[operRegion.startColIndex].get('sort'),
    				startRowSort: headItemRowList[operRegion.startRowIndex].get('sort'),
    				endColSort: headItemColList[operRegion.endColIndex].get('sort'),
    				endRowSort: headItemRowList[operRegion.endRowIndex].get('sort')
    			}, changeModelList));
    		}
    		sendData();
    
    		function sendData() {
    			send.PackAjax({
    				url: config.url.cell.wordwrap,
    				data: JSON.stringify({
    					coordinate: sendRegion,
    					wordWrap: wordWrap
    				})
    			});
    		}
    	};
    	return setWordWrap;
    });
    define('entrance/cell/gettextbycoordinate',function() {
    	
    	var cache = require('basic/tools/cache'),
    		cells = require('collections/cells'),
    		headItemCols = require('collections/headItemCol'),
    		headItemRows = require('collections/headItemRow'),
    		getOperRegion = require('basic/tools/getoperregion'),
    		getTextByCoordinate;
    
    	getTextByCoordinate = function(sheetId, label) {
    		var region,
    			operRegion,
    			headLineColModelList = headItemCols.models,
    			headLineRowModelList = headItemRows.models,
    			aliasGridRow,
    			aliasGridCol,
    			cellsPositionX,
    			modelCell;
    
    		//bug：超出加载区域，出现错误
    		region = getOperRegion(label);
    		operRegion = region.operRegion;
    
    		aliasGridCol = headLineColModelList[operRegion.startColIndex].get('alias');
    		aliasGridRow = headLineRowModelList[operRegion.startRowIndex].get('alias');
    
    		cellsPositionX = cache.CellsPosition.strandX;
    
    		if (cellsPositionX[aliasGridCol] !== undefined &&
    			cellsPositionX[aliasGridCol][aliasGridRow] !== undefined) {
    			modelCell = cells.models[cellsPositionX[aliasGridCol][aliasGridRow]];
    			return modelCell.get('content').texts;
    		} else {
    			return '';
    		}
    	};
    	return getTextByCoordinate;
    });
    define('entrance/sheet/adaptscreen',function() {
    	
    	var Backbone = require('lib/backbone'),
    		adaptScreen;
    	adaptScreen = function() {
    		Backbone.trigger('call:screenContainer:adaptScreen');
    	};
    	return adaptScreen;
    });
    define('entrance/sheet/getfrozenstate',function() {
    	
    	var cache = require('basic/tools/cache'),
    		getFrozenState;
    
    		getFrozenState = function() {
    			return cache.TempProp.isFrozen;
    		};
    	return getFrozenState;
    });
    
    define('entrance/sheet/getselectregion',function() {
    	var selectRegions = require('collections/selectRegion'),
    		headItemCols = require('collections/headItemCol'),
    		headItemRows = require('collections/headItemRow'),
    		getSelectRegion;
    
    	
    	getSelectRegion = function() {
    		var result = {},
    			cols = [],
    			rows = [],
    			selectRegion,
    			startColAlias,
    			startRowAlias,
    			endColAlias,
    			endRowAlias,
    			startColIndex,
    			startRowIndex,
    			endColIndex,
    			endRowIndex, i;
    
    		selectRegion = selectRegions.findWhere({
    			'selectType': 'selected'
    		});
    		startColAlias = selectRegion.get('wholePosi').startX;
    		startRowAlias = selectRegion.get('wholePosi').startY;
    		endColAlias = selectRegion.get('wholePosi').endX;
    		endRowAlias = selectRegion.get('wholePosi').endY;
    
    		startRowIndex = headItemRows.getIndexByAlias(startRowAlias);
    		startColIndex = headItemCols.getIndexByAlias(startColAlias);
    
    		endRowIndex = headItemRows.getIndexByAlias(endRowAlias);
    		endColIndex = headItemCols.getIndexByAlias(endColAlias);
    		
    
    		for (i = startColIndex; i < endColIndex + 1; i++) {
    			cols.push(headItemCols.models[i].get('displayName'));
    		}
    		for (i = startRowIndex; i < endRowIndex + 1; i++) {
    			rows.push(headItemRows.models[i].get('displayName'));
    		}
    		result.col = cols;
    		result.row = rows;
    		return result;
    	};
    	return getSelectRegion;
    });
    
    define('entrance/sheet/reload',function() {
    	var Backbone = require('lib/backbone');
    
    	function reload() {
    		Backbone.trigger('event:reload');
    	}
    	return reload;
    });
      
      define('entrance/tool/settexttype',function() {
        var Backbone = require('lib/backbone'),
          send = require('basic/tools/send'),
          cells = require('collections/cells'),
          config = require('spreadsheet/config'),
          getOperRegion = require('basic/tools/getoperregion'),
          selectRegions = require('collections/selectRegion'),
          headItemRows = require('collections/headItemRow'),
          headItemCols = require('collections/headItemCol'),
          rowOperate = require('entrance/row/rowoperation'),
          colOperate = require('entrance/col/coloperation'),
          history = require('basic/tools/history'),
          cache = require('basic/tools/cache'),
          textTypeHandler;
    
        textTypeHandler = {
          
          typeRecognize: function(model) {
            var text = model.get('content').texts,
              type = model.get('format').type;
            if (type === 'normal' && this.isDate(text)) {
              model.set('format.dateFormat', this.getDateFormat(text));
              model.set('format.type', 'date');
              this.generateDisplayText(model);
            }
          },
          
          setNormal: function(sheetId, label) {
            var self,
              region,
              operRegion,
              sendRegion,
              format;
    
            self = this;
            if (this.before()) {
              return;
            }
            region = getOperRegion(label);
            operRegion = region.operRegion;
            sendRegion = region.sendRegion;
            format = {
              type: 'normal',
              isValid: false,
              decimal: null,
              thousands: null,
              dateFormat: null,
              currencySign: null,
              currencyValid: false
            };
            //处理第三方调用，操作超出已加载区域
            if (operRegion.startColIndex === -1 || operRegion.startRowIndex === -1) {
              this.sendData(format, sendRegion);
              return;
            }
            if (operRegion.endColIndex === 'MAX') { //整行操作
              rowOperate.rowPropOper(operRegion.startRowIndex, operRegion.endRowIndex, 'format', format);
            } else if (operRegion.endRowIndex === 'MAX') {
              colOperate.colPropOper(operRegion.startColIndex, operRegion.endColIndex, 'format', format);
            } else {
              cells.oprCellsByRegion(operRegion, function(cell) {
                cell.set('format', format);
              });
            }
            this.sendData(format, sendRegion);
          },
          setText: function(sheetId, label) {
            var region,
              operRegion,
              sendRegion,
              format;
    
            if (this.before()) {
              return;
            }
            region = getOperRegion(label);
            operRegion = region.operRegion;
            sendRegion = region.sendRegion;
            format = {
              type: 'text',
              isValid: false,
              decimal: null,
              thousands: null,
              dateFormat: null,
              currencySign: null,
              currencyValid: false
            };
            if (operRegion.startColIndex === -1 || operRegion.startRowIndex === -1) {
              this.sendData(format, sendRegion);
              return;
            }
            if (operRegion.endColIndex === 'MAX') { //整行操作
              rowOperate.rowPropOper(operRegion.startRowIndex, operRegion.endRowIndex, 'format', format);
            } else if (operRegion.endRowIndex === 'MAX') {
              colOperate.colPropOper(operRegion.startColIndex, operRegion.endColIndex, 'format', format);
            } else {
              cells.oprCellsByRegion(operRegion, function(cell) {
                cell.set('format', format);
              });
            }
    
            this.sendData(format, sendRegion);
          },
          setNum: function(sheetId, thousands, decimal, label) {
            var self,
              region,
              operRegion,
              sendRegion,
              changeModelList = [],
              headItemRowList = headItemRows.models,
              headItemColList = headItemCols.models,
              format;
            if (this.before()) {
              return;
            }
            self = this;
            region = getOperRegion(label);
            operRegion = region.operRegion;
            sendRegion = region.sendRegion;
            format = {
              type: 'number',
              isValid: false,
              decimal: decimal,
              thousands: thousands,
              dateFormat: null,
              currencySign: null,
              currencyValid: false
            };
            if (operRegion.startColIndex === -1 || operRegion.startRowIndex === -1) {
              this.sendData(format, sendRegion);
              return;
            }
            if (operRegion.endColIndex === 'MAX') { //整行操作
              rowOperate.rowPropOper(operRegion.startRowIndex, operRegion.endRowIndex, 'format', format);
            } else if (operRegion.endRowIndex === 'MAX') { //整行操作
              colOperate.colPropOper(operRegion.startColIndex, operRegion.endColIndex, 'format', format);
            } else {
              cells.oprCellsByRegion(operRegion, function(cell, colSort, rowSort) {
                changeModelList.push({
                  colSort: colSort,
                  rowSort: rowSort,
                  value: cell.get('format')
                });
                cell.set('format', format);
              });
              history.addAction(history.getCellPropUpdateAction('format', format, {
                startColSort: headItemColList[operRegion.startColIndex].get('sort'),
                startRowSort: headItemRowList[operRegion.startRowIndex].get('sort'),
                endColSort: headItemColList[operRegion.endColIndex].get('sort'),
                endRowSort: headItemRowList[operRegion.endRowIndex].get('sort')
              }, changeModelList));
            }
            this.sendData(format, sendRegion);
          },
          setDate: function(sheetId, dateFormat, label) {
            var self,
              region,
              operRegion,
              sendRegion,
              changeModelList = [],
              headItemRowList = headItemRows.models,
              headItemColList = headItemCols.models,
              format;
            if (this.before()) {
              return;
            }
            format = {
              type: 'date',
              isValid: false,
              decimal: null,
              thousands: null,
              dateFormat: dateFormat,
              currencySign: null,
              currencyValid: false
            };
            region = getOperRegion(label);
            operRegion = region.operRegion;
            sendRegion = region.sendRegion;
            self = this;
            if (operRegion.startColIndex === -1 || operRegion.startRowIndex === -1) {
              this.sendData(format, sendRegion);
              return;
            }
            if (operRegion.endColIndex === 'MAX') { //整行操作
              rowOperate.rowPropOper(operRegion.startRowIndex, operRegion.endRowIndex, 'format', format);
            } else if (operRegion.endRowIndex === 'MAX') { //整列操作
              colOperate.colPropOper(operRegion.startColIndex, operRegion.endColIndex, 'format', format);
            } else {
              cells.oprCellsByRegion(operRegion, function(cell, colSort, rowSort) {
                changeModelList.push({
                  colSort: colSort,
                  rowSort: rowSort,
                  value: cell.get('format')
                });
                cell.set('format', format);
              });
              history.addAction(history.getCellPropUpdateAction('format', format, {
                startColSort: headItemColList[operRegion.startColIndex].get('sort'),
                startRowSort: headItemRowList[operRegion.startRowIndex].get('sort'),
                endColSort: headItemColList[operRegion.endColIndex].get('sort'),
                endRowSort: headItemRowList[operRegion.endRowIndex].get('sort')
              }, changeModelList));
            }
            this.sendData(format, sendRegion);
          },
          setPercent: function(sheetId, decimal, label) {
            var self,
              region,
              operRegion,
              sendRegion,
              changeModelList = [],
              headItemRowList = headItemRows.models,
              headItemColList = headItemCols.models,
              format;
    
            self = this;
            if (this.before()) {
              return;
            }
            format = {
              type: 'percent',
              isValid: false,
              decimal: decimal,
              thousands: false,
              dateFormat: null,
              currencySign: null,
              currencyValid: false
            };
            region = getOperRegion(label);
            operRegion = region.operRegion;
            sendRegion = region.sendRegion;
            self = this;
            if (operRegion.startColIndex === -1 || operRegion.startRowIndex === -1) {
              this.sendData(format, sendRegion);
              return;
            }
            if (operRegion.endColIndex === 'MAX') { //整行操作
              rowOperate.rowPropOper(operRegion.startRowIndex, operRegion.endRowIndex, 'format', format, function(cell) {
                self.generateDisplayText(cell);
              });
    
            } else if (operRegion.endRowIndex === 'MAX') { //整列操作
              colOperate.colPropOper(operRegion.startColIndex, operRegion.endColIndex, 'format', format, function(cell) {
                self.generateDisplayText(cell);
              });
            } else {
              cells.oprCellsByRegion(operRegion, function(cell, colSort, rowSort) {
                changeModelList.push({
                  colSort: colSort,
                  rowSort: rowSort,
                  value: cell.get('format')
                });
                cell.set('format', format);
              });
              history.addAction(history.getCellPropUpdateAction('format', format, {
                startColSort: headItemColList[operRegion.startColIndex].get('sort'),
                startRowSort: headItemRowList[operRegion.startRowIndex].get('sort'),
                endColSort: headItemColList[operRegion.endColIndex].get('sort'),
                endRowSort: headItemRowList[operRegion.endRowIndex].get('sort')
              }, changeModelList));
            }
            this.sendData(format, sendRegion);
          },
          setCurrency: function(sheetId, decimal, sign, label) {
            var self,
              format,
              region,
              changeModelList = [],
              headItemRowList = headItemRows.models,
              headItemColList = headItemCols.models,
              operRegion,
              sendRegion;
            if (this.before()) {
              return;
            }
            region = getOperRegion(label);
            operRegion = region.operRegion;
            sendRegion = region.sendRegion;
            self = this;
            format = {
              type: 'currency',
              isValid: false,
              decimal: decimal,
              thousands: false,
              dateFormat: null,
              currencySign: sign,
              currencyValid: false
            };
            if (operRegion.startColIndex === -1 || operRegion.startRowIndex === -1) {
              this.sendData(format, sendRegion);
              return;
            }
            if (operRegion.endColIndex === 'MAX') { //整行操作
              rowOperate.rowPropOper(operRegion.startRowIndex, operRegion.endRowIndex, 'format', format, function(cell) {
                self.generateDisplayText(cell);
              });
            } else if (operRegion.endRowIndex === 'MAX') { //整行操作
              colOperate.colPropOper(operRegion.startColIndex, operRegion.endColIndex, 'format', format, function(cell) {
                self.generateDisplayText(cell);
              });
            } else {
              cells.oprCellsByRegion(operRegion, function(cell, colSort, rowSort) {
                changeModelList.push({
                  colSort: colSort,
                  rowSort: rowSort,
                  value: cell.get('format')
                });
                cell.set('format', format);
              });
              history.addUpdateAction('format', format, {
                startColSort: headItemColList[operRegion.startColIndex].get('sort'),
                startRowSort: headItemRowList[operRegion.startRowIndex].get('sort'),
                endColSort: headItemColList[operRegion.endColIndex].get('sort'),
                endRowSort: headItemRowList[operRegion.endRowIndex].get('sort')
              }, changeModelList);
            }
            this.sendData(format, sendRegion);
          },
          before: function() {
            var clip;
            clip = selectRegions.getModelByType('clip');
            if (clip !== undefined) {
              cache.clipState = 'null';
              clip.destroy();
            }
            if (cache.protectState) {
              Backbone.trigger('event:showMsgBar:show', '保护状态，不能进行该操作');
              return true;
            } else {
              return false;
            }
          },
          sendData: function(format, sendRegion) {
            var data;
            data = {
              coordinate: sendRegion,
              format: format.type
            };
            switch (format.type) {
              case 'number':
                data.decimalPoint = format.decimal || 0;
                data.thousandPoint = format.thousands || false;
                break;
              case 'date':
                data.dateFormat = format.dateFormat || '';
                break;
              case 'currency':
                data.decimalPoint = format.decimal || 0;
                data.currencySymbol = format.currencySign;
                break;
              case 'percent':
                data.decimalPoint = format.decimal || 0;
                break;
            }
            send.PackAjax({
              url: config.url.cell.format,
              data: JSON.stringify(data)
            });
          },
          
          isNum: function(value) {
            var reg;
            if (value === '') {
              return false;
            }
            if (value.indexOf(',') === -1) {
              reg = /^(\-|\+)?[0-9]+(\.[0-9]+)?$/;
            } else {
              reg = /^(\-|\+)?([1-9][0-9]{0,2})+(,\d{3})*(\.[0-9]+)?$/;
            }
            return reg.test(value);
          },
          
          trimZero: function(value) {
            var head,
              tail,
              values;
            if (!this.isNum(value)) {
              return value;
            }
            values = value.split('.');
            head = values[0];
            tail = values[1];
    
            head = head.replace(/^0*/, '');
            head = head === '' ? '0' : head;
            if (typeof tail !== 'undefined') {
              tail = tail.replace(/0*$/, '');
              if (tail.length !== 0) {
                head += '.';
              }
              head += tail;
            }
            return head;
          },
          
          getFormatNumber: function(value, thousands, decimal) {
            var num,
              values,
              remainder,
              head,
              tail,
              sign = '',
              temp,
              len, i;
            //需要去除末尾无效的0字符
            if (!this.isNum(value)) {
              return value;
            }
            value = this.trimZero(value);
            //含有千分位的，先去除千分位，进行处理
            value = value.replace(/,/g, '');
            num = parseFloat(value);
            num = num * Math.pow(10, decimal);
            num = Math.round(num);
            value = (num / Math.pow(10, decimal)).toString();
            value = value.replace(/,/g, '');
            if (thousands) {
              values = value.split('.');
              head = values[0];
              if (head.charAt(0) === '-' || head.indexOf('+') === 0) {
                sign = head.charAt(0);
                head = head.substring(1, head.length);
              }
              len = Math.ceil(head.length / 3);
              remainder = head.length % 3 > 0 ? head.length % 3 : 3;
              temp = head;
              head = '';
              for (i = len - 1; i > -1; i--) {
                if (i === 0) {
                  head = temp.substring(0, remainder) + head;
                } else {
                  head = ',' + temp.substring(3 * (i - 1) + remainder, 3 * i + remainder) + head;
                }
              }
              value = sign + head;
              if (typeof values[1] !== 'undefined') {
                value += '.' + values[1];
              }
            }
            values = value.split('.');
            //补零
            if (decimal && (typeof values[1] === 'undefined' || values[1].length < decimal)) {
              head = values[0];
              tail = values[1] || '';
              for (i = 0, len = decimal - tail.length; i < len; i++) {
                tail += '0';
              }
              value = head + '.' + tail;
            }
            return value;
    
          },
          isDate: function(value) {
            var regularLine = /^\d{4}\/\d{1,2}\/\d{1,2}$/,
              regularWord = /^\d{4}\u5e74\d{1,2}\u6708(\d{1,2}\u65e5)?$/,
              year,
              month,
              day,
              date;
            if (value === '') {
              return false;
            }
            if (!regularLine.test(value) && !regularWord.test(value)) {
              return false;
            }
            year = value.match(/\d{4}/)[0];
            month = value.match(/(\/|\u5e74)\d{1,2}(\/|\u6708)/);
            if (month !== null) {
              month = month[0].substring(1, month[0].length - 1);
            }
            day = value.match(/\d{1,2}\u65e5/);
    
            if (day === null) {
              day = value.match(/\d{1,2}$/);
            }
            if (day !== null) {
              day = day[0].substring(0, day[0].length);
            }
            if (day !== null && day.indexOf('日') !== -1) {
              day = day.substring(0, day.length - 1);
            }
    
            date = new Date(year + '/' + (month || '01') + '/' + (day || '01'));
            if (parseInt(year) !== date.getFullYear()) {
              return false;
            }
            if (month !== null && parseInt(month) !== date.getMonth() + 1) {
              return false;
            }
            if (day !== null && parseInt(day) !== date.getDate()) {
              return false;
            }
            return true;
          },
          getFormatDate: function(value, formatType) {
            var year,
              month,
              day,
              result;
            if (!this.isDate(value) || value === '') {
              return value;
            }
            year = value.match(/\d{4}/)[0];
            month = value.match(/(\/|\u5e74)\d{1,2}(\/|\u6708)/);
            if (month !== null) {
              month = month[0].substring(1, month[0].length - 1);
            } else {
              month = '01';
            }
            day = value.match(/\d{1,2}\u65e5/);
            if (day === null) {
              day = value.match(/\d{1,2}$/);
            }
            if (day !== null) {
              day = day[0].substring(0, day[0].length);
            }
            if (day !== null && day.indexOf('日') !== -1) {
              day = day.substring(0, day.length - 1);
            }
            if (day === null) {
              day = '01';
            }
            switch (formatType) {
              case config.dateFormatType.frist:
                result = year + '/' + month + '/' + day;
                break;
              case config.dateFormatType.second:
                result = year + '/' + month;
                break;
              case config.dateFormatType.third:
                result = year;
                break;
              case config.dateFormatType.fourth:
                result = year + '年' + month + '月' + day + '日';
                break;
              case config.dateFormatType.fifth:
                result = year + '年' + month + '月';
                break;
              case config.dateFormatType.sixth:
                result = year + '年';
                break;
              default:
                result = value;
                break;
            }
            return result;
          },
          
          getDateFormat: function(value) {
            var regular1 = /^\d{4}\/\d{1,2}\/\d{1,2}$/, // 1999/01/01
              regular2 = /^\d{4}\u5e74\d{1,2}\u6708$/, // 1999年1月
              regular3 = /^\d{4}\u5e74\d{1,2}\u6708\d{1,2}\u65e5$/; // 1999年1月1日
            if (regular1.test(value)) {
              return config.dateFormatType.frist;
            }
            if (regular2.test(value)) {
              return config.dateFormatType.fifth;
            }
            if (regular3.test(value)) {
              return config.dateFormatType.fourth;
            }
            return null;
          },
          isCurrency: function(value) {
            if (value.charAt(0) === '¥' || value.charAt(0) === '$') {
              value = value.substring(1, value.length);
            }
            return this.isNum(value);
          },
          isLossCurrency: function(value) {
            if (value.charAt(0) === '¥' || value.charAt(0) === '$') {
              value = value.substring(1, value.length);
            }
            if (value.charAt(0) === '-') {
              return true;
            } else {
              return false;
            }
          },
          getFormatCurrency: function(value, decimal, sign) {
            var temp = value,
              result;
            if (value === '') {
              return value;
            }
            if (this.isCurrency(value)) {
              if (value.charAt(0) === '¥' || value.charAt(0) === '$') {
                value = value.substring(1, value.length);
              }
              sign = sign || '$';
              //货币千分位
              result = sign + this.getFormatNumber(value, true, decimal);
              return result;
            }
            return temp;
          },
          isPercent: function(value) {
            if (value.charAt(value.length - 1) === '%') {
              value = value.substring(0, value.length - 1);
            }
            return this.isNum(value);
          },
          getFormatPercent: function(value, decimal) {
            var temp = value;
            if (value === '') {
              return value;
            }
            if (value.charAt(value.length - 1) === '%') {
              value = value.substring(0, value.length - 1);
              if (this.isNum(value)) {
                value = this.getFormatNumber(value, false, decimal);
                return value + '%';
              }
            } else {
              if (this.isNum(value)) {
                value = value.replace(/,/g, '');
                value = (Number(value) * 100).toString();
                value = this.getFormatNumber(value, false, decimal);
                return value + '%';
              }
            }
            return temp;
          },
          
          generateDisplayText: function(model) {
            var displayText,
              isValid,
              text = model.get('content.texts'),
              format = model.get('format'),
              type = format.type,
              decimal = format.decimal,
              thousands = format.thousands,
              dateFormat = format.dateFormat,
              currencySign = format.currencySign;
    
            switch (type) {
              case 'normal':
                if (this.isNum(text)) {
                  isValid = true;
                  if (text.indexOf(',') !== -1) {
                    thousands = true;
                    model.set('content.texts', text.replace(/,/g, ''));
                  }
                  displayText = this.getFormatNumber(text, thousands, config.defaultNumberFormat.decimal);
                  displayText = this.trimZero(displayText);
                  model.set('content.displayTexts', displayText);
                  if (model.get('format').thousands !== thousands) {
                    model.set('format.thousands', thousands);
                  }
                } else {
                  model.set('content.displayTexts', text);
                }
                break;
              case 'date':
                isValid = this.isDate(text);
                if (isValid) {
                  model.set('content.displayTexts', textTypeHandler.getFormatDate(text, dateFormat));
                } else {
                  model.set('content.displayTexts', text);
                }
                break;
              case 'number':
                isValid = this.isNum(text);
                if (isValid) {
                  if (text.indexOf(',') !== -1) {
                    thousands = true;
                    model.set('content.texts', text.replace(/,/g, ''));
                  }
                  model.set('content.displayTexts', textTypeHandler.getFormatNumber(text, thousands, decimal));
                } else {
                  model.set('content.displayTexts', text);
                }
                break;
              case 'currency':
                isValid = this.isCurrency(text);
                if (isValid) {
                  if (text.indexOf(',') !== -1) {
                    thousands = true;
                    model.set('content.texts', text.replace(/,/g, ''));
                  }
                  if (text.indexOf('$') !== -1 || text.indexOf('¥') !== -1) {
                    model.set('content.texts', text.replace(/¥/g, ''));
                  }
                  model.set('content.displayTexts', textTypeHandler.getFormatCurrency(text, decimal, currencySign));
                } else {
                  model.set('content.displayTexts', text);
                }
                break;
              case 'percent':
                isValid = this.isPercent(text);
                if (isValid) {
                  if (text.indexOf(',') !== -1) {
                    thousands = true;
                    model.set('content.texts', text.replace(/,/g, ''));
                  }
                  if (text.indexOf('%') !== -1) {
                    text = text.replace(/%/g, '');
                    text = (parseInt(text) / 100).toString();
                    model.set('content.texts', text);
                  }
                  model.set('content.displayTexts', textTypeHandler.getFormatPercent(text, decimal));
                } else {
                  model.set('content.displayTexts', text);
                }
                break;
              default:
                model.set('content.displayTexts', text);
                isValid = true;
                break;
            }
            if (model.get('format').isValid !== isValid) {
              model.set('format.isValid', isValid);
            }
          }
        };
        return textTypeHandler;
      });
    define('entrance/tool/addrow',function() {
    	
    	var _ = require('lib/underscore'),
    		Backbone = require('lib/backbone'),
    		config = require('spreadsheet/config'),
    		cache = require('basic/tools/cache'),
    		rows = require('collections/headItemRow'),
    		cols = require('collections/headItemCol'),
    		getOperRegion = require('basic/tools/getoperregion'),
    		cells = require('collections/cells'),
    		selectRegions = require('collections/selectRegion'),
    		siderLineRows = require('collections/siderLineRow'),
    		strandMap = require('basic/tools/strandmap'),
    		send = require('basic/tools/send'),
    		rowList = rows.models,
    		colList = cols.models;
    
    	return {
    		
    		add: function(sheetId, label) {
    			var clip,
    				region,
    				operRegion,
    				sendRegion,
    				posi,
    				index,
    				height;
    
    			clip = selectRegions.getModelByType('clip');
    			if (clip !== undefined) {
    				cache.clipState = 'null';
    				clip.destroy();
    			}
    			if (cache.protectState) {
    				Backbone.trigger('event:showMsgBar:show', '保护状态，不能进行该操作');
    				return;
    			}
    			if (cache.TempProp.isFrozen === true) {
    				return;
    			}
    			region = getOperRegion(label);
    			operRegion = region.operRegion;
    			sendRegion = region.sendRegion;
    
    
    			if (operRegion.endRowIndex === 'MAX') {
    				return;
    			}
    			index = operRegion.startRowIndex;
    			posi = rows.models[index].get('top');
    			height = rows.models[index].get('height');
    			this._adaptHeadRowItem(index);
    			this._adaptSelectRegion(index);
    			this._adaptCells(index);
    			this._fillCells(index);
    			send.PackAjax({
    				url: config.url.row.plus,
    				data: JSON.stringify({
    					sheetId: '1',
    					row: sendRegion.startRow
    				})
    			});
    			Backbone.trigger('event:mainContainer:adaptRowHeightChange', posi, config.User.cellHeight + 1);
    		},
    		
    		_adaptHeadRowItem: function(index) {
    			var currentRowModel,
    				height,
    				sort,
    				top,
    				len,
    				i = index + 1;
    			currentRowModel = rows.models[index];
    
    			rows.add({
    				sort: currentRowModel.get('sort'),
    				alias: cache.aliasGenerator(),
    				top: currentRowModel.get('top'),
    				displayName: currentRowModel.get('displayName'),
    			}, {
    				at: index
    			});
    
    			height = config.User.cellHeight;
    			len = rows.length;
    			for (; i < len; i++) {
    				currentRowModel = rows.models[i];
    				top = currentRowModel.get('top') + height;
    				sort = currentRowModel.get('sort') + 1;
    				currentRowModel.set('top', top);
    				currentRowModel.set('displayName', (sort + 1).toString());
    				currentRowModel.set('sort', sort);
    			}
    		},
    		
    		_adaptSelectRegion: function(index) {
    			var select,
    				startRowAlias,
    				endRowAlias,
    				startRowIndex,
    				height,
    				top,
    				endRowIndex;
    			select = selectRegions.getModelByType('selected');
    			startRowAlias = select.get('wholePosi').startY;
    			endRowAlias = select.get('wholePosi').endY;
    			startRowIndex = rows.getIndexByAlias(startRowAlias);
    			endRowIndex = rows.getIndexByAlias(endRowAlias);
    
    			if (endRowIndex < index) {
    				return;
    			}
    			if (startRowIndex >= index) {
    				top = select.get('physicsBox').top;
    				top += config.User.cellHeight;
    				select.set('physicsBox.top', top);
    				siderLineRows.models[0].set('top', top);
    				startRowIndex++;
    			}
    			if (startRowIndex < index && endRowIndex >= index) {
    				height = select.get('physicsBox').height;
    				height += config.User.cellHeight;
    				select.set('physicsBox.height', height);
    				siderLineRows.models[0].set('height', height);
    				rows.models[index].set('activeState', true);
    				//	endRowIndex++;
    			}
    
    		},
    		
    		_adaptCells: function(index) {
    			var cellStrand = cache.CellsPosition.strandY,
    				top,
    				height,
    				occupyCol,
    				occupyRow,
    				nextAlias,
    				preAlias,
    				insertAlias,
    				insertCellIndex, //插入列，经过单元格的相对索引
    				colAlias,
    				rowAlias,
    				changeCellList,
    				currentCell,
    				cellIndex,
    				attributes,
    				rule,
    				len, len2, i, j;
    
    
    			insertAlias = rows.models[index].get('alias');
    			nextAlias = rows.models[index + 1].get('alias');
    			preAlias = index > 0 ? cols.models[index - 1].get('alias') : null;
    
    			changeCellList = cells.getCellByRow(index + 1,
    				rows.length - 1);
    
    			for (i = 0, len = changeCellList.length; i < len; i++) {
    				currentCell = changeCellList[i];
    				occupyRow = currentCell.get('occupy').y;
    				insertCellIndex = occupyRow.indexOf(nextAlias);
    
    				if (insertCellIndex === -1 || insertCellIndex === 0) { //未经过单元格
    					top = currentCell.get('physicsBox').top;
    					top += config.User.cellHeight;
    					currentCell.set('physicsBox.top', top);
    				} else {
    					occupyRow.splice(insertCellIndex, 0, insertAlias);
    					height = currentCell.get('physicsBox').height;
    					height += config.User.cellHeight;
    
    					occupyCol = currentCell.get('occupy').x;
    					cellIndex = cellStrand[nextAlias][occupyCol[0]];
    					for (j = 0, len2 = occupyCol.length; j < len2; j++) {
    						cache.cachePosition(insertAlias, occupyCol[j], cellIndex);
    					}
    					currentCell.set('physicsBox.height', height);
    					currentCell.set('occupy.y', occupyRow);
    
    				}
    			}
    
    
    			if (!preAlias) {
    				return;
    			}
    
    			rowAlias = rowList[index - 1].get('alias');
    			for (i = 0, len = colList.length; i < len; i++) {
    				colAlias = colList[i].get('alias');
    				rule = strandMap.getPointRecord(colAlias, rowAlias);
    				if (rule) {
    					strandMap.addPointRecord(colAlias, insertAlias, rule);
    				}
    				currentCell = cells.getCellByVertical(i, index - 1)[0];
    				if (currentCell &&
    					(occupyRow = currentCell.get('occupy').y).indexOf(preAlias) === occupyRow.length - 1) {
    					attributes = _.clone(currentCell.attributes);
    					attributes.content.texts = '';
    					attributes.content.displayTexts = '';
    					cells.createCellModel(i, index, attributes);
    				}
    			}
    		},
    		_fillCells: function(index) {
    			var headItemColList,
    				headColModel,
    				currentStrandX,
    				rowAlias,
    				colAlias,
    				colProp,
    				len, i = 0;
    
    			headItemColList = cols.models;
    			len = cols.length;
    			rowAlias = rows.models[index].get('alias');
    			currentStrandX = cache.CellsPosition.strandX;
    			for (; i < len; i++) {
    				headColModel = headItemColList[i];
    				colProp = headColModel.get('operProp');
    				if (!isEmptyObj(colProp)) {
    					colAlias = headColModel.get('alias');
    					if (currentStrandX[colAlias] === undefined ||
    						currentStrandX[colAlias][rowAlias] === undefined) {
    						cells.createCellModel(i, index, colProp);
    					}
    				}
    			}
    
    			function isEmptyObj(obj) {
    				var i;
    				for (i in obj) {
    					return false;
    				}
    				return true;
    			}
    		}
    	};
    });
    define('entrance/tool/addcol',function() {
    	
    	var _ = require('lib/underscore'),
    		Backbone = require('lib/backbone'),
    		config = require('spreadsheet/config'),
    		cache = require('basic/tools/cache'),
    		cols = require('collections/headItemCol'),
    		rows = require('collections/headItemRow'),
    		getDisplayName = require('basic/tools/getdisplayname'),
    		getOperRegion = require('basic/tools/getoperregion'),
    		cells = require('collections/cells'),
    		selectRegions = require('collections/selectRegion'),
    		siderLineCols = require('collections/siderLineCol'),
    		send = require('basic/tools/send'),
    		strandMap = require('basic/tools/strandmap'),
    		colList = cols.models,
    		rowList = rows.models;
    
    	return {
    		
    		add: function(sheetId, label) {
    			var clip,
    				region,
    				operRegion,
    				sendRegion;
    
    			clip = selectRegions.getModelByType('clip');
    			if (clip !== undefined) {
    				cache.clipState = 'null';
    				clip.destroy();
    			}
    			if (cache.protectState) {
    				Backbone.trigger('event:showMsgBar:show', '保护状态，不能进行该操作');
    				return;
    			}
    			if (cache.TempProp.isFrozen === true) {
    				return;
    			}
    			if (!this._isAbleAdd()) {
    				return;
    			}
    			region = getOperRegion(label);
    			operRegion = region.operRegion;
    			sendRegion = region.sendRegion;
    
    			if (operRegion.endColIndex === 'MAX') {
    				return;
    			}
    
    			this._adaptHeadColItem(operRegion.startColIndex);
    			this._adaptSelectRegion(operRegion.startColIndex);
    			this._adaptCells(operRegion.startColIndex);
    			this._removeLastColItem();
    			// this._frozenHandle(operRegion.startColIndex);
    			send.PackAjax({
    				url: config.url.col.plus,
    				data: JSON.stringify({
    					sheetId: '1',
    					col: sendRegion.startCol,
    				}),
    			});
    		},
    		
    		_isAbleAdd: function() {
    			var index = cols.length - 1,
    				cellList;
    
    			cellList = cells.getCellsByColIndex(index);
    			if (cellList.length > 0) {
    				return false;
    			} else {
    				return true;
    			}
    		},
    		
    		_removeLastColItem: function() {
    			var itemModel,
    				index = cols.length - 1;
    			itemModel = cols.models[index];
    			cols.remove(itemModel);
    			itemModel.destroy();
    		},
    		
    		_adaptHeadColItem: function(index) {
    			var currentColModel,
    				width,
    				sort,
    				left,
    				len,
    				i = index + 1;
    			currentColModel = cols.models[index];
    			width = config.User.cellWidth;
    			cols.add({
    				sort: currentColModel.get('sort'),
    				alias: cache.aliasGenerator('col'),
    				left: currentColModel.get('left'),
    				width: width - 1,
    				displayName: currentColModel.get('displayName'),
    			}, {
    				at: index
    			});
    
    			len = cols.length;
    			for (; i < len; i++) {
    				currentColModel = cols.models[i];
    				left = currentColModel.get('left') + width;
    				sort = currentColModel.get('sort') + 1;
    				currentColModel.set('left', left);
    				currentColModel.set('displayName', getDisplayName.getColDisplayName(sort));
    				currentColModel.set('sort', sort);
    			}
    		},
    		
    		_adaptSelectRegion: function(index) {
    			var select,
    				insertModel,
    				startColAlias,
    				endColAlias,
    				startColIndex,
    				endColIndex,
    				lastIndex,
    				width,
    				left;
    
    			select = selectRegions.getModelByType('selected');
    
    			startColAlias = select.get('wholePosi').startX;
    			endColAlias = select.get('wholePosi').endX;
    			startColIndex = cols.getIndexByAlias(startColAlias);
    			endColIndex = cols.getIndexByAlias(endColAlias);
    
    			insertModel = cols.models[index];
    			lastIndex = cols.length - 1;
    
    			if (endColIndex < index) {
    				return;
    			}
    			//位于最后一列
    			//ps:存在bug，后期修改
    			if (lastIndex === endColIndex) {
    				if (startColIndex === endColIndex) {
    					left = insertModel.get('left');
    					width = insertModel.get('width');
    					startColAlias = insertModel.get('alias');
    					select.set('physicsBox.left', left);
    					select.set('physicsBox.width', width);
    					select.set('wholePosi.startX', startColAlias);
    					select.set('wholePosi.endX', startColAlias);
    					siderLineCols.models[0].set('left', left);
    					siderLineCols.models[0].set('width', width);
    					cols.models[lastIndex - 1].set('activeState', true);
    				} else {
    					left = select.get('physicsBox').left;
    					left += config.User.cellWidth;
    					width = select.get('physicsBox').width;
    					width -= cols.models[lastIndex].get('width');
    					endColAlias = insertModel.get('alias');
    					select.set('physicsBox.left', left);
    					select.set('physicsBox.width', width);
    					endColAlias = cols.models[endColIndex - 1].get('alias');
    					select.set('wholePosi.endX', endColAlias);
    
    					siderLineCols.models[0].set('left', left);
    					siderLineCols.models[0].set('width', width);
    				}
    				return;
    			}
    			left = select.get('physicsBox').left;
    			left += config.User.cellWidth;
    			select.set('physicsBox.left', left);
    			siderLineCols.models[0].set('left', left);
    		},
    		
    		_adaptCells: function(index) {
    			var cellStrand = cache.CellsPosition.strandX,
    				left,
    				width,
    				occupyCol,
    				occupyRow,
    				nextAlias,
    				preAlias,
    				insertAlias,
    				insertCellIndex, //插入列，经过单元格的相对索引
    				colAlias,
    				rowAlias,
    				changeCellList,
    				currentCell,
    				cellIndex,
    				attributes,
    				rule,
    				len, len2, i, j;
    
    
    			insertAlias = cols.models[index].get('alias');
    			nextAlias = cols.models[index + 1].get('alias');
    			preAlias = index > 0 ? cols.models[index - 1].get('alias') : null;
    
    			changeCellList = cells.getCellsByColIndex(index + 1,
    				cols.length - 1);
    
    			for (i = 0, len = changeCellList.length; i < len; i++) {
    				currentCell = changeCellList[i];
    				occupyCol = currentCell.get('occupy').x;
    				insertCellIndex = occupyCol.indexOf(nextAlias);
    
    				if (insertCellIndex === -1 || insertCellIndex === 0) { //未经过单元格
    					left = currentCell.get('physicsBox').left;
    					left += config.User.cellWidth;
    					currentCell.set('physicsBox.left', left);
    				} else {
    					occupyCol.splice(insertCellIndex, 0, insertAlias);
    					width = currentCell.get('physicsBox').width;
    					width += config.User.cellWidth;
    
    					occupyRow = currentCell.get('occupy').y;
    					cellIndex = cellStrand[nextAlias][occupyRow[0]];
    
    					for (j = 0, len2 = occupyRow.length; j < len2; j++) {
    						cache.cachePosition(occupyRow[j], insertAlias, cellIndex);
    					}
    					currentCell.set('physicsBox.width', width);
    					currentCell.set('occupy.x', occupyCol);
    				}
    			}
    
    
    			if (!preAlias) {
    				return;
    			}
    			//克隆过程
    			colAlias = colList[index - 1].get('alias');
    			for (i = 0, len = rowList.length; i < len; i++) {
    				rowAlias = rowList[i].get('alias');
    				rule = strandMap.getPointRecord(colAlias, rowAlias);
    				if (rule) {
    					strandMap.addPointRecord(insertAlias, rowAlias, rule);
    				}
    				currentCell = cells.getCellByVertical(index - 1, i)[0];
    				if (currentCell &&
    					(occupyCol = currentCell.get('occupy').x).indexOf(preAlias) === occupyCol.length - 1) {
    					attributes = _.clone(currentCell.attributes);
    					attributes.content.texts = '';
    					attributes.content.displayTexts = '';
    					cells.createCellModel(index, i, attributes);
    				}
    			}
    		}
    	};
    });
    define('entrance/tool/deleterow',function() {
    	
    	var Backbone = require('lib/backbone'),
    		observerPattern = require('basic/util/observer.pattern'),
    		cache = require('basic/tools/cache'),
    		config = require('spreadsheet/config'),
    		headItemRows = require('collections/headItemRow'),
    		cells = require('collections/cells'),
    		getOperRegion = require('basic/tools/getoperregion'),
    		selectRegions = require('collections/selectRegion'),
    		siderLineRows = require('collections/siderLineRow'),
    		send = require('basic/tools/send'),
    		deleteRow;
    
    	deleteRow = {
    		
    		deleteRow: function(sheetId, arrOpr) {
    			var clip,
    				region,
    				operRegion,
    				sendRegion,
    				index,
    				posi,
    				height;
    
    			clip = selectRegions.getModelByType('clip');
    			if (clip !== undefined) {
    				cache.clipState = 'null';
    				clip.destroy();
    			}
    			if (cache.protectState) {
    				Backbone.trigger('event:showMsgBar:show', '保护状态，不能进行该操作');
    				return;
    			}
    			if (cache.TempProp.isFrozen === true) {
    				return;
    			}
    			region = getOperRegion(arrOpr);
    			operRegion = region.operRegion;
    			sendRegion = region.sendRegion;
    
    			if (operRegion.endRowIndex === 'MAX' && arrOpr === undefined) {
    				return;
    			}
    
    			if (operRegion.startRowIndex === -1) {
    				sendData();
    				return;
    			}
    			index = operRegion.startRowIndex;
    			this.publish('validate', 'deleteRowPublish', headItemRows.models[index].get('alias'), index);
    
    			posi = headItemRows.models[index].get('top');
    			height = headItemRows.models[index].get('height');
    			this._adaptCells(index);
    			this._adaptSelectRegion(index);
    			this._adaptHeadRowItem(index);
    			sendData();
    			
    			Backbone.trigger('event:cellsContainer:adaptHeight');
    			Backbone.trigger('event:rowsAllHeadContainer:adaptHeight');
    			Backbone.trigger('event:mainContainer:adaptRowHeightChange', posi, -height - 1);
    			
    			function sendData() {
    				send.PackAjax({
    					url: config.url.row.reduce,
    					data: JSON.stringify({
    						row: sendRegion.startRow,
    					}),
    				});
    			}
    		},
    		
    		_adaptHeadRowItem: function(index) {
    			var currentRowModel,
    				height,
    				sort,
    				top,
    				len,
    				i = index;
    			currentRowModel = headItemRows.models[index];
    			height = currentRowModel.get('height');
    			headItemRows.remove(currentRowModel);
    			currentRowModel.destroy();
    
    			len = headItemRows.length;
    			for (; i < len; i++) {
    				currentRowModel = headItemRows.models[i];
    				top = currentRowModel.get('top') - height - 1;
    				sort = currentRowModel.get('sort') - 1;
    				currentRowModel.set('top', top);
    				currentRowModel.set('displayName', (sort + 1).toString());
    				currentRowModel.set('sort', sort);
    			}
    		},
    		
    		_adaptSelectRegion: function(index) {
    			var select,
    				startRowAlias,
    				endRowAlias,
    				startRowIndex,
    				height,
    				top,
    				endRowIndex;
    
    
    			select = selectRegions.getModelByType('selected');
    			startRowAlias = select.get('wholePosi').startY;
    			endRowAlias = select.get('wholePosi').endY;
    			top = select.get('physicsBox').top;
    			height = select.get('physicsBox').height;
    			startRowIndex = headItemRows.getIndexByAlias(startRowAlias);
    			endRowIndex = headItemRows.getIndexByAlias(endRowAlias);
    
    			if (endRowIndex < index) {
    				return;
    			}
    			if (startRowIndex === index) {
    				if (endRowIndex === startRowIndex) {
    					height = headItemRows.models[index + 1].get('height');
    					endRowAlias = headItemRows.models[index + 1].get('alias');
    					select.set('wholePosi.endY', endRowAlias);
    					select.set('wholePosi.startY', endRowAlias);
    					headItemRows.models[index + 1].set('activeState', true);
    				} else {
    					height = height - headItemRows.models[index].get('height') - 1;
    				}
    				startRowAlias = headItemRows.models[index + 1].get('alias');
    				select.set('wholePosi.startY', startRowAlias);
    				select.set('physicsBox.height', height);
    			}
    			if (endRowIndex !== startRowIndex && endRowIndex === index) {
    				height = select.get('physicsBox').height;
    				height = height - headItemRows.models[index].get('height') - 1;
    				endRowAlias = headItemRows.models[index - 1].get('alias');
    				select.set('wholePosi.endY', endRowAlias);
    			}
    			if (startRowIndex < index && endRowIndex > index) {
    				height = select.get('physicsBox').height;
    				height = height - headItemRows.models[index].get('height') - 1;
    				select.set('physicsBox.height', height);
    			}
    
    			if (startRowIndex > index) {
    				top = top - headItemRows.models[index].get('height') - 1;
    				select.set('physicsBox.top', top);
    			}
    			siderLineRows.models[0].set('height', height);
    		},
    		
    		_adaptCells: function(index) {
    			var height,
    				deleteAlias,
    				rowAlias,
    				aliasRowArray,
    				aliasColArray,
    				startIndex,
    				cellsList,
    				aliasLen,
    				len, i = 0,
    				j,
    				tempCell,
    				top;
    
    			cellsList = cells.getCellByRow(index,
    				headItemRows.length - 1);
    
    			deleteAlias = headItemRows.models[index].get('alias');
    			len = cellsList.length;
    			for (; i < len; i++) {
    				tempCell = cellsList[i];
    				aliasRowArray = tempCell.get('occupy').y;
    				aliasColArray = tempCell.get('occupy').x;
    				aliasLen = aliasColArray.length;
    				rowAlias = aliasRowArray[0];
    				startIndex = headItemRows.getIndexByAlias(rowAlias);
    
    				if (startIndex === index && aliasRowArray.length === 1) {
    					tempCell.set('isDestroy', true);
    				} else if (startIndex <= index) {
    					height = tempCell.get('physicsBox').height;
    					height -= headItemRows.models[index].get('height');
    					tempCell.set('physicsBox.height', height - 1);
    					aliasRowArray.splice(index - startIndex, 1);
    					tempCell.set('occupy.y', aliasRowArray);
    				} else if (startIndex > index) {
    					top = tempCell.get('physicsBox').top;
    					top = top - headItemRows.models[index].get('height') - 1;
    					tempCell.set('physicsBox.top', top);
    				}
    				for (j = 0; j < aliasLen; j++) {
    					cache.deletePosi(deleteAlias, aliasColArray[j]);
    				}
    			}
    		}
    	};
    	observerPattern.buildPublisher(deleteRow);
    	return deleteRow;
    });
    define('entrance/tool/deletecol',function() {
    	
    	var Backbone = require('lib/backbone'),
    		observerPattern = require('basic/util/observer.pattern'),
    		cache = require('basic/tools/cache'),
    		config = require('spreadsheet/config'),
    		headItemCols = require('collections/headItemCol'),
    		getOperRegion = require('basic/tools/getoperregion'),
    		getDisplayName = require('basic/tools/getdisplayname'),
    		cells = require('collections/cells'),
    		selectRegions = require('collections/selectRegion'),
    		siderLineCols = require('collections/siderLineCol'),
    		send = require('basic/tools/send'),
    		deleteCol;
    
    	deleteCol = {
    		
    		deleteCol: function(sheetId, arrOpr) {
    			var clip,
    				region,
    				operRegion,
    				sendRegion,
    				index;
    
    			clip = selectRegions.getModelByType('clip');
    			if (clip !== undefined) {
    				cache.clipState = 'null';
    				clip.destroy();
    			}
    			if (cache.protectState) {
    				Backbone.trigger('event:showMsgBar:show', '保护状态，不能进行该操作');
    				return;
    			}
    			if (cache.TempProp.isFrozen === true) {
    				return;
    			}
    			region = getOperRegion(arrOpr);
    			operRegion = region.operRegion;
    			sendRegion = region.sendRegion;
    
    			if (operRegion.endColIndex === 'MAX' && arrOpr === undefined) {
    				return;
    			}
    
    			if (operRegion.startRowIndex === -1) {
    				sendData();
    				return;
    			}
    			index = operRegion.startColIndex;
    
    			this.publish('validate', 'deleteColPublish', headItemCols.models[index].get('alias'), index);
    			this._addColItem();
    			this._adaptCells(index);
    			this._adaptSelectRegion(index);
    			this._adaptHeadColItem(index);
    			sendData();
    
    			Backbone.trigger('event:cellsContainer:adaptWidth');
    			Backbone.trigger('event:colsAllHeadContainer:adaptWidth');
    
    			function sendData() {
    				send.PackAjax({
    					url: config.url.col.reduce,
    					data: JSON.stringify({
    						col: sendRegion.startCol,
    					}),
    				});
    			}
    		},
    		
    		_addColItem: function() {
    			var index = headItemCols.length,
    				previousModel = headItemCols.models[index - 1];
    
    			headItemCols.add({
    				sort: previousModel.get('sort') + 1,
    				alias: cache.aliasGenerator('col'),
    				left: previousModel.get('left') + previousModel.get('width') + 1
    			});
    		},
    		
    		_adaptHeadColItem: function(index) {
    			var currentColModel,
    				width,
    				sort,
    				left,
    				len,
    				i = index;
    			currentColModel = headItemCols.models[index];
    			width = currentColModel.get('width');
    			headItemCols.remove(currentColModel);
    			currentColModel.destroy();
    
    			len = headItemCols.length;
    			for (; i < len; i++) {
    				currentColModel = headItemCols.models[i];
    				left = currentColModel.get('left') - width - 1;
    				sort = currentColModel.get('sort') - 1;
    				currentColModel.set('left', left);
    				currentColModel.set('displayName', getDisplayName.getColDisplayName(i));
    				currentColModel.set('sort', sort);
    			}
    		},
    		
    		_adaptSelectRegion: function(index) {
    			var select,
    				startColAlias,
    				endColAlias,
    				startColIndex,
    				endColIndex,
    				width,
    				left;
    
    			select = selectRegions.getModelByType('selected');
    			startColAlias = select.get('wholePosi').startX;
    			endColAlias = select.get('wholePosi').endX;
    			startColIndex = headItemCols.getIndexByAlias(startColAlias);
    			endColIndex = headItemCols.getIndexByAlias(endColAlias);
    			left = select.get('physicsBox').left;
    			width = select.get('physicsBox').width;
    
    			if (endColIndex < index) {
    				return;
    			}
    			if (startColIndex === index) {
    				if (endColIndex === startColIndex) {
    					width = headItemCols.models[index + 1].get('width');
    					endColAlias = headItemCols.models[index + 1].get('alias');
    					select.set('wholePosi.endX', endColAlias);
    					select.set('wholePosi.startX', endColAlias);
    					headItemCols.models[index + 1].set('activeState', true);
    				} else {
    					width = width - headItemCols.models[index].get('width') - 1;
    				}
    				startColAlias = headItemCols.models[index + 1].get('alias');
    				select.set('wholePosi.startX', startColAlias);
    				select.set('physicsBox.width', width);
    
    			}
    			if (endColIndex !== startColIndex && endColIndex === index) {
    				width = select.get('physicsBox').width;
    				width = width - headItemCols.models[index].get('width') - 1;
    				endColAlias = headItemCols.models[index - 1].get('alias');
    				select.set('wholePosi.endX', endColAlias);
    			}
    			if (startColIndex < index && endColIndex > index) {
    				width = select.get('physicsBox').width;
    				width = width - headItemCols.models[index].get('width') - 1;
    				select.set('physicsBox.width', width);
    			}
    
    			if (startColIndex > index) {
    				left = left - headItemCols.models[index].get('width') - 1;
    				select.set('physicsBox.left', left);
    			}
    			siderLineCols.models[0].set('width', width);
    		},
    		
    		_adaptCells: function(index) {
    			var width,
    				left,
    				deleteAlias,
    				colAlias,
    				aliasRowArray,
    				aliasColArray,
    				startIndex,
    				cellsList,
    				aliasLen,
    				len, i = 0,
    				j,
    				tempCell;
    
    			cellsList = cells.getCellsByColIndex(index,
    				headItemCols.length - 1);
    
    			deleteAlias = headItemCols.models[index].get('alias');
    
    			len = cellsList.length;
    			for (; i < len; i++) {
    				tempCell = cellsList[i];
    				aliasRowArray = tempCell.get('occupy').y;
    				aliasColArray = tempCell.get('occupy').x;
    				aliasLen = aliasRowArray.length;
    				colAlias = aliasColArray[0];
    
    				startIndex = headItemCols.getIndexByAlias(colAlias);
    
    				if (startIndex === index && aliasColArray.length === 1) {
    					tempCell.set('isDestroy', true);
    
    				} else if (startIndex <= index) {
    
    					width = tempCell.get('physicsBox').width;
    					width -= headItemCols.models[index].get('width');
    					tempCell.set('physicsBox.width', width - 1);
    					aliasColArray.splice(index - startIndex, 1);
    					tempCell.set('occupy.x', aliasColArray);
    
    				} else if (startIndex > index) {
    					left = tempCell.get('physicsBox').left;
    					left = left - headItemCols.models[index].get('width') - 1;
    					tempCell.set('physicsBox.left', left);
    				}
    				for (j = 0; j < aliasLen; j++) {
    					cache.deletePosi(aliasRowArray[j], deleteAlias);
    				}
    			}
    		},
    	};
    	observerPattern.buildPublisher(deleteCol);
    	return deleteCol;
    });
    
    define('entrance/tool/regiondel',function() {
    	var send = require('basic/tools/send'),
    		selectRegions = require('collections/selectRegion'),
    		getOperRegion = require('basic/tools/getoperregion'),
    		cache = require('basic/tools/cache'),
    		cells = require('collections/cells'),
    		regionDel;
    
    	
    	regionDel = function(sheetId, label) {
    		var clip,
    			region,
    			operRegion,
    			sendRegion;
    
    		clip = selectRegions.getModelByType('clip');
    		if (clip !== undefined) {
    			cache.clipState = 'null';
    			clip.destroy();
    		}
    		region = getOperRegion(label);
    		operRegion = region.operRegion;
    		sendRegion = region.sendRegion;
    
    		if (operRegion.startColIndex === -1 || operRegion.startRowIndex === -1) {
    			sendData();
    			return;
    		}
    
    		cells.oprCellsByRegion(operRegion, function(cell) {
    			cell.set('content.texts', '');
    			cell.set('content.displayTexts', '');
    		});
    		
    		sendData();
    
    		function sendData() {
    			send.PackAjax({
    				url: 'text.htm?m=data_del',
    				data: JSON.stringify({
    					coordinate: sendRegion
    				})
    			});
    		}
    
    	};
    	return regionDel;
    });
    
    define('entrance/col/colhide',function() {
    	var send = require('basic/tools/send'),
    		config = require('spreadsheet/config'),
    		selectRegions = require('collections/selectRegion'),
    		headItemCols = require('collections/headItemCol'),
    		headItemRows = require('collections/headItemRow'),
    		siderLineCols = require('collections/siderLineCol'),
    		Backbone = require('lib/backbone'),
    		cells = require('collections/cells'),
    		cache = require('basic/tools/cache'),
    		getOperRegion = require('basic/tools/getoperregion');
    
    	return {
    		hide: function(sheetId, label) {
    			var clip,
    				region,
    				colindex,
    				colSort,
    				adjustWidth,
    				headItemColList,
    				len;
    
    			clip = selectRegions.getModelByType('clip');
    			if (clip !== undefined) {
    				cache.clipState = 'null';
    				clip.destroy();
    			}
    			if (cache.protectState) {
    				Backbone.trigger('event:showMsgBar:show', '保护状态，不能进行该操作');
    				return;
    			}
    			if (cache.TempProp.isFrozen) {
    				return;
    			}
    			region = getOperRegion(label);
    			if (region.operRegion.endRowIndex !== 'MAX' && label === undefined) {
    				return;
    			}
    
    			headItemColList = headItemCols.models;
    			len = headItemColList.length;
    
    			colindex = region.operRegion.startColIndex;
    			colSort = region.sendRegion.startColSort;
    			if (headItemColList[colindex].get('hidden')) {
    				return;
    			}
    			adjustWidth = headItemColList[colindex].get('width');
    
    			//不能进行全部隐藏
    			if (headItemColList[len - 1].get('left') === 0 ||
    				(headItemColList[len - 1].get('left') === adjustWidth + 1 &&
    					headItemColList[len - 1].get('hidden'))
    			) {
    				return;
    			}
    
    
    			this._adjustHideHeadItemCols(colindex, adjustWidth);
    			this._adjustHideCells(colindex, adjustWidth);
    			this._adjustHideSelectRegion(colindex, adjustWidth);
    			Backbone.trigger('event:cellsContainer:adaptWidth');
    
    			send.PackAjax({
    				url: config.url.col.hide,
    				data: JSON.stringify({
    					sheetId: '1',
    					col: headItemColList[colindex].get('sort')
    				})
    			});
    
    		},
    		_adjustHideCells: function(index) {
    			var cellList,
    				tempCell,
    				colAliasList,
    				currentWidth,
    				width,
    				alias,
    				left,
    				i, len;
    			cellList = cells.getCellByVertical(index, 0, 'MAX', 'MAX');
    			alias = headItemCols.models[index].get('alias');
    			width = headItemCols.models[index].get('originalWidth');
    			len = cellList.length;
    			for (i = 0; i < len; i++) {
    				tempCell = cellList[i];
    				colAliasList = tempCell.get('occupy').x;
    				if (colAliasList.length === 1) {
    					if (colAliasList[0] === alias) {
    						tempCell.set('physicsBox.width', 0);
    						tempCell.set('hidden', true);
    					} else {
    						left = tempCell.get('physicsBox').left;
    						tempCell.set('physicsBox.left', left - width - 1);
    					}
    				} else {
    					if (colAliasList.indexOf(alias) !== -1) {
    						currentWidth = tempCell.get('physicsBox').width;
    						if (currentWidth === width) {
    							tempCell.set('physicsBox.width', 0);
    							tempCell.set('hidden', true);
    						} else {
    							tempCell.set('physicsBox.width', currentWidth - width - 1);
    						}
    					} else {
    						left = tempCell.get('physicsBox').left;
    						tempCell.set('physicsBox.left', left - width - 1);
    					}
    
    				}
    			}
    		},
    		_adjustHideSelectRegion: function(index) {
    			var headItemColList = headItemCols.models,
    				headItemRowList = headItemRows.models,
    				colLen = headItemColList.length,
    				rowLen = headItemRowList.length,
    				headItemModel,
    				lastHeadItemLeft,
    				select,
    				colAlias,
    				rowStartAlias,
    				width,
    				height,
    				left, i;
    
    			select = selectRegions.getModelByType('selected');
    			lastHeadItemLeft = headItemColList[colLen - 1].get('left');
    			left = headItemColList[index].get('left');
    			//处理只剩一列情况
    			if (lastHeadItemLeft === 0) { //最后一列隐藏
    				i = index + 1;
    				while (headItemColList[i].get('hidden')) {
    					i++;
    				}
    			} else {
    				i = index - 1;
    				while (i > -1 && headItemColList[i].get('hidden')) {
    					i--;
    				}
    			}
    			if (i === -1) {
    				i = index + 1;
    				while (headItemColList[i].get('hidden')) {
    					i++;
    				}
    			}
    			headItemModel = headItemColList[i];
    			headItemModel.set('activeState', true);
    			colAlias = headItemModel.get('alias');
    			rowStartAlias = headItemRowList[0].get('alias');
    			height = headItemRowList[rowLen - 1].get('top') + headItemRowList[rowLen - 1].get('height');
    			width = headItemModel.get('width');
    			left = headItemModel.get('left');
    
    			select.set('tempPosi', {
    				initColIndex: i,
    				initRowIndex: 0,
    				mouseColIndex: i,
    				mouseRowIndex: 'MAX'
    			});
    		},
    		_adjustHideHeadItemCols: function(index) {
    			var headItemColList = headItemCols.models,
    				len = headItemColList.length,
    				lastHeadItemLeft,
    				width,
    				left,
    				i;
    			if (index > 0) {
    				headItemColList[index - 1].set('isRightAjacentHide', true);
    			}
    			width = headItemColList[index].get('width');
    			headItemColList[index].set('hidden', true);
    			headItemColList[index].set('width', 0);
    			headItemColList[index].set('activeState', false);
    			left = headItemColList[index].get('left');
    			lastHeadItemLeft = headItemColList[len - 1].get('left');
    
    			if (index < len - 1) {
    				left = headItemColList[index + 1].get('left');
    				headItemColList[index + 1].set('left', left - width - 1);
    				headItemColList[index + 1].set('isLeftAjacentHide', true);
    			}
    			for (i = index + 2; i < len; i++) {
    				left = headItemColList[i].get('left');
    				headItemColList[i].set('left', left - width - 1);
    			}
    		},
    		cancelHide: function() {
    			var headItemColList = headItemCols.models,
    				len = headItemColList.length,
    				clip,
    				hidden,
    				cellList,
    				cellLen,
    				cellWidth,
    				cellLeft,
    				headItemLeft,
    				headItemAlias,
    				moveWidth = 0, //取消隐藏时，单元格，列对象，向右移动宽度
    				width,
    				i = 0,
    				j;
    
    			if (cache.TempProp.isFrozen) {
    				return;
    			}
    			clip = selectRegions.getModelByType('clip');
    			if (clip !== undefined) {
    				cache.clipState = 'null';
    				clip.destroy();
    			}
    			if (cache.protectState) {
    				Backbone.trigger('event:showMsgBar:show', '保护状态，不能进行该操作');
    				return;
    			}
    			Backbone.trigger('event:restoreHideCellView');
    			Backbone.trigger('event:restoreHideCols');
    
    			for (; i < len; i++) {
    				headItemAlias = headItemColList[i].get('alias');
    				if (headItemColList[i].get('hidden')) {
    					if (i > 0) {
    						headItemColList[i - 1].set('isRightAjacentHide', false);
    					}
    					if (i < len - 1) {
    						headItemColList[i + 1].set('isLeftAjacentHide', false);
    					}
    					width = headItemColList[i].get('originalWidth');
    					//当前列单元格调整宽度
    					cellList = cells.getCellByVertical(i, 0, i, 'MAX');
    					cellLen = cellList.length;
    					headItemColList[i].set('width', width);
    					headItemLeft = headItemColList[i].get('left');
    					headItemColList[i].set('left', headItemLeft + moveWidth);
    					headItemColList[i].set('hidden', false);
    					for (j = 0; j < cellLen; j++) {
    						cellWidth = cellList[j].get('physicsBox').width;
    						hidden = cellList[j].get('hidden');
    						if (!hidden) {
    							cellList[j].set('physicsBox.width', cellWidth + width + 1);
    						} else {
    							cellList[j].set('physicsBox.width', cellWidth + width);
    							cellList[j].set('hidden', false);
    						}
    						if (headItemAlias === cellList[j].get('occupy').x[0]) {
    							cellLeft = cellList[j].get('physicsBox').left;
    							cellList[j].set('physicsBox.left', cellLeft + moveWidth);
    						}
    					}
    					moveWidth += (width + 1);
    				} else if (moveWidth !== 0) {
    					//调整单元格left值
    					cellList = cells.getCellByVertical(i, 0, i, 'MAX');
    					cellLen = cellList.length;
    					for (j = 0; j < cellLen; j++) {
    						if (headItemAlias === cellList[j].get('occupy').x[0]) {
    							cellLeft = cellList[j].get('physicsBox').left;
    							cellList[j].set('physicsBox.left', cellLeft + moveWidth);
    						}
    					}
    					//调整列的left值
    					headItemLeft = headItemColList[i].get('left');
    					headItemColList[i].set('left', headItemLeft + moveWidth);
    				}
    			}
    			this._adjustCancelHideSelectRegion();
    			Backbone.trigger('event:cellsContainer:adaptWidth');
    			Backbone.trigger('event:colsAllHeadContainer:adaptWidth');
    			send.PackAjax({
    				sheetId: '1',
    				url: config.url.col.show
    			});
    
    		},
    		_adjustCancelHideSelectRegion: function() {
    			var headItemColList = headItemCols.models,
    				startColIndex,
    				endColIndex,
    				select,
    				left,
    				width = 0;
    			select = selectRegions.getModelByType('selected');
    			startColIndex = headItemCols.getIndexByAlias(select.get('wholePosi').startX);
    			endColIndex = headItemCols.getIndexByAlias(select.get('wholePosi').endX);
    			left = headItemColList[startColIndex].get('left');
    			for (var i = startColIndex; i < endColIndex + 1; i++) {
    				width += (headItemColList[i].get('width') + 1);
    			}
    			select.set('physicsBox.width', width - 1);
    			select.set('physicsBox.left', left);
    			siderLineCols.models[0].set('left', left);
    			siderLineCols.models[0].set('width', width - 1);
    		}
    	};
    });
    define('entrance/tool/batchsetbg',function() {
    	
    	var Backbone = require('lib/backbone'),
    		send = require('basic/tools/send'),
    		cache = require('basic/tools/cache'),
    		config = require('spreadsheet/config'),
    		cells = require('collections/cells'),
    		headItemCols = require('collections/headItemCol'),
    		headItemRows = require('collections/headItemRow'),
    		rowOperate = require('entrance/row/rowoperation'),
    		colOperate = require('entrance/col/coloperation'),
    		weight;
    
    	var setBg = {
    		set: function(sheeId, color, arrOper) {
    			var regColor = /^rgb\(((25[0-5]|2[0-4][0-9]|[0-1]?[0-9]?[0-9]),){2}(25[0-5]|2[0-4][0-9]|[0-1]?[0-9]?[0-9])\)$/,
    				regions, i, len,
    				oper, sendData;
    
    			if (arguments.length < 3) {
    				arrOper = color;
    				color = sheeId;
    			}
    			color = color.replace(/\s/g, '');
    			
    			if (cache.protectState) {
    				Backbone.trigger('event:showMsgBar:show', '保护状态，不能进行该操作');
    				return;
    			}
    			if (!regColor.test(color)) {
    				throw new Error('非法参数');
    			}
    			regions = this._parse(arrOper);
    			oper = regions.oper;
    			sendData = regions.send;
    			for (i = 0, len = oper.length; i < len; i++) {
    				if (oper[i].endColIndex === -1) {
    					rowOperate.rowPropOper(oper[i].endRowIndex, 'customProp.background', color);
    				} else if (oper[i].endRowIndex === -1) {
    					colOperate.colPropOper(oper[i].endColIndex, 'customProp.background', color);
    				} else {
    					cells.oprCellsByRegion(oper[i], callback, color);
    				}
    			}
    
    			function callback(cell, colSort, rowSort, value) {
    				var original;
    				if ((original = cell.get('customProp').background) !== value) {
    					cell.set('customProp.background', value);
    				}
    			}
    			send.PackAjax({
    				url: config.url.cell.bgBatch,
    				data: JSON.stringify({
    					coordinate: sendData,
    					color: color
    				})
    			});
    
    		},
    		_getWeight: function() {
    			var sign,
    				result = {},
    				arr, len, i, count = 1;
    
    			sign = 'A B C D E F G H I J K L M N O P Q R S T U V W X Y Z ';
    			sign += 'a b c d e f g h i j k l m n o p q r s t u v w x y z';
    			arr = sign.split(' ');
    			for (i = 0, len = arr.length; i < len; i++, count++) {
    				result[arr[i]] = count;
    				if (i === 25) {
    					count = 0;
    				}
    			}
    			return result;
    		},
    		_parse: function(arrOper) {
    			var regCol = /^[a-zA-Z]+$/,
    				regRow = /^[1-9]\d*$/,
    				maxRowNum = config.User.maxRowNum,
    				maxColNum = config.User.maxColNum,
    				startCol, startRow, endCol, endRow,
    				oper = [],
    				send = [],
    				point,
    				temp,
    				len, i;
    
    			if (!weight) {
    				weight = this._getWeight();
    			}
    			if (Object.prototype.toString.call(arrOper) !== '[object Array]') {
    				arrOper = [arrOper];
    			}
    			for (i = 0, len = arrOper.length; i < len; i++) {
    				point = arrOper[i];
    				//整行或整列操作
    				if (typeof point === 'string') {
    					if (regCol.test(point) && (startCol = colToSort(point)) <= maxColNum) {
    						send.push({
    							startCol: startCol,
    							endCol: startCol,
    							startRow: 0,
    							endRow: -1
    						});
    						startCol = headItemCols.getIndexBySort(startCol);
    						oper.push({
    							startColIndex: startCol,
    							endColIndex: startCol,
    							startRowIndex: 0,
    							endRowIndex: -1
    						});
    						continue;
    					}
    					if (regRow.test(point) && (startRow = rowToSort(point)) <= maxRowNum) {
    						send.push({
    							startCol: 0,
    							endCol: -1,
    							startRow: startRow,
    							endRow: startRow
    						});
    						startRow = headItemRows.getIndexBySort(startRow);
    						oper.push({
    							startColIndex: 0,
    							endColIndex: -1,
    							startRowIndex: startRow,
    							endRowIndex: startRow
    						});
    						continue;
    					}
    					throw new Error('非法参数');
    				}
    
    				point.endRow = point.endRow === undefined ? point.startRow : point.endRow;
    				point.endCol = point.endCol === undefined ? point.startCol : point.endCol;
    				startCol = point.startCol;
    				if (startCol === undefined || !regCol.test(startCol) || (startCol = colToSort(startCol)) >= maxColNum) {
    					throw new Error('非法参数');
    				}
    				endCol = point.endCol;
    				if ((endCol = colToSort(endCol)) > maxColNum) {
    					throw new Error('非法参数');
    				}
    				if (startCol > endCol) {
    					temp = startCol;
    					startCol = endCol;
    					endCol = temp;
    				}
    				startRow = point.startRow;
    				if (startRow === undefined || !regRow.test(startRow) || (startRow = rowToSort(startRow)) >= maxRowNum) {
    					throw new Error('非法参数');
    				}
    				endRow = point.endRow;
    				if ((endRow = rowToSort(endRow)) > maxRowNum) {
    					throw new Error('非法参数');
    				}
    				if (startRow > endRow) {
    					temp = startRow;
    					startRow = endRow;
    					endRow = temp;
    				}
    				send.push({
    					startCol: startCol,
    					startRow: startRow,
    					endCol: endCol,
    					endRow: endRow
    				});
    				startCol = headItemCols.getIndexBySort(startCol);
    				startRow = headItemRows.getIndexBySort(startRow);
    				endCol = headItemCols.getIndexBySort(endCol);
    				endRow = headItemRows.getIndexBySort(endRow);
    				oper.push({
    					startColIndex: startCol,
    					startRowIndex: startRow,
    					endColIndex: endCol,
    					endRowIndex: endRow
    				});
    			}
    			return {
    				send: send,
    				oper: oper
    			};
    
    			function colToSort(str) {
    				var count = -1,
    					i, len;
    				for (i = 0, len = str.length; i < len; i++) {
    					count += weight[str[i]] * (Math.pow(26, (len - i - 1)));
    				}
    				return count;
    			}
    
    			function rowToSort(str) {
    				return Number(str) - 1;
    			}
    		},
    	};
    	return setBg;
    });
    
    define('entrance/tool/comment',function() {
    	var send = require('basic/tools/send'),
    		cells = require('collections/cells'),
    		Backbone = require('lib/backbone'),
    		config = require('spreadsheet/config'),
    		selectRegions = require('collections/selectRegion'),
    		getOperRegion = require('basic/tools/getoperregion'),
    		history = require('basic/tools/history'),
    		headItemCols = require('collections/headItemCol'),
    		headItemRows = require('collections/headItemRow'),
    		rowOperate = require('entrance/row/rowoperation'),
    		colOperate = require('entrance/col/coloperation'),
    		cache = require('basic/tools/cache'),
    		commentHandler;
    
    	commentHandler = {
    		before: function() {
    			var clip = selectRegions.getModelByType('clip');
    			if (clip !== undefined) {
    				cache.clipState = 'null';
    				clip.destroy();
    			}
    			if (cache.protectState) {
    				Backbone.trigger('event:showMsgBar:show', '保护状态，不能进行该操作');
    				return true;
    			}
    		},
    		modifyComment: function(sheetId, comment, label) {
    			var region,
    				operRegion,
    				sendRegion,
    				headItemRowList = headItemRows.models,
    				headItemColList = headItemCols.models,
    				changeModelList = [];
    
    			if (this.before()) {
    				return;
    			}
    			region = getOperRegion(label);
    			operRegion = region.operRegion;
    			sendRegion = region.sendRegion;
    
    			if (operRegion.startColIndex === -1 || operRegion.startRowIndex === -1) {
    				if (comment === null) {
    					this.sendData(sendRegion, null, config.url.cell.commentDel);
    				} else {
    					this.sendData(sendRegion, comment, config.url.cell.commentPlus);
    				}
    				return;
    			}
    
    			if (operRegion.endColIndex === 'MAX') { //整行操作
    				rowOperate.rowPropOper(operRegion.startRowIndex, operRegion.endRowIndex, 'customProp.comment', comment);
    			} else if (operRegion.endRowIndex === 'MAX') {
    				colOperate.colPropOper(operRegion.startColIndex, operRegion.endColIndex, 'customProp.comment', comment);
    			} else {
    				cells.oprCellsByRegion(operRegion, function(cell, colSort, rowSort) {
    					if (cell.get('customProp').comment !== comment) {
    						changeModelList.push({
    							colSort: colSort,
    							rowSort: rowSort,
    							value: cell.get('customProp').comment
    						});
    						cell.set('customProp.comment', comment);
    					}
    				});
    				history.addAction(history.getCellPropUpdateAction('customProp.comment', comment, {
    					startColSort: headItemColList[operRegion.startColIndex].get('sort'),
    					startRowSort: headItemRowList[operRegion.startRowIndex].get('sort'),
    					endColSort: headItemColList[operRegion.endColIndex].get('sort'),
    					endRowSort: headItemRowList[operRegion.endRowIndex].get('sort')
    				}, changeModelList));
    
    			}
    			if (comment === null) {
    				this.sendData(sendRegion, null, config.url.cell.commentDel);
    			} else {
    				this.sendData(sendRegion, comment, config.url.cell.commentPlus);
    			}
    		},
    		createAddCommentView: function() {
    			if (this.before()) {
    				return;
    			}
    			Backbone.trigger('event:bodyContainer:handleComment', {
    				'action': 'add',
    			});
    		},
    		createEditComment: function() {
    			if (this.before()) {
    				return;
    			}
    			Backbone.trigger('event:bodyContainer:handleComment', {
    				'action': 'edit'
    			});
    		},
    
    		deleteComment: function(label) {
    			if (this.before()) {
    				return;
    			}
    			this.modifyComment('1', null, label);
    		},
    		sendData: function(sendRegion, comment, url) {
    			var data = {
    				coordinate: sendRegion
    			};
    			if (comment !== null) {
    				data.comment = comment;
    			}
    			send.PackAjax({
    				url: url,
    				data: JSON.stringify(data)
    			});
    		}
    	};
    	return commentHandler;
    });
    
    define('lib/handlebars',function() {
    	return  (function(modules) { // webpackBootstrap
    			 // The module cache
    			
    			var installedModules = {};
    
    			 // The require function
    			
    			function __webpack_require__(moduleId) {
    
    				 // Check if module is in cache
    				
    				if (installedModules[moduleId])
    				
    					return installedModules[moduleId].exports;
    
    				 // Create a new module (and put it into the cache)
    				
    				var module = installedModules[moduleId] = {
    					
    					exports: {},
    					
    					id: moduleId,
    					
    					loaded: false
    						
    				};
    
    				 // Execute the module function
    				
    				modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
    
    				 // Flag the module as loaded
    				
    				module.loaded = true;
    
    				 // Return the exports of the module
    				
    				return module.exports;
    				
    			}
    
    
    			 // expose the modules object (__webpack_modules__)
    			
    			__webpack_require__.m = modules;
    
    			 // expose the module cache
    			
    			__webpack_require__.c = installedModules;
    
    			 // __webpack_public_path__
    			
    			__webpack_require__.p = "";
    
    			 // Load entry module and return exports
    			
    			return __webpack_require__(0);
    			
    		})
    		
    		
    		([
    			
    			
    			function(module, exports, __webpack_require__) {
    
    				
    
    				var _interopRequireDefault = __webpack_require__(1)['default'];
    
    				exports.__esModule = true;
    
    				var _handlebarsRuntime = __webpack_require__(2);
    
    				var _handlebarsRuntime2 = _interopRequireDefault(_handlebarsRuntime);
    
    				// Compiler imports
    
    				var _handlebarsCompilerAst = __webpack_require__(21);
    
    				var _handlebarsCompilerAst2 = _interopRequireDefault(_handlebarsCompilerAst);
    
    				var _handlebarsCompilerBase = __webpack_require__(22);
    
    				var _handlebarsCompilerCompiler = __webpack_require__(27);
    
    				var _handlebarsCompilerJavascriptCompiler = __webpack_require__(28);
    
    				var _handlebarsCompilerJavascriptCompiler2 = _interopRequireDefault(_handlebarsCompilerJavascriptCompiler);
    
    				var _handlebarsCompilerVisitor = __webpack_require__(25);
    
    				var _handlebarsCompilerVisitor2 = _interopRequireDefault(_handlebarsCompilerVisitor);
    
    				var _handlebarsNoConflict = __webpack_require__(20);
    
    				var _handlebarsNoConflict2 = _interopRequireDefault(_handlebarsNoConflict);
    
    				var _create = _handlebarsRuntime2['default'].create;
    
    				function create() {
    					var hb = _create();
    
    					hb.compile = function(input, options) {
    						return _handlebarsCompilerCompiler.compile(input, options, hb);
    					};
    					hb.precompile = function(input, options) {
    						return _handlebarsCompilerCompiler.precompile(input, options, hb);
    					};
    
    					hb.AST = _handlebarsCompilerAst2['default'];
    					hb.Compiler = _handlebarsCompilerCompiler.Compiler;
    					hb.JavaScriptCompiler = _handlebarsCompilerJavascriptCompiler2['default'];
    					hb.Parser = _handlebarsCompilerBase.parser;
    					hb.parse = _handlebarsCompilerBase.parse;
    
    					return hb;
    				}
    
    				var inst = create();
    				inst.create = create;
    
    				_handlebarsNoConflict2['default'](inst);
    
    				inst.Visitor = _handlebarsCompilerVisitor2['default'];
    
    				inst['default'] = inst;
    
    				exports['default'] = inst;
    				module.exports = exports['default'];
    
    				
    			},
    			
    			
    			function(module, exports) {
    
    				
    
    				exports["default"] = function(obj) {
    					return obj && obj.__esModule ? obj : {
    						"default": obj
    					};
    				};
    
    				exports.__esModule = true;
    
    				
    			},
    			
    			
    			function(module, exports, __webpack_require__) {
    
    				
    
    				var _interopRequireWildcard = __webpack_require__(3)['default'];
    
    				var _interopRequireDefault = __webpack_require__(1)['default'];
    
    				exports.__esModule = true;
    
    				var _handlebarsBase = __webpack_require__(4);
    
    				var base = _interopRequireWildcard(_handlebarsBase);
    
    				// Each of these augment the Handlebars object. No need to setup here.
    				// (This is done to easily share code between commonjs and browse envs)
    
    				var _handlebarsSafeString = __webpack_require__(18);
    
    				var _handlebarsSafeString2 = _interopRequireDefault(_handlebarsSafeString);
    
    				var _handlebarsException = __webpack_require__(6);
    
    				var _handlebarsException2 = _interopRequireDefault(_handlebarsException);
    
    				var _handlebarsUtils = __webpack_require__(5);
    
    				var Utils = _interopRequireWildcard(_handlebarsUtils);
    
    				var _handlebarsRuntime = __webpack_require__(19);
    
    				var runtime = _interopRequireWildcard(_handlebarsRuntime);
    
    				var _handlebarsNoConflict = __webpack_require__(20);
    
    				var _handlebarsNoConflict2 = _interopRequireDefault(_handlebarsNoConflict);
    
    				// For compatibility and usage outside of module systems, make the Handlebars object a namespace
    				function create() {
    					var hb = new base.HandlebarsEnvironment();
    
    					Utils.extend(hb, base);
    					hb.SafeString = _handlebarsSafeString2['default'];
    					hb.Exception = _handlebarsException2['default'];
    					hb.Utils = Utils;
    					hb.escapeExpression = Utils.escapeExpression;
    
    					hb.VM = runtime;
    					hb.template = function(spec) {
    						return runtime.template(spec, hb);
    					};
    
    					return hb;
    				}
    
    				var inst = create();
    				inst.create = create;
    
    				_handlebarsNoConflict2['default'](inst);
    
    				inst['default'] = inst;
    
    				exports['default'] = inst;
    				module.exports = exports['default'];
    
    				
    			},
    			
    			
    			function(module, exports) {
    
    				
    
    				exports["default"] = function(obj) {
    					if (obj && obj.__esModule) {
    						return obj;
    					} else {
    						var newObj = {};
    
    						if (obj != null) {
    							for (var key in obj) {
    								if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
    							}
    						}
    
    						newObj["default"] = obj;
    						return newObj;
    					}
    				};
    
    				exports.__esModule = true;
    
    				
    			},
    			
    			
    			function(module, exports, __webpack_require__) {
    
    				
    
    				var _interopRequireDefault = __webpack_require__(1)['default'];
    
    				exports.__esModule = true;
    				exports.HandlebarsEnvironment = HandlebarsEnvironment;
    
    				var _utils = __webpack_require__(5);
    
    				var _exception = __webpack_require__(6);
    
    				var _exception2 = _interopRequireDefault(_exception);
    
    				var _helpers = __webpack_require__(7);
    
    				var _decorators = __webpack_require__(15);
    
    				var _logger = __webpack_require__(17);
    
    				var _logger2 = _interopRequireDefault(_logger);
    
    				var VERSION = '4.0.5';
    				exports.VERSION = VERSION;
    				var COMPILER_REVISION = 7;
    
    				exports.COMPILER_REVISION = COMPILER_REVISION;
    				var REVISION_CHANGES = {
    					1: '<= 1.0.rc.2', // 1.0.rc.2 is actually rev2 but doesn't report it
    					2: '== 1.0.0-rc.3',
    					3: '== 1.0.0-rc.4',
    					4: '== 1.x.x',
    					5: '== 2.0.0-alpha.x',
    					6: '>= 2.0.0-beta.1',
    					7: '>= 4.0.0'
    				};
    
    				exports.REVISION_CHANGES = REVISION_CHANGES;
    				var objectType = '[object Object]';
    
    				function HandlebarsEnvironment(helpers, partials, decorators) {
    					this.helpers = helpers || {};
    					this.partials = partials || {};
    					this.decorators = decorators || {};
    
    					_helpers.registerDefaultHelpers(this);
    					_decorators.registerDefaultDecorators(this);
    				}
    
    				HandlebarsEnvironment.prototype = {
    					constructor: HandlebarsEnvironment,
    
    					logger: _logger2['default'],
    					log: _logger2['default'].log,
    
    					registerHelper: function registerHelper(name, fn) {
    						if (_utils.toString.call(name) === objectType) {
    							if (fn) {
    								throw new _exception2['default']('Arg not supported with multiple helpers');
    							}
    							_utils.extend(this.helpers, name);
    						} else {
    							this.helpers[name] = fn;
    						}
    					},
    					unregisterHelper: function unregisterHelper(name) {
    						delete this.helpers[name];
    					},
    
    					registerPartial: function registerPartial(name, partial) {
    						if (_utils.toString.call(name) === objectType) {
    							_utils.extend(this.partials, name);
    						} else {
    							if (typeof partial === 'undefined') {
    								throw new _exception2['default']('Attempting to register a partial called "' + name + '" as undefined');
    							}
    							this.partials[name] = partial;
    						}
    					},
    					unregisterPartial: function unregisterPartial(name) {
    						delete this.partials[name];
    					},
    
    					registerDecorator: function registerDecorator(name, fn) {
    						if (_utils.toString.call(name) === objectType) {
    							if (fn) {
    								throw new _exception2['default']('Arg not supported with multiple decorators');
    							}
    							_utils.extend(this.decorators, name);
    						} else {
    							this.decorators[name] = fn;
    						}
    					},
    					unregisterDecorator: function unregisterDecorator(name) {
    						delete this.decorators[name];
    					}
    				};
    
    				var log = _logger2['default'].log;
    
    				exports.log = log;
    				exports.createFrame = _utils.createFrame;
    				exports.logger = _logger2['default'];
    
    				
    			},
    			
    			
    			function(module, exports) {
    
    				
    
    				exports.__esModule = true;
    				exports.extend = extend;
    				exports.indexOf = indexOf;
    				exports.escapeExpression = escapeExpression;
    				exports.isEmpty = isEmpty;
    				exports.createFrame = createFrame;
    				exports.blockParams = blockParams;
    				exports.appendContextPath = appendContextPath;
    				var escape = {
    					'&': '&amp;',
    					'<': '&lt;',
    					'>': '&gt;',
    					'"': '&quot;',
    					"'": '&#x27;',
    					'`': '&#x60;',
    					'=': '&#x3D;'
    				};
    
    				var badChars = /[&<>"'`=]/g,
    					possible = /[&<>"'`=]/;
    
    				function escapeChar(chr) {
    					return escape[chr];
    				}
    
    				function extend(obj  ) {
    					for (var i = 1; i < arguments.length; i++) {
    						for (var key in arguments[i]) {
    							if (Object.prototype.hasOwnProperty.call(arguments[i], key)) {
    								obj[key] = arguments[i][key];
    							}
    						}
    					}
    
    					return obj;
    				}
    
    				var toString = Object.prototype.toString;
    
    				exports.toString = toString;
    				// Sourced from lodash
    				// https://github.com/bestiejs/lodash/blob/master/LICENSE.txt
    				
    				var isFunction = function isFunction(value) {
    					return typeof value === 'function';
    				};
    				// fallback for older versions of Chrome and Safari
    				
    				if (isFunction(/x/)) {
    					exports.isFunction = isFunction = function(value) {
    						return typeof value === 'function' && toString.call(value) === '[object Function]';
    					};
    				}
    				exports.isFunction = isFunction;
    
    				
    
    				
    				var isArray = Array.isArray || function(value) {
    					return value && typeof value === 'object' ? toString.call(value) === '[object Array]' : false;
    				};
    
    				exports.isArray = isArray;
    				// Older IE versions do not directly support indexOf so we must implement our own, sadly.
    
    				function indexOf(array, value) {
    					for (var i = 0, len = array.length; i < len; i++) {
    						if (array[i] === value) {
    							return i;
    						}
    					}
    					return -1;
    				}
    
    				function escapeExpression(string) {
    					if (typeof string !== 'string') {
    						// don't escape SafeStrings, since they're already safe
    						if (string && string.toHTML) {
    							return string.toHTML();
    						} else if (string == null) {
    							return '';
    						} else if (!string) {
    							return string + '';
    						}
    
    						// Force a string conversion as this will be done by the append regardless and
    						// the regex test will do this transparently behind the scenes, causing issues if
    						// an object's to string has escaped characters in it.
    						string = '' + string;
    					}
    
    					if (!possible.test(string)) {
    						return string;
    					}
    					return string.replace(badChars, escapeChar);
    				}
    
    				function isEmpty(value) {
    					if (!value && value !== 0) {
    						return true;
    					} else if (isArray(value) && value.length === 0) {
    						return true;
    					} else {
    						return false;
    					}
    				}
    
    				function createFrame(object) {
    					var frame = extend({}, object);
    					frame._parent = object;
    					return frame;
    				}
    
    				function blockParams(params, ids) {
    					params.path = ids;
    					return params;
    				}
    
    				function appendContextPath(contextPath, id) {
    					return (contextPath ? contextPath + '.' : '') + id;
    				}
    
    				
    			},
    			
    			
    			function(module, exports) {
    
    				
    
    				exports.__esModule = true;
    
    				var errorProps = ['description', 'fileName', 'lineNumber', 'message', 'name', 'number', 'stack'];
    
    				function Exception(message, node) {
    					var loc = node && node.loc,
    						line = undefined,
    						column = undefined;
    					if (loc) {
    						line = loc.start.line;
    						column = loc.start.column;
    
    						message += ' - ' + line + ':' + column;
    					}
    
    					var tmp = Error.prototype.constructor.call(this, message);
    
    					// Unfortunately errors are not enumerable in Chrome (at least), so `for prop in tmp` doesn't work.
    					for (var idx = 0; idx < errorProps.length; idx++) {
    						this[errorProps[idx]] = tmp[errorProps[idx]];
    					}
    
    					
    					if (Error.captureStackTrace) {
    						Error.captureStackTrace(this, Exception);
    					}
    
    					if (loc) {
    						this.lineNumber = line;
    						this.column = column;
    					}
    				}
    
    				Exception.prototype = new Error();
    
    				exports['default'] = Exception;
    				module.exports = exports['default'];
    
    				
    			},
    			
    			
    			function(module, exports, __webpack_require__) {
    
    				
    
    				var _interopRequireDefault = __webpack_require__(1)['default'];
    
    				exports.__esModule = true;
    				exports.registerDefaultHelpers = registerDefaultHelpers;
    
    				var _helpersBlockHelperMissing = __webpack_require__(8);
    
    				var _helpersBlockHelperMissing2 = _interopRequireDefault(_helpersBlockHelperMissing);
    
    				var _helpersEach = __webpack_require__(9);
    
    				var _helpersEach2 = _interopRequireDefault(_helpersEach);
    
    				var _helpersHelperMissing = __webpack_require__(10);
    
    				var _helpersHelperMissing2 = _interopRequireDefault(_helpersHelperMissing);
    
    				var _helpersIf = __webpack_require__(11);
    
    				var _helpersIf2 = _interopRequireDefault(_helpersIf);
    
    				var _helpersLog = __webpack_require__(12);
    
    				var _helpersLog2 = _interopRequireDefault(_helpersLog);
    
    				var _helpersLookup = __webpack_require__(13);
    
    				var _helpersLookup2 = _interopRequireDefault(_helpersLookup);
    
    				var _helpersWith = __webpack_require__(14);
    
    				var _helpersWith2 = _interopRequireDefault(_helpersWith);
    
    				function registerDefaultHelpers(instance) {
    					_helpersBlockHelperMissing2['default'](instance);
    					_helpersEach2['default'](instance);
    					_helpersHelperMissing2['default'](instance);
    					_helpersIf2['default'](instance);
    					_helpersLog2['default'](instance);
    					_helpersLookup2['default'](instance);
    					_helpersWith2['default'](instance);
    				}
    
    				
    			},
    			
    			
    			function(module, exports, __webpack_require__) {
    
    				
    
    				exports.__esModule = true;
    
    				var _utils = __webpack_require__(5);
    
    				exports['default'] = function(instance) {
    					instance.registerHelper('blockHelperMissing', function(context, options) {
    						var inverse = options.inverse,
    							fn = options.fn;
    
    						if (context === true) {
    							return fn(this);
    						} else if (context === false || context == null) {
    							return inverse(this);
    						} else if (_utils.isArray(context)) {
    							if (context.length > 0) {
    								if (options.ids) {
    									options.ids = [options.name];
    								}
    
    								return instance.helpers.each(context, options);
    							} else {
    								return inverse(this);
    							}
    						} else {
    							if (options.data && options.ids) {
    								var data = _utils.createFrame(options.data);
    								data.contextPath = _utils.appendContextPath(options.data.contextPath, options.name);
    								options = {
    									data: data
    								};
    							}
    
    							return fn(context, options);
    						}
    					});
    				};
    
    				module.exports = exports['default'];
    
    				
    			},
    			
    			
    			function(module, exports, __webpack_require__) {
    
    				
    
    				var _interopRequireDefault = __webpack_require__(1)['default'];
    
    				exports.__esModule = true;
    
    				var _utils = __webpack_require__(5);
    
    				var _exception = __webpack_require__(6);
    
    				var _exception2 = _interopRequireDefault(_exception);
    
    				exports['default'] = function(instance) {
    					instance.registerHelper('each', function(context, options) {
    						if (!options) {
    							throw new _exception2['default']('Must pass iterator to #each');
    						}
    
    						var fn = options.fn,
    							inverse = options.inverse,
    							i = 0,
    							ret = '',
    							data = undefined,
    							contextPath = undefined;
    
    						if (options.data && options.ids) {
    							contextPath = _utils.appendContextPath(options.data.contextPath, options.ids[0]) + '.';
    						}
    
    						if (_utils.isFunction(context)) {
    							context = context.call(this);
    						}
    
    						if (options.data) {
    							data = _utils.createFrame(options.data);
    						}
    
    						function execIteration(field, index, last) {
    							if (data) {
    								data.key = field;
    								data.index = index;
    								data.first = index === 0;
    								data.last = !!last;
    
    								if (contextPath) {
    									data.contextPath = contextPath + field;
    								}
    							}
    
    							ret = ret + fn(context[field], {
    								data: data,
    								blockParams: _utils.blockParams([context[field], field], [contextPath + field, null])
    							});
    						}
    
    						if (context && typeof context === 'object') {
    							if (_utils.isArray(context)) {
    								for (var j = context.length; i < j; i++) {
    									if (i in context) {
    										execIteration(i, i, i === context.length - 1);
    									}
    								}
    							} else {
    								var priorKey = undefined;
    
    								for (var key in context) {
    									if (context.hasOwnProperty(key)) {
    										// We're running the iterations one step out of sync so we can detect
    										// the last iteration without have to scan the object twice and create
    										// an itermediate keys array.
    										if (priorKey !== undefined) {
    											execIteration(priorKey, i - 1);
    										}
    										priorKey = key;
    										i++;
    									}
    								}
    								if (priorKey !== undefined) {
    									execIteration(priorKey, i - 1, true);
    								}
    							}
    						}
    
    						if (i === 0) {
    							ret = inverse(this);
    						}
    
    						return ret;
    					});
    				};
    
    				module.exports = exports['default'];
    
    				
    			},
    			
    			
    			function(module, exports, __webpack_require__) {
    
    				
    
    				var _interopRequireDefault = __webpack_require__(1)['default'];
    
    				exports.__esModule = true;
    
    				var _exception = __webpack_require__(6);
    
    				var _exception2 = _interopRequireDefault(_exception);
    
    				exports['default'] = function(instance) {
    					instance.registerHelper('helperMissing', function()  {
    						if (arguments.length === 1) {
    							// A missing field in a {{foo}} construct.
    							return undefined;
    						} else {
    							// Someone is actually trying to call something, blow up.
    							throw new _exception2['default']('Missing helper: "' + arguments[arguments.length - 1].name + '"');
    						}
    					});
    				};
    
    				module.exports = exports['default'];
    
    				
    			},
    			
    			
    			function(module, exports, __webpack_require__) {
    
    				
    
    				exports.__esModule = true;
    
    				var _utils = __webpack_require__(5);
    
    				exports['default'] = function(instance) {
    					instance.registerHelper('if', function(conditional, options) {
    						if (_utils.isFunction(conditional)) {
    							conditional = conditional.call(this);
    						}
    
    						// Default behavior is to render the positive path if the value is truthy and not empty.
    						// The `includeZero` option may be set to treat the condtional as purely not empty based on the
    						// behavior of isEmpty. Effectively this determines if 0 is handled by the positive path or negative.
    						if (!options.hash.includeZero && !conditional || _utils.isEmpty(conditional)) {
    							return options.inverse(this);
    						} else {
    							return options.fn(this);
    						}
    					});
    
    					instance.registerHelper('unless', function(conditional, options) {
    						return instance.helpers['if'].call(this, conditional, {
    							fn: options.inverse,
    							inverse: options.fn,
    							hash: options.hash
    						});
    					});
    				};
    
    				module.exports = exports['default'];
    
    				
    			},
    			
    			
    			function(module, exports) {
    
    				
    
    				exports.__esModule = true;
    
    				exports['default'] = function(instance) {
    					instance.registerHelper('log', function()  {
    						var args = [undefined],
    							options = arguments[arguments.length - 1];
    						for (var i = 0; i < arguments.length - 1; i++) {
    							args.push(arguments[i]);
    						}
    
    						var level = 1;
    						if (options.hash.level != null) {
    							level = options.hash.level;
    						} else if (options.data && options.data.level != null) {
    							level = options.data.level;
    						}
    						args[0] = level;
    
    						instance.log.apply(instance, args);
    					});
    				};
    
    				module.exports = exports['default'];
    
    				
    			},
    			
    			
    			function(module, exports) {
    
    				
    
    				exports.__esModule = true;
    
    				exports['default'] = function(instance) {
    					instance.registerHelper('lookup', function(obj, field) {
    						return obj && obj[field];
    					});
    				};
    
    				module.exports = exports['default'];
    
    				
    			},
    			
    			
    			function(module, exports, __webpack_require__) {
    
    				
    
    				exports.__esModule = true;
    
    				var _utils = __webpack_require__(5);
    
    				exports['default'] = function(instance) {
    					instance.registerHelper('with', function(context, options) {
    						if (_utils.isFunction(context)) {
    							context = context.call(this);
    						}
    
    						var fn = options.fn;
    
    						if (!_utils.isEmpty(context)) {
    							var data = options.data;
    							if (options.data && options.ids) {
    								data = _utils.createFrame(options.data);
    								data.contextPath = _utils.appendContextPath(options.data.contextPath, options.ids[0]);
    							}
    
    							return fn(context, {
    								data: data,
    								blockParams: _utils.blockParams([context], [data && data.contextPath])
    							});
    						} else {
    							return options.inverse(this);
    						}
    					});
    				};
    
    				module.exports = exports['default'];
    
    				
    			},
    			
    			
    			function(module, exports, __webpack_require__) {
    
    				
    
    				var _interopRequireDefault = __webpack_require__(1)['default'];
    
    				exports.__esModule = true;
    				exports.registerDefaultDecorators = registerDefaultDecorators;
    
    				var _decoratorsInline = __webpack_require__(16);
    
    				var _decoratorsInline2 = _interopRequireDefault(_decoratorsInline);
    
    				function registerDefaultDecorators(instance) {
    					_decoratorsInline2['default'](instance);
    				}
    
    				
    			},
    			
    			
    			function(module, exports, __webpack_require__) {
    
    				
    
    				exports.__esModule = true;
    
    				var _utils = __webpack_require__(5);
    
    				exports['default'] = function(instance) {
    					instance.registerDecorator('inline', function(fn, props, container, options) {
    						var ret = fn;
    						if (!props.partials) {
    							props.partials = {};
    							ret = function(context, options) {
    								// Create a new partials stack frame prior to exec.
    								var original = container.partials;
    								container.partials = _utils.extend({}, original, props.partials);
    								var ret = fn(context, options);
    								container.partials = original;
    								return ret;
    							};
    						}
    
    						props.partials[options.args[0]] = options.fn;
    
    						return ret;
    					});
    				};
    
    				module.exports = exports['default'];
    
    				
    			},
    			
    			
    			function(module, exports, __webpack_require__) {
    
    				
    
    				exports.__esModule = true;
    
    				var _utils = __webpack_require__(5);
    
    				var logger = {
    					methodMap: ['debug', 'info', 'warn', 'error'],
    					level: 'info',
    
    					// Maps a given level value to the `methodMap` indexes above.
    					lookupLevel: function lookupLevel(level) {
    						if (typeof level === 'string') {
    							var levelMap = _utils.indexOf(logger.methodMap, level.toLowerCase());
    							if (levelMap >= 0) {
    								level = levelMap;
    							} else {
    								level = parseInt(level, 10);
    							}
    						}
    
    						return level;
    					},
    
    					// Can be overridden in the host environment
    					log: function log(level) {
    						level = logger.lookupLevel(level);
    
    						if (typeof console !== 'undefined' && logger.lookupLevel(logger.level) <= level) {
    							var method = logger.methodMap[level];
    							if (!console[method]) {
    								// eslint-disable-line no-console
    								method = 'log';
    							}
    
    							for (var _len = arguments.length, message = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    								message[_key - 1] = arguments[_key];
    							}
    
    							console[method].apply(console, message); // eslint-disable-line no-console
    						}
    					}
    				};
    
    				exports['default'] = logger;
    				module.exports = exports['default'];
    
    				
    			},
    			
    			
    			function(module, exports) {
    
    				// Build out our basic SafeString type
    				
    
    				exports.__esModule = true;
    
    				function SafeString(string) {
    					this.string = string;
    				}
    
    				SafeString.prototype.toString = SafeString.prototype.toHTML = function() {
    					return '' + this.string;
    				};
    
    				exports['default'] = SafeString;
    				module.exports = exports['default'];
    
    				
    			},
    			
    			
    			function(module, exports, __webpack_require__) {
    
    				
    
    				var _interopRequireWildcard = __webpack_require__(3)['default'];
    
    				var _interopRequireDefault = __webpack_require__(1)['default'];
    
    				exports.__esModule = true;
    				exports.checkRevision = checkRevision;
    				exports.template = template;
    				exports.wrapProgram = wrapProgram;
    				exports.resolvePartial = resolvePartial;
    				exports.invokePartial = invokePartial;
    				exports.noop = noop;
    
    				var _utils = __webpack_require__(5);
    
    				var Utils = _interopRequireWildcard(_utils);
    
    				var _exception = __webpack_require__(6);
    
    				var _exception2 = _interopRequireDefault(_exception);
    
    				var _base = __webpack_require__(4);
    
    				function checkRevision(compilerInfo) {
    					var compilerRevision = compilerInfo && compilerInfo[0] || 1,
    						currentRevision = _base.COMPILER_REVISION;
    
    					if (compilerRevision !== currentRevision) {
    						if (compilerRevision < currentRevision) {
    							var runtimeVersions = _base.REVISION_CHANGES[currentRevision],
    								compilerVersions = _base.REVISION_CHANGES[compilerRevision];
    							throw new _exception2['default']('Template was precompiled with an older version of Handlebars than the current runtime. ' + 'Please update your precompiler to a newer version (' + runtimeVersions + ') or downgrade your runtime to an older version (' + compilerVersions + ').');
    						} else {
    							// Use the embedded version info since the runtime doesn't know about this revision yet
    							throw new _exception2['default']('Template was precompiled with a newer version of Handlebars than the current runtime. ' + 'Please update your runtime to a newer version (' + compilerInfo[1] + ').');
    						}
    					}
    				}
    
    				function template(templateSpec, env) {
    					
    					if (!env) {
    						throw new _exception2['default']('No environment passed to template');
    					}
    					if (!templateSpec || !templateSpec.main) {
    						throw new _exception2['default']('Unknown template object: ' + typeof templateSpec);
    					}
    
    					templateSpec.main.decorator = templateSpec.main_d;
    
    					// Note: Using env.VM references rather than local var references throughout this section to allow
    					// for external users to override these as psuedo-supported APIs.
    					env.VM.checkRevision(templateSpec.compiler);
    
    					function invokePartialWrapper(partial, context, options) {
    						if (options.hash) {
    							context = Utils.extend({}, context, options.hash);
    							if (options.ids) {
    								options.ids[0] = true;
    							}
    						}
    
    						partial = env.VM.resolvePartial.call(this, partial, context, options);
    						var result = env.VM.invokePartial.call(this, partial, context, options);
    
    						if (result == null && env.compile) {
    							options.partials[options.name] = env.compile(partial, templateSpec.compilerOptions, env);
    							result = options.partials[options.name](context, options);
    						}
    						if (result != null) {
    							if (options.indent) {
    								var lines = result.split('\n');
    								for (var i = 0, l = lines.length; i < l; i++) {
    									if (!lines[i] && i + 1 === l) {
    										break;
    									}
    
    									lines[i] = options.indent + lines[i];
    								}
    								result = lines.join('\n');
    							}
    							return result;
    						} else {
    							throw new _exception2['default']('The partial ' + options.name + ' could not be compiled when running in runtime-only mode');
    						}
    					}
    
    					// Just add water
    					var container = {
    						strict: function strict(obj, name) {
    							if (!(name in obj)) {
    								throw new _exception2['default']('"' + name + '" not defined in ' + obj);
    							}
    							return obj[name];
    						},
    						lookup: function lookup(depths, name) {
    							var len = depths.length;
    							for (var i = 0; i < len; i++) {
    								if (depths[i] && depths[i][name] != null) {
    									return depths[i][name];
    								}
    							}
    						},
    						lambda: function lambda(current, context) {
    							return typeof current === 'function' ? current.call(context) : current;
    						},
    
    						escapeExpression: Utils.escapeExpression,
    						invokePartial: invokePartialWrapper,
    
    						fn: function fn(i) {
    							var ret = templateSpec[i];
    							ret.decorator = templateSpec[i + '_d'];
    							return ret;
    						},
    
    						programs: [],
    						program: function program(i, data, declaredBlockParams, blockParams, depths) {
    							var programWrapper = this.programs[i],
    								fn = this.fn(i);
    							if (data || depths || blockParams || declaredBlockParams) {
    								programWrapper = wrapProgram(this, i, fn, data, declaredBlockParams, blockParams, depths);
    							} else if (!programWrapper) {
    								programWrapper = this.programs[i] = wrapProgram(this, i, fn);
    							}
    							return programWrapper;
    						},
    
    						data: function data(value, depth) {
    							while (value && depth--) {
    								value = value._parent;
    							}
    							return value;
    						},
    						merge: function merge(param, common) {
    							var obj = param || common;
    
    							if (param && common && param !== common) {
    								obj = Utils.extend({}, common, param);
    							}
    
    							return obj;
    						},
    
    						noop: env.VM.noop,
    						compilerInfo: templateSpec.compiler
    					};
    
    					function ret(context) {
    						var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
    
    						var data = options.data;
    
    						ret._setup(options);
    						if (!options.partial && templateSpec.useData) {
    							data = initData(context, data);
    						}
    						var depths = undefined,
    							blockParams = templateSpec.useBlockParams ? [] : undefined;
    						if (templateSpec.useDepths) {
    							if (options.depths) {
    								depths = context !== options.depths[0] ? [context].concat(options.depths) : options.depths;
    							} else {
    								depths = [context];
    							}
    						}
    
    						function main(context  ) {
    							return '' + templateSpec.main(container, context, container.helpers, container.partials, data, blockParams, depths);
    						}
    						main = executeDecorators(templateSpec.main, main, container, options.depths || [], data, blockParams);
    						return main(context, options);
    					}
    					ret.isTop = true;
    
    					ret._setup = function(options) {
    						if (!options.partial) {
    							container.helpers = container.merge(options.helpers, env.helpers);
    
    							if (templateSpec.usePartial) {
    								container.partials = container.merge(options.partials, env.partials);
    							}
    							if (templateSpec.usePartial || templateSpec.useDecorators) {
    								container.decorators = container.merge(options.decorators, env.decorators);
    							}
    						} else {
    							container.helpers = options.helpers;
    							container.partials = options.partials;
    							container.decorators = options.decorators;
    						}
    					};
    
    					ret._child = function(i, data, blockParams, depths) {
    						if (templateSpec.useBlockParams && !blockParams) {
    							throw new _exception2['default']('must pass block params');
    						}
    						if (templateSpec.useDepths && !depths) {
    							throw new _exception2['default']('must pass parent depths');
    						}
    
    						return wrapProgram(container, i, templateSpec[i], data, 0, blockParams, depths);
    					};
    					return ret;
    				}
    
    				function wrapProgram(container, i, fn, data, declaredBlockParams, blockParams, depths) {
    					function prog(context) {
    						var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
    
    						var currentDepths = depths;
    						if (depths && context !== depths[0]) {
    							currentDepths = [context].concat(depths);
    						}
    
    						return fn(container, context, container.helpers, container.partials, options.data || data, blockParams && [options.blockParams].concat(blockParams), currentDepths);
    					}
    
    					prog = executeDecorators(fn, prog, container, depths, data, blockParams);
    
    					prog.program = i;
    					prog.depth = depths ? depths.length : 0;
    					prog.blockParams = declaredBlockParams || 0;
    					return prog;
    				}
    
    				function resolvePartial(partial, context, options) {
    					if (!partial) {
    						if (options.name === '@partial-block') {
    							partial = options.data['partial-block'];
    						} else {
    							partial = options.partials[options.name];
    						}
    					} else if (!partial.call && !options.name) {
    						// This is a dynamic partial that returned a string
    						options.name = partial;
    						partial = options.partials[partial];
    					}
    					return partial;
    				}
    
    				function invokePartial(partial, context, options) {
    					options.partial = true;
    					if (options.ids) {
    						options.data.contextPath = options.ids[0] || options.data.contextPath;
    					}
    
    					var partialBlock = undefined;
    					if (options.fn && options.fn !== noop) {
    						options.data = _base.createFrame(options.data);
    						partialBlock = options.data['partial-block'] = options.fn;
    
    						if (partialBlock.partials) {
    							options.partials = Utils.extend({}, options.partials, partialBlock.partials);
    						}
    					}
    
    					if (partial === undefined && partialBlock) {
    						partial = partialBlock;
    					}
    
    					if (partial === undefined) {
    						throw new _exception2['default']('The partial ' + options.name + ' could not be found');
    					} else if (partial instanceof Function) {
    						return partial(context, options);
    					}
    				}
    
    				function noop() {
    					return '';
    				}
    
    				function initData(context, data) {
    					if (!data || !('root' in data)) {
    						data = data ? _base.createFrame(data) : {};
    						data.root = context;
    					}
    					return data;
    				}
    
    				function executeDecorators(fn, prog, container, depths, data, blockParams) {
    					if (fn.decorator) {
    						var props = {};
    						prog = fn.decorator(prog, props, container, depths && depths[0], data, blockParams, depths);
    						Utils.extend(prog, props);
    					}
    					return prog;
    				}
    
    				
    			},
    			
    			
    			function(module, exports) {
    
    				
    				(function(global) { 
    					
    
    					exports.__esModule = true;
    
    					exports['default'] = function(Handlebars) {
    						
    						var root = typeof global !== 'undefined' ? global : window,
    							$Handlebars = root.Handlebars;
    						
    						Handlebars.noConflict = function() {
    							if (root.Handlebars === Handlebars) {
    								root.Handlebars = $Handlebars;
    							}
    							return Handlebars;
    						};
    					};
    
    					module.exports = exports['default'];
    					
    				}.call(exports, (function() {
    					return this;
    				}())))
    
    				
    			},
    			
    			
    			function(module, exports) {
    
    				
    
    				exports.__esModule = true;
    				var AST = {
    					// Public API used to evaluate derived attributes regarding AST nodes
    					helpers: {
    						// a mustache is definitely a helper if:
    						// * it is an eligible helper, and
    						// * it has at least one parameter or hash segment
    						helperExpression: function helperExpression(node) {
    							return node.type === 'SubExpression' || (node.type === 'MustacheStatement' || node.type === 'BlockStatement') && !!(node.params && node.params.length || node.hash);
    						},
    
    						scopedId: function scopedId(path) {
    							return (/^\.|this\b/.test(path.original));
    						},
    
    						// an ID is simple if it only has one part, and that part is not
    						// `..` or `this`.
    						simpleId: function simpleId(path) {
    							return path.parts.length === 1 && !AST.helpers.scopedId(path) && !path.depth;
    						}
    					}
    				};
    
    				// Must be exported as an object rather than the root of the module as the jison lexer
    				// must modify the object to operate properly.
    				exports['default'] = AST;
    				module.exports = exports['default'];
    
    				
    			},
    			
    			
    			function(module, exports, __webpack_require__) {
    
    				
    
    				var _interopRequireDefault = __webpack_require__(1)['default'];
    
    				var _interopRequireWildcard = __webpack_require__(3)['default'];
    
    				exports.__esModule = true;
    				exports.parse = parse;
    
    				var _parser = __webpack_require__(23);
    
    				var _parser2 = _interopRequireDefault(_parser);
    
    				var _whitespaceControl = __webpack_require__(24);
    
    				var _whitespaceControl2 = _interopRequireDefault(_whitespaceControl);
    
    				var _helpers = __webpack_require__(26);
    
    				var Helpers = _interopRequireWildcard(_helpers);
    
    				var _utils = __webpack_require__(5);
    
    				exports.parser = _parser2['default'];
    
    				var yy = {};
    				_utils.extend(yy, Helpers);
    
    				function parse(input, options) {
    					// Just return if an already-compiled AST was passed in.
    					if (input.type === 'Program') {
    						return input;
    					}
    
    					_parser2['default'].yy = yy;
    
    					// Altering the shared object here, but this is ok as parser is a sync operation
    					yy.locInfo = function(locInfo) {
    						return new yy.SourceLocation(options && options.srcName, locInfo);
    					};
    
    					var strip = new _whitespaceControl2['default'](options);
    					return strip.accept(_parser2['default'].parse(input));
    				}
    
    				
    			},
    			
    			
    			function(module, exports) {
    
    				
    				
    				
    
    				var handlebars = (function() {
    					var parser = {
    						trace: function trace() {},
    						yy: {},
    						symbols_: {
    							"error": 2,
    							"root": 3,
    							"program": 4,
    							"EOF": 5,
    							"program_repetition0": 6,
    							"statement": 7,
    							"mustache": 8,
    							"block": 9,
    							"rawBlock": 10,
    							"partial": 11,
    							"partialBlock": 12,
    							"content": 13,
    							"COMMENT": 14,
    							"CONTENT": 15,
    							"openRawBlock": 16,
    							"rawBlock_repetition_plus0": 17,
    							"END_RAW_BLOCK": 18,
    							"OPEN_RAW_BLOCK": 19,
    							"helperName": 20,
    							"openRawBlock_repetition0": 21,
    							"openRawBlock_option0": 22,
    							"CLOSE_RAW_BLOCK": 23,
    							"openBlock": 24,
    							"block_option0": 25,
    							"closeBlock": 26,
    							"openInverse": 27,
    							"block_option1": 28,
    							"OPEN_BLOCK": 29,
    							"openBlock_repetition0": 30,
    							"openBlock_option0": 31,
    							"openBlock_option1": 32,
    							"CLOSE": 33,
    							"OPEN_INVERSE": 34,
    							"openInverse_repetition0": 35,
    							"openInverse_option0": 36,
    							"openInverse_option1": 37,
    							"openInverseChain": 38,
    							"OPEN_INVERSE_CHAIN": 39,
    							"openInverseChain_repetition0": 40,
    							"openInverseChain_option0": 41,
    							"openInverseChain_option1": 42,
    							"inverseAndProgram": 43,
    							"INVERSE": 44,
    							"inverseChain": 45,
    							"inverseChain_option0": 46,
    							"OPEN_ENDBLOCK": 47,
    							"OPEN": 48,
    							"mustache_repetition0": 49,
    							"mustache_option0": 50,
    							"OPEN_UNESCAPED": 51,
    							"mustache_repetition1": 52,
    							"mustache_option1": 53,
    							"CLOSE_UNESCAPED": 54,
    							"OPEN_PARTIAL": 55,
    							"partialName": 56,
    							"partial_repetition0": 57,
    							"partial_option0": 58,
    							"openPartialBlock": 59,
    							"OPEN_PARTIAL_BLOCK": 60,
    							"openPartialBlock_repetition0": 61,
    							"openPartialBlock_option0": 62,
    							"param": 63,
    							"sexpr": 64,
    							"OPEN_SEXPR": 65,
    							"sexpr_repetition0": 66,
    							"sexpr_option0": 67,
    							"CLOSE_SEXPR": 68,
    							"hash": 69,
    							"hash_repetition_plus0": 70,
    							"hashSegment": 71,
    							"ID": 72,
    							"EQUALS": 73,
    							"blockParams": 74,
    							"OPEN_BLOCK_PARAMS": 75,
    							"blockParams_repetition_plus0": 76,
    							"CLOSE_BLOCK_PARAMS": 77,
    							"path": 78,
    							"dataName": 79,
    							"STRING": 80,
    							"NUMBER": 81,
    							"BOOLEAN": 82,
    							"UNDEFINED": 83,
    							"NULL": 84,
    							"DATA": 85,
    							"pathSegments": 86,
    							"SEP": 87,
    							"$accept": 0,
    							"$end": 1
    						},
    						terminals_: {
    							2: "error",
    							5: "EOF",
    							14: "COMMENT",
    							15: "CONTENT",
    							18: "END_RAW_BLOCK",
    							19: "OPEN_RAW_BLOCK",
    							23: "CLOSE_RAW_BLOCK",
    							29: "OPEN_BLOCK",
    							33: "CLOSE",
    							34: "OPEN_INVERSE",
    							39: "OPEN_INVERSE_CHAIN",
    							44: "INVERSE",
    							47: "OPEN_ENDBLOCK",
    							48: "OPEN",
    							51: "OPEN_UNESCAPED",
    							54: "CLOSE_UNESCAPED",
    							55: "OPEN_PARTIAL",
    							60: "OPEN_PARTIAL_BLOCK",
    							65: "OPEN_SEXPR",
    							68: "CLOSE_SEXPR",
    							72: "ID",
    							73: "EQUALS",
    							75: "OPEN_BLOCK_PARAMS",
    							77: "CLOSE_BLOCK_PARAMS",
    							80: "STRING",
    							81: "NUMBER",
    							82: "BOOLEAN",
    							83: "UNDEFINED",
    							84: "NULL",
    							85: "DATA",
    							87: "SEP"
    						},
    						productions_: [0, [3, 2],
    							[4, 1],
    							[7, 1],
    							[7, 1],
    							[7, 1],
    							[7, 1],
    							[7, 1],
    							[7, 1],
    							[7, 1],
    							[13, 1],
    							[10, 3],
    							[16, 5],
    							[9, 4],
    							[9, 4],
    							[24, 6],
    							[27, 6],
    							[38, 6],
    							[43, 2],
    							[45, 3],
    							[45, 1],
    							[26, 3],
    							[8, 5],
    							[8, 5],
    							[11, 5],
    							[12, 3],
    							[59, 5],
    							[63, 1],
    							[63, 1],
    							[64, 5],
    							[69, 1],
    							[71, 3],
    							[74, 3],
    							[20, 1],
    							[20, 1],
    							[20, 1],
    							[20, 1],
    							[20, 1],
    							[20, 1],
    							[20, 1],
    							[56, 1],
    							[56, 1],
    							[79, 2],
    							[78, 1],
    							[86, 3],
    							[86, 1],
    							[6, 0],
    							[6, 2],
    							[17, 1],
    							[17, 2],
    							[21, 0],
    							[21, 2],
    							[22, 0],
    							[22, 1],
    							[25, 0],
    							[25, 1],
    							[28, 0],
    							[28, 1],
    							[30, 0],
    							[30, 2],
    							[31, 0],
    							[31, 1],
    							[32, 0],
    							[32, 1],
    							[35, 0],
    							[35, 2],
    							[36, 0],
    							[36, 1],
    							[37, 0],
    							[37, 1],
    							[40, 0],
    							[40, 2],
    							[41, 0],
    							[41, 1],
    							[42, 0],
    							[42, 1],
    							[46, 0],
    							[46, 1],
    							[49, 0],
    							[49, 2],
    							[50, 0],
    							[50, 1],
    							[52, 0],
    							[52, 2],
    							[53, 0],
    							[53, 1],
    							[57, 0],
    							[57, 2],
    							[58, 0],
    							[58, 1],
    							[61, 0],
    							[61, 2],
    							[62, 0],
    							[62, 1],
    							[66, 0],
    							[66, 2],
    							[67, 0],
    							[67, 1],
    							[70, 1],
    							[70, 2],
    							[76, 1],
    							[76, 2]
    						],
    						performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$
    							
    						) {
    
    							var $0 = $$.length - 1;
    							switch (yystate) {
    								case 1:
    									return $$[$0 - 1];
    									break;
    								case 2:
    									this.$ = yy.prepareProgram($$[$0]);
    									break;
    								case 3:
    									this.$ = $$[$0];
    									break;
    								case 4:
    									this.$ = $$[$0];
    									break;
    								case 5:
    									this.$ = $$[$0];
    									break;
    								case 6:
    									this.$ = $$[$0];
    									break;
    								case 7:
    									this.$ = $$[$0];
    									break;
    								case 8:
    									this.$ = $$[$0];
    									break;
    								case 9:
    									this.$ = {
    										type: 'CommentStatement',
    										value: yy.stripComment($$[$0]),
    										strip: yy.stripFlags($$[$0], $$[$0]),
    										loc: yy.locInfo(this._$)
    									};
    
    									break;
    								case 10:
    									this.$ = {
    										type: 'ContentStatement',
    										original: $$[$0],
    										value: $$[$0],
    										loc: yy.locInfo(this._$)
    									};
    
    									break;
    								case 11:
    									this.$ = yy.prepareRawBlock($$[$0 - 2], $$[$0 - 1], $$[$0], this._$);
    									break;
    								case 12:
    									this.$ = {
    										path: $$[$0 - 3],
    										params: $$[$0 - 2],
    										hash: $$[$0 - 1]
    									};
    									break;
    								case 13:
    									this.$ = yy.prepareBlock($$[$0 - 3], $$[$0 - 2], $$[$0 - 1], $$[$0], false, this._$);
    									break;
    								case 14:
    									this.$ = yy.prepareBlock($$[$0 - 3], $$[$0 - 2], $$[$0 - 1], $$[$0], true, this._$);
    									break;
    								case 15:
    									this.$ = {
    										open: $$[$0 - 5],
    										path: $$[$0 - 4],
    										params: $$[$0 - 3],
    										hash: $$[$0 - 2],
    										blockParams: $$[$0 - 1],
    										strip: yy.stripFlags($$[$0 - 5], $$[$0])
    									};
    									break;
    								case 16:
    									this.$ = {
    										path: $$[$0 - 4],
    										params: $$[$0 - 3],
    										hash: $$[$0 - 2],
    										blockParams: $$[$0 - 1],
    										strip: yy.stripFlags($$[$0 - 5], $$[$0])
    									};
    									break;
    								case 17:
    									this.$ = {
    										path: $$[$0 - 4],
    										params: $$[$0 - 3],
    										hash: $$[$0 - 2],
    										blockParams: $$[$0 - 1],
    										strip: yy.stripFlags($$[$0 - 5], $$[$0])
    									};
    									break;
    								case 18:
    									this.$ = {
    										strip: yy.stripFlags($$[$0 - 1], $$[$0 - 1]),
    										program: $$[$0]
    									};
    									break;
    								case 19:
    									var inverse = yy.prepareBlock($$[$0 - 2], $$[$0 - 1], $$[$0], $$[$0], false, this._$),
    										program = yy.prepareProgram([inverse], $$[$0 - 1].loc);
    									program.chained = true;
    
    									this.$ = {
    										strip: $$[$0 - 2].strip,
    										program: program,
    										chain: true
    									};
    
    									break;
    								case 20:
    									this.$ = $$[$0];
    									break;
    								case 21:
    									this.$ = {
    										path: $$[$0 - 1],
    										strip: yy.stripFlags($$[$0 - 2], $$[$0])
    									};
    									break;
    								case 22:
    									this.$ = yy.prepareMustache($$[$0 - 3], $$[$0 - 2], $$[$0 - 1], $$[$0 - 4], yy.stripFlags($$[$0 - 4], $$[$0]), this._$);
    									break;
    								case 23:
    									this.$ = yy.prepareMustache($$[$0 - 3], $$[$0 - 2], $$[$0 - 1], $$[$0 - 4], yy.stripFlags($$[$0 - 4], $$[$0]), this._$);
    									break;
    								case 24:
    									this.$ = {
    										type: 'PartialStatement',
    										name: $$[$0 - 3],
    										params: $$[$0 - 2],
    										hash: $$[$0 - 1],
    										indent: '',
    										strip: yy.stripFlags($$[$0 - 4], $$[$0]),
    										loc: yy.locInfo(this._$)
    									};
    
    									break;
    								case 25:
    									this.$ = yy.preparePartialBlock($$[$0 - 2], $$[$0 - 1], $$[$0], this._$);
    									break;
    								case 26:
    									this.$ = {
    										path: $$[$0 - 3],
    										params: $$[$0 - 2],
    										hash: $$[$0 - 1],
    										strip: yy.stripFlags($$[$0 - 4], $$[$0])
    									};
    									break;
    								case 27:
    									this.$ = $$[$0];
    									break;
    								case 28:
    									this.$ = $$[$0];
    									break;
    								case 29:
    									this.$ = {
    										type: 'SubExpression',
    										path: $$[$0 - 3],
    										params: $$[$0 - 2],
    										hash: $$[$0 - 1],
    										loc: yy.locInfo(this._$)
    									};
    
    									break;
    								case 30:
    									this.$ = {
    										type: 'Hash',
    										pairs: $$[$0],
    										loc: yy.locInfo(this._$)
    									};
    									break;
    								case 31:
    									this.$ = {
    										type: 'HashPair',
    										key: yy.id($$[$0 - 2]),
    										value: $$[$0],
    										loc: yy.locInfo(this._$)
    									};
    									break;
    								case 32:
    									this.$ = yy.id($$[$0 - 1]);
    									break;
    								case 33:
    									this.$ = $$[$0];
    									break;
    								case 34:
    									this.$ = $$[$0];
    									break;
    								case 35:
    									this.$ = {
    										type: 'StringLiteral',
    										value: $$[$0],
    										original: $$[$0],
    										loc: yy.locInfo(this._$)
    									};
    									break;
    								case 36:
    									this.$ = {
    										type: 'NumberLiteral',
    										value: Number($$[$0]),
    										original: Number($$[$0]),
    										loc: yy.locInfo(this._$)
    									};
    									break;
    								case 37:
    									this.$ = {
    										type: 'BooleanLiteral',
    										value: $$[$0] === 'true',
    										original: $$[$0] === 'true',
    										loc: yy.locInfo(this._$)
    									};
    									break;
    								case 38:
    									this.$ = {
    										type: 'UndefinedLiteral',
    										original: undefined,
    										value: undefined,
    										loc: yy.locInfo(this._$)
    									};
    									break;
    								case 39:
    									this.$ = {
    										type: 'NullLiteral',
    										original: null,
    										value: null,
    										loc: yy.locInfo(this._$)
    									};
    									break;
    								case 40:
    									this.$ = $$[$0];
    									break;
    								case 41:
    									this.$ = $$[$0];
    									break;
    								case 42:
    									this.$ = yy.preparePath(true, $$[$0], this._$);
    									break;
    								case 43:
    									this.$ = yy.preparePath(false, $$[$0], this._$);
    									break;
    								case 44:
    									$$[$0 - 2].push({
    										part: yy.id($$[$0]),
    										original: $$[$0],
    										separator: $$[$0 - 1]
    									});
    									this.$ = $$[$0 - 2];
    									break;
    								case 45:
    									this.$ = [{
    										part: yy.id($$[$0]),
    										original: $$[$0]
    									}];
    									break;
    								case 46:
    									this.$ = [];
    									break;
    								case 47:
    									$$[$0 - 1].push($$[$0]);
    									break;
    								case 48:
    									this.$ = [$$[$0]];
    									break;
    								case 49:
    									$$[$0 - 1].push($$[$0]);
    									break;
    								case 50:
    									this.$ = [];
    									break;
    								case 51:
    									$$[$0 - 1].push($$[$0]);
    									break;
    								case 58:
    									this.$ = [];
    									break;
    								case 59:
    									$$[$0 - 1].push($$[$0]);
    									break;
    								case 64:
    									this.$ = [];
    									break;
    								case 65:
    									$$[$0 - 1].push($$[$0]);
    									break;
    								case 70:
    									this.$ = [];
    									break;
    								case 71:
    									$$[$0 - 1].push($$[$0]);
    									break;
    								case 78:
    									this.$ = [];
    									break;
    								case 79:
    									$$[$0 - 1].push($$[$0]);
    									break;
    								case 82:
    									this.$ = [];
    									break;
    								case 83:
    									$$[$0 - 1].push($$[$0]);
    									break;
    								case 86:
    									this.$ = [];
    									break;
    								case 87:
    									$$[$0 - 1].push($$[$0]);
    									break;
    								case 90:
    									this.$ = [];
    									break;
    								case 91:
    									$$[$0 - 1].push($$[$0]);
    									break;
    								case 94:
    									this.$ = [];
    									break;
    								case 95:
    									$$[$0 - 1].push($$[$0]);
    									break;
    								case 98:
    									this.$ = [$$[$0]];
    									break;
    								case 99:
    									$$[$0 - 1].push($$[$0]);
    									break;
    								case 100:
    									this.$ = [$$[$0]];
    									break;
    								case 101:
    									$$[$0 - 1].push($$[$0]);
    									break;
    							}
    						},
    						table: [{
    							3: 1,
    							4: 2,
    							5: [2, 46],
    							6: 3,
    							14: [2, 46],
    							15: [2, 46],
    							19: [2, 46],
    							29: [2, 46],
    							34: [2, 46],
    							48: [2, 46],
    							51: [2, 46],
    							55: [2, 46],
    							60: [2, 46]
    						}, {
    							1: [3]
    						}, {
    							5: [1, 4]
    						}, {
    							5: [2, 2],
    							7: 5,
    							8: 6,
    							9: 7,
    							10: 8,
    							11: 9,
    							12: 10,
    							13: 11,
    							14: [1, 12],
    							15: [1, 20],
    							16: 17,
    							19: [1, 23],
    							24: 15,
    							27: 16,
    							29: [1, 21],
    							34: [1, 22],
    							39: [2, 2],
    							44: [2, 2],
    							47: [2, 2],
    							48: [1, 13],
    							51: [1, 14],
    							55: [1, 18],
    							59: 19,
    							60: [1, 24]
    						}, {
    							1: [2, 1]
    						}, {
    							5: [2, 47],
    							14: [2, 47],
    							15: [2, 47],
    							19: [2, 47],
    							29: [2, 47],
    							34: [2, 47],
    							39: [2, 47],
    							44: [2, 47],
    							47: [2, 47],
    							48: [2, 47],
    							51: [2, 47],
    							55: [2, 47],
    							60: [2, 47]
    						}, {
    							5: [2, 3],
    							14: [2, 3],
    							15: [2, 3],
    							19: [2, 3],
    							29: [2, 3],
    							34: [2, 3],
    							39: [2, 3],
    							44: [2, 3],
    							47: [2, 3],
    							48: [2, 3],
    							51: [2, 3],
    							55: [2, 3],
    							60: [2, 3]
    						}, {
    							5: [2, 4],
    							14: [2, 4],
    							15: [2, 4],
    							19: [2, 4],
    							29: [2, 4],
    							34: [2, 4],
    							39: [2, 4],
    							44: [2, 4],
    							47: [2, 4],
    							48: [2, 4],
    							51: [2, 4],
    							55: [2, 4],
    							60: [2, 4]
    						}, {
    							5: [2, 5],
    							14: [2, 5],
    							15: [2, 5],
    							19: [2, 5],
    							29: [2, 5],
    							34: [2, 5],
    							39: [2, 5],
    							44: [2, 5],
    							47: [2, 5],
    							48: [2, 5],
    							51: [2, 5],
    							55: [2, 5],
    							60: [2, 5]
    						}, {
    							5: [2, 6],
    							14: [2, 6],
    							15: [2, 6],
    							19: [2, 6],
    							29: [2, 6],
    							34: [2, 6],
    							39: [2, 6],
    							44: [2, 6],
    							47: [2, 6],
    							48: [2, 6],
    							51: [2, 6],
    							55: [2, 6],
    							60: [2, 6]
    						}, {
    							5: [2, 7],
    							14: [2, 7],
    							15: [2, 7],
    							19: [2, 7],
    							29: [2, 7],
    							34: [2, 7],
    							39: [2, 7],
    							44: [2, 7],
    							47: [2, 7],
    							48: [2, 7],
    							51: [2, 7],
    							55: [2, 7],
    							60: [2, 7]
    						}, {
    							5: [2, 8],
    							14: [2, 8],
    							15: [2, 8],
    							19: [2, 8],
    							29: [2, 8],
    							34: [2, 8],
    							39: [2, 8],
    							44: [2, 8],
    							47: [2, 8],
    							48: [2, 8],
    							51: [2, 8],
    							55: [2, 8],
    							60: [2, 8]
    						}, {
    							5: [2, 9],
    							14: [2, 9],
    							15: [2, 9],
    							19: [2, 9],
    							29: [2, 9],
    							34: [2, 9],
    							39: [2, 9],
    							44: [2, 9],
    							47: [2, 9],
    							48: [2, 9],
    							51: [2, 9],
    							55: [2, 9],
    							60: [2, 9]
    						}, {
    							20: 25,
    							72: [1, 35],
    							78: 26,
    							79: 27,
    							80: [1, 28],
    							81: [1, 29],
    							82: [1, 30],
    							83: [1, 31],
    							84: [1, 32],
    							85: [1, 34],
    							86: 33
    						}, {
    							20: 36,
    							72: [1, 35],
    							78: 26,
    							79: 27,
    							80: [1, 28],
    							81: [1, 29],
    							82: [1, 30],
    							83: [1, 31],
    							84: [1, 32],
    							85: [1, 34],
    							86: 33
    						}, {
    							4: 37,
    							6: 3,
    							14: [2, 46],
    							15: [2, 46],
    							19: [2, 46],
    							29: [2, 46],
    							34: [2, 46],
    							39: [2, 46],
    							44: [2, 46],
    							47: [2, 46],
    							48: [2, 46],
    							51: [2, 46],
    							55: [2, 46],
    							60: [2, 46]
    						}, {
    							4: 38,
    							6: 3,
    							14: [2, 46],
    							15: [2, 46],
    							19: [2, 46],
    							29: [2, 46],
    							34: [2, 46],
    							44: [2, 46],
    							47: [2, 46],
    							48: [2, 46],
    							51: [2, 46],
    							55: [2, 46],
    							60: [2, 46]
    						}, {
    							13: 40,
    							15: [1, 20],
    							17: 39
    						}, {
    							20: 42,
    							56: 41,
    							64: 43,
    							65: [1, 44],
    							72: [1, 35],
    							78: 26,
    							79: 27,
    							80: [1, 28],
    							81: [1, 29],
    							82: [1, 30],
    							83: [1, 31],
    							84: [1, 32],
    							85: [1, 34],
    							86: 33
    						}, {
    							4: 45,
    							6: 3,
    							14: [2, 46],
    							15: [2, 46],
    							19: [2, 46],
    							29: [2, 46],
    							34: [2, 46],
    							47: [2, 46],
    							48: [2, 46],
    							51: [2, 46],
    							55: [2, 46],
    							60: [2, 46]
    						}, {
    							5: [2, 10],
    							14: [2, 10],
    							15: [2, 10],
    							18: [2, 10],
    							19: [2, 10],
    							29: [2, 10],
    							34: [2, 10],
    							39: [2, 10],
    							44: [2, 10],
    							47: [2, 10],
    							48: [2, 10],
    							51: [2, 10],
    							55: [2, 10],
    							60: [2, 10]
    						}, {
    							20: 46,
    							72: [1, 35],
    							78: 26,
    							79: 27,
    							80: [1, 28],
    							81: [1, 29],
    							82: [1, 30],
    							83: [1, 31],
    							84: [1, 32],
    							85: [1, 34],
    							86: 33
    						}, {
    							20: 47,
    							72: [1, 35],
    							78: 26,
    							79: 27,
    							80: [1, 28],
    							81: [1, 29],
    							82: [1, 30],
    							83: [1, 31],
    							84: [1, 32],
    							85: [1, 34],
    							86: 33
    						}, {
    							20: 48,
    							72: [1, 35],
    							78: 26,
    							79: 27,
    							80: [1, 28],
    							81: [1, 29],
    							82: [1, 30],
    							83: [1, 31],
    							84: [1, 32],
    							85: [1, 34],
    							86: 33
    						}, {
    							20: 42,
    							56: 49,
    							64: 43,
    							65: [1, 44],
    							72: [1, 35],
    							78: 26,
    							79: 27,
    							80: [1, 28],
    							81: [1, 29],
    							82: [1, 30],
    							83: [1, 31],
    							84: [1, 32],
    							85: [1, 34],
    							86: 33
    						}, {
    							33: [2, 78],
    							49: 50,
    							65: [2, 78],
    							72: [2, 78],
    							80: [2, 78],
    							81: [2, 78],
    							82: [2, 78],
    							83: [2, 78],
    							84: [2, 78],
    							85: [2, 78]
    						}, {
    							23: [2, 33],
    							33: [2, 33],
    							54: [2, 33],
    							65: [2, 33],
    							68: [2, 33],
    							72: [2, 33],
    							75: [2, 33],
    							80: [2, 33],
    							81: [2, 33],
    							82: [2, 33],
    							83: [2, 33],
    							84: [2, 33],
    							85: [2, 33]
    						}, {
    							23: [2, 34],
    							33: [2, 34],
    							54: [2, 34],
    							65: [2, 34],
    							68: [2, 34],
    							72: [2, 34],
    							75: [2, 34],
    							80: [2, 34],
    							81: [2, 34],
    							82: [2, 34],
    							83: [2, 34],
    							84: [2, 34],
    							85: [2, 34]
    						}, {
    							23: [2, 35],
    							33: [2, 35],
    							54: [2, 35],
    							65: [2, 35],
    							68: [2, 35],
    							72: [2, 35],
    							75: [2, 35],
    							80: [2, 35],
    							81: [2, 35],
    							82: [2, 35],
    							83: [2, 35],
    							84: [2, 35],
    							85: [2, 35]
    						}, {
    							23: [2, 36],
    							33: [2, 36],
    							54: [2, 36],
    							65: [2, 36],
    							68: [2, 36],
    							72: [2, 36],
    							75: [2, 36],
    							80: [2, 36],
    							81: [2, 36],
    							82: [2, 36],
    							83: [2, 36],
    							84: [2, 36],
    							85: [2, 36]
    						}, {
    							23: [2, 37],
    							33: [2, 37],
    							54: [2, 37],
    							65: [2, 37],
    							68: [2, 37],
    							72: [2, 37],
    							75: [2, 37],
    							80: [2, 37],
    							81: [2, 37],
    							82: [2, 37],
    							83: [2, 37],
    							84: [2, 37],
    							85: [2, 37]
    						}, {
    							23: [2, 38],
    							33: [2, 38],
    							54: [2, 38],
    							65: [2, 38],
    							68: [2, 38],
    							72: [2, 38],
    							75: [2, 38],
    							80: [2, 38],
    							81: [2, 38],
    							82: [2, 38],
    							83: [2, 38],
    							84: [2, 38],
    							85: [2, 38]
    						}, {
    							23: [2, 39],
    							33: [2, 39],
    							54: [2, 39],
    							65: [2, 39],
    							68: [2, 39],
    							72: [2, 39],
    							75: [2, 39],
    							80: [2, 39],
    							81: [2, 39],
    							82: [2, 39],
    							83: [2, 39],
    							84: [2, 39],
    							85: [2, 39]
    						}, {
    							23: [2, 43],
    							33: [2, 43],
    							54: [2, 43],
    							65: [2, 43],
    							68: [2, 43],
    							72: [2, 43],
    							75: [2, 43],
    							80: [2, 43],
    							81: [2, 43],
    							82: [2, 43],
    							83: [2, 43],
    							84: [2, 43],
    							85: [2, 43],
    							87: [1, 51]
    						}, {
    							72: [1, 35],
    							86: 52
    						}, {
    							23: [2, 45],
    							33: [2, 45],
    							54: [2, 45],
    							65: [2, 45],
    							68: [2, 45],
    							72: [2, 45],
    							75: [2, 45],
    							80: [2, 45],
    							81: [2, 45],
    							82: [2, 45],
    							83: [2, 45],
    							84: [2, 45],
    							85: [2, 45],
    							87: [2, 45]
    						}, {
    							52: 53,
    							54: [2, 82],
    							65: [2, 82],
    							72: [2, 82],
    							80: [2, 82],
    							81: [2, 82],
    							82: [2, 82],
    							83: [2, 82],
    							84: [2, 82],
    							85: [2, 82]
    						}, {
    							25: 54,
    							38: 56,
    							39: [1, 58],
    							43: 57,
    							44: [1, 59],
    							45: 55,
    							47: [2, 54]
    						}, {
    							28: 60,
    							43: 61,
    							44: [1, 59],
    							47: [2, 56]
    						}, {
    							13: 63,
    							15: [1, 20],
    							18: [1, 62]
    						}, {
    							15: [2, 48],
    							18: [2, 48]
    						}, {
    							33: [2, 86],
    							57: 64,
    							65: [2, 86],
    							72: [2, 86],
    							80: [2, 86],
    							81: [2, 86],
    							82: [2, 86],
    							83: [2, 86],
    							84: [2, 86],
    							85: [2, 86]
    						}, {
    							33: [2, 40],
    							65: [2, 40],
    							72: [2, 40],
    							80: [2, 40],
    							81: [2, 40],
    							82: [2, 40],
    							83: [2, 40],
    							84: [2, 40],
    							85: [2, 40]
    						}, {
    							33: [2, 41],
    							65: [2, 41],
    							72: [2, 41],
    							80: [2, 41],
    							81: [2, 41],
    							82: [2, 41],
    							83: [2, 41],
    							84: [2, 41],
    							85: [2, 41]
    						}, {
    							20: 65,
    							72: [1, 35],
    							78: 26,
    							79: 27,
    							80: [1, 28],
    							81: [1, 29],
    							82: [1, 30],
    							83: [1, 31],
    							84: [1, 32],
    							85: [1, 34],
    							86: 33
    						}, {
    							26: 66,
    							47: [1, 67]
    						}, {
    							30: 68,
    							33: [2, 58],
    							65: [2, 58],
    							72: [2, 58],
    							75: [2, 58],
    							80: [2, 58],
    							81: [2, 58],
    							82: [2, 58],
    							83: [2, 58],
    							84: [2, 58],
    							85: [2, 58]
    						}, {
    							33: [2, 64],
    							35: 69,
    							65: [2, 64],
    							72: [2, 64],
    							75: [2, 64],
    							80: [2, 64],
    							81: [2, 64],
    							82: [2, 64],
    							83: [2, 64],
    							84: [2, 64],
    							85: [2, 64]
    						}, {
    							21: 70,
    							23: [2, 50],
    							65: [2, 50],
    							72: [2, 50],
    							80: [2, 50],
    							81: [2, 50],
    							82: [2, 50],
    							83: [2, 50],
    							84: [2, 50],
    							85: [2, 50]
    						}, {
    							33: [2, 90],
    							61: 71,
    							65: [2, 90],
    							72: [2, 90],
    							80: [2, 90],
    							81: [2, 90],
    							82: [2, 90],
    							83: [2, 90],
    							84: [2, 90],
    							85: [2, 90]
    						}, {
    							20: 75,
    							33: [2, 80],
    							50: 72,
    							63: 73,
    							64: 76,
    							65: [1, 44],
    							69: 74,
    							70: 77,
    							71: 78,
    							72: [1, 79],
    							78: 26,
    							79: 27,
    							80: [1, 28],
    							81: [1, 29],
    							82: [1, 30],
    							83: [1, 31],
    							84: [1, 32],
    							85: [1, 34],
    							86: 33
    						}, {
    							72: [1, 80]
    						}, {
    							23: [2, 42],
    							33: [2, 42],
    							54: [2, 42],
    							65: [2, 42],
    							68: [2, 42],
    							72: [2, 42],
    							75: [2, 42],
    							80: [2, 42],
    							81: [2, 42],
    							82: [2, 42],
    							83: [2, 42],
    							84: [2, 42],
    							85: [2, 42],
    							87: [1, 51]
    						}, {
    							20: 75,
    							53: 81,
    							54: [2, 84],
    							63: 82,
    							64: 76,
    							65: [1, 44],
    							69: 83,
    							70: 77,
    							71: 78,
    							72: [1, 79],
    							78: 26,
    							79: 27,
    							80: [1, 28],
    							81: [1, 29],
    							82: [1, 30],
    							83: [1, 31],
    							84: [1, 32],
    							85: [1, 34],
    							86: 33
    						}, {
    							26: 84,
    							47: [1, 67]
    						}, {
    							47: [2, 55]
    						}, {
    							4: 85,
    							6: 3,
    							14: [2, 46],
    							15: [2, 46],
    							19: [2, 46],
    							29: [2, 46],
    							34: [2, 46],
    							39: [2, 46],
    							44: [2, 46],
    							47: [2, 46],
    							48: [2, 46],
    							51: [2, 46],
    							55: [2, 46],
    							60: [2, 46]
    						}, {
    							47: [2, 20]
    						}, {
    							20: 86,
    							72: [1, 35],
    							78: 26,
    							79: 27,
    							80: [1, 28],
    							81: [1, 29],
    							82: [1, 30],
    							83: [1, 31],
    							84: [1, 32],
    							85: [1, 34],
    							86: 33
    						}, {
    							4: 87,
    							6: 3,
    							14: [2, 46],
    							15: [2, 46],
    							19: [2, 46],
    							29: [2, 46],
    							34: [2, 46],
    							47: [2, 46],
    							48: [2, 46],
    							51: [2, 46],
    							55: [2, 46],
    							60: [2, 46]
    						}, {
    							26: 88,
    							47: [1, 67]
    						}, {
    							47: [2, 57]
    						}, {
    							5: [2, 11],
    							14: [2, 11],
    							15: [2, 11],
    							19: [2, 11],
    							29: [2, 11],
    							34: [2, 11],
    							39: [2, 11],
    							44: [2, 11],
    							47: [2, 11],
    							48: [2, 11],
    							51: [2, 11],
    							55: [2, 11],
    							60: [2, 11]
    						}, {
    							15: [2, 49],
    							18: [2, 49]
    						}, {
    							20: 75,
    							33: [2, 88],
    							58: 89,
    							63: 90,
    							64: 76,
    							65: [1, 44],
    							69: 91,
    							70: 77,
    							71: 78,
    							72: [1, 79],
    							78: 26,
    							79: 27,
    							80: [1, 28],
    							81: [1, 29],
    							82: [1, 30],
    							83: [1, 31],
    							84: [1, 32],
    							85: [1, 34],
    							86: 33
    						}, {
    							65: [2, 94],
    							66: 92,
    							68: [2, 94],
    							72: [2, 94],
    							80: [2, 94],
    							81: [2, 94],
    							82: [2, 94],
    							83: [2, 94],
    							84: [2, 94],
    							85: [2, 94]
    						}, {
    							5: [2, 25],
    							14: [2, 25],
    							15: [2, 25],
    							19: [2, 25],
    							29: [2, 25],
    							34: [2, 25],
    							39: [2, 25],
    							44: [2, 25],
    							47: [2, 25],
    							48: [2, 25],
    							51: [2, 25],
    							55: [2, 25],
    							60: [2, 25]
    						}, {
    							20: 93,
    							72: [1, 35],
    							78: 26,
    							79: 27,
    							80: [1, 28],
    							81: [1, 29],
    							82: [1, 30],
    							83: [1, 31],
    							84: [1, 32],
    							85: [1, 34],
    							86: 33
    						}, {
    							20: 75,
    							31: 94,
    							33: [2, 60],
    							63: 95,
    							64: 76,
    							65: [1, 44],
    							69: 96,
    							70: 77,
    							71: 78,
    							72: [1, 79],
    							75: [2, 60],
    							78: 26,
    							79: 27,
    							80: [1, 28],
    							81: [1, 29],
    							82: [1, 30],
    							83: [1, 31],
    							84: [1, 32],
    							85: [1, 34],
    							86: 33
    						}, {
    							20: 75,
    							33: [2, 66],
    							36: 97,
    							63: 98,
    							64: 76,
    							65: [1, 44],
    							69: 99,
    							70: 77,
    							71: 78,
    							72: [1, 79],
    							75: [2, 66],
    							78: 26,
    							79: 27,
    							80: [1, 28],
    							81: [1, 29],
    							82: [1, 30],
    							83: [1, 31],
    							84: [1, 32],
    							85: [1, 34],
    							86: 33
    						}, {
    							20: 75,
    							22: 100,
    							23: [2, 52],
    							63: 101,
    							64: 76,
    							65: [1, 44],
    							69: 102,
    							70: 77,
    							71: 78,
    							72: [1, 79],
    							78: 26,
    							79: 27,
    							80: [1, 28],
    							81: [1, 29],
    							82: [1, 30],
    							83: [1, 31],
    							84: [1, 32],
    							85: [1, 34],
    							86: 33
    						}, {
    							20: 75,
    							33: [2, 92],
    							62: 103,
    							63: 104,
    							64: 76,
    							65: [1, 44],
    							69: 105,
    							70: 77,
    							71: 78,
    							72: [1, 79],
    							78: 26,
    							79: 27,
    							80: [1, 28],
    							81: [1, 29],
    							82: [1, 30],
    							83: [1, 31],
    							84: [1, 32],
    							85: [1, 34],
    							86: 33
    						}, {
    							33: [1, 106]
    						}, {
    							33: [2, 79],
    							65: [2, 79],
    							72: [2, 79],
    							80: [2, 79],
    							81: [2, 79],
    							82: [2, 79],
    							83: [2, 79],
    							84: [2, 79],
    							85: [2, 79]
    						}, {
    							33: [2, 81]
    						}, {
    							23: [2, 27],
    							33: [2, 27],
    							54: [2, 27],
    							65: [2, 27],
    							68: [2, 27],
    							72: [2, 27],
    							75: [2, 27],
    							80: [2, 27],
    							81: [2, 27],
    							82: [2, 27],
    							83: [2, 27],
    							84: [2, 27],
    							85: [2, 27]
    						}, {
    							23: [2, 28],
    							33: [2, 28],
    							54: [2, 28],
    							65: [2, 28],
    							68: [2, 28],
    							72: [2, 28],
    							75: [2, 28],
    							80: [2, 28],
    							81: [2, 28],
    							82: [2, 28],
    							83: [2, 28],
    							84: [2, 28],
    							85: [2, 28]
    						}, {
    							23: [2, 30],
    							33: [2, 30],
    							54: [2, 30],
    							68: [2, 30],
    							71: 107,
    							72: [1, 108],
    							75: [2, 30]
    						}, {
    							23: [2, 98],
    							33: [2, 98],
    							54: [2, 98],
    							68: [2, 98],
    							72: [2, 98],
    							75: [2, 98]
    						}, {
    							23: [2, 45],
    							33: [2, 45],
    							54: [2, 45],
    							65: [2, 45],
    							68: [2, 45],
    							72: [2, 45],
    							73: [1, 109],
    							75: [2, 45],
    							80: [2, 45],
    							81: [2, 45],
    							82: [2, 45],
    							83: [2, 45],
    							84: [2, 45],
    							85: [2, 45],
    							87: [2, 45]
    						}, {
    							23: [2, 44],
    							33: [2, 44],
    							54: [2, 44],
    							65: [2, 44],
    							68: [2, 44],
    							72: [2, 44],
    							75: [2, 44],
    							80: [2, 44],
    							81: [2, 44],
    							82: [2, 44],
    							83: [2, 44],
    							84: [2, 44],
    							85: [2, 44],
    							87: [2, 44]
    						}, {
    							54: [1, 110]
    						}, {
    							54: [2, 83],
    							65: [2, 83],
    							72: [2, 83],
    							80: [2, 83],
    							81: [2, 83],
    							82: [2, 83],
    							83: [2, 83],
    							84: [2, 83],
    							85: [2, 83]
    						}, {
    							54: [2, 85]
    						}, {
    							5: [2, 13],
    							14: [2, 13],
    							15: [2, 13],
    							19: [2, 13],
    							29: [2, 13],
    							34: [2, 13],
    							39: [2, 13],
    							44: [2, 13],
    							47: [2, 13],
    							48: [2, 13],
    							51: [2, 13],
    							55: [2, 13],
    							60: [2, 13]
    						}, {
    							38: 56,
    							39: [1, 58],
    							43: 57,
    							44: [1, 59],
    							45: 112,
    							46: 111,
    							47: [2, 76]
    						}, {
    							33: [2, 70],
    							40: 113,
    							65: [2, 70],
    							72: [2, 70],
    							75: [2, 70],
    							80: [2, 70],
    							81: [2, 70],
    							82: [2, 70],
    							83: [2, 70],
    							84: [2, 70],
    							85: [2, 70]
    						}, {
    							47: [2, 18]
    						}, {
    							5: [2, 14],
    							14: [2, 14],
    							15: [2, 14],
    							19: [2, 14],
    							29: [2, 14],
    							34: [2, 14],
    							39: [2, 14],
    							44: [2, 14],
    							47: [2, 14],
    							48: [2, 14],
    							51: [2, 14],
    							55: [2, 14],
    							60: [2, 14]
    						}, {
    							33: [1, 114]
    						}, {
    							33: [2, 87],
    							65: [2, 87],
    							72: [2, 87],
    							80: [2, 87],
    							81: [2, 87],
    							82: [2, 87],
    							83: [2, 87],
    							84: [2, 87],
    							85: [2, 87]
    						}, {
    							33: [2, 89]
    						}, {
    							20: 75,
    							63: 116,
    							64: 76,
    							65: [1, 44],
    							67: 115,
    							68: [2, 96],
    							69: 117,
    							70: 77,
    							71: 78,
    							72: [1, 79],
    							78: 26,
    							79: 27,
    							80: [1, 28],
    							81: [1, 29],
    							82: [1, 30],
    							83: [1, 31],
    							84: [1, 32],
    							85: [1, 34],
    							86: 33
    						}, {
    							33: [1, 118]
    						}, {
    							32: 119,
    							33: [2, 62],
    							74: 120,
    							75: [1, 121]
    						}, {
    							33: [2, 59],
    							65: [2, 59],
    							72: [2, 59],
    							75: [2, 59],
    							80: [2, 59],
    							81: [2, 59],
    							82: [2, 59],
    							83: [2, 59],
    							84: [2, 59],
    							85: [2, 59]
    						}, {
    							33: [2, 61],
    							75: [2, 61]
    						}, {
    							33: [2, 68],
    							37: 122,
    							74: 123,
    							75: [1, 121]
    						}, {
    							33: [2, 65],
    							65: [2, 65],
    							72: [2, 65],
    							75: [2, 65],
    							80: [2, 65],
    							81: [2, 65],
    							82: [2, 65],
    							83: [2, 65],
    							84: [2, 65],
    							85: [2, 65]
    						}, {
    							33: [2, 67],
    							75: [2, 67]
    						}, {
    							23: [1, 124]
    						}, {
    							23: [2, 51],
    							65: [2, 51],
    							72: [2, 51],
    							80: [2, 51],
    							81: [2, 51],
    							82: [2, 51],
    							83: [2, 51],
    							84: [2, 51],
    							85: [2, 51]
    						}, {
    							23: [2, 53]
    						}, {
    							33: [1, 125]
    						}, {
    							33: [2, 91],
    							65: [2, 91],
    							72: [2, 91],
    							80: [2, 91],
    							81: [2, 91],
    							82: [2, 91],
    							83: [2, 91],
    							84: [2, 91],
    							85: [2, 91]
    						}, {
    							33: [2, 93]
    						}, {
    							5: [2, 22],
    							14: [2, 22],
    							15: [2, 22],
    							19: [2, 22],
    							29: [2, 22],
    							34: [2, 22],
    							39: [2, 22],
    							44: [2, 22],
    							47: [2, 22],
    							48: [2, 22],
    							51: [2, 22],
    							55: [2, 22],
    							60: [2, 22]
    						}, {
    							23: [2, 99],
    							33: [2, 99],
    							54: [2, 99],
    							68: [2, 99],
    							72: [2, 99],
    							75: [2, 99]
    						}, {
    							73: [1, 109]
    						}, {
    							20: 75,
    							63: 126,
    							64: 76,
    							65: [1, 44],
    							72: [1, 35],
    							78: 26,
    							79: 27,
    							80: [1, 28],
    							81: [1, 29],
    							82: [1, 30],
    							83: [1, 31],
    							84: [1, 32],
    							85: [1, 34],
    							86: 33
    						}, {
    							5: [2, 23],
    							14: [2, 23],
    							15: [2, 23],
    							19: [2, 23],
    							29: [2, 23],
    							34: [2, 23],
    							39: [2, 23],
    							44: [2, 23],
    							47: [2, 23],
    							48: [2, 23],
    							51: [2, 23],
    							55: [2, 23],
    							60: [2, 23]
    						}, {
    							47: [2, 19]
    						}, {
    							47: [2, 77]
    						}, {
    							20: 75,
    							33: [2, 72],
    							41: 127,
    							63: 128,
    							64: 76,
    							65: [1, 44],
    							69: 129,
    							70: 77,
    							71: 78,
    							72: [1, 79],
    							75: [2, 72],
    							78: 26,
    							79: 27,
    							80: [1, 28],
    							81: [1, 29],
    							82: [1, 30],
    							83: [1, 31],
    							84: [1, 32],
    							85: [1, 34],
    							86: 33
    						}, {
    							5: [2, 24],
    							14: [2, 24],
    							15: [2, 24],
    							19: [2, 24],
    							29: [2, 24],
    							34: [2, 24],
    							39: [2, 24],
    							44: [2, 24],
    							47: [2, 24],
    							48: [2, 24],
    							51: [2, 24],
    							55: [2, 24],
    							60: [2, 24]
    						}, {
    							68: [1, 130]
    						}, {
    							65: [2, 95],
    							68: [2, 95],
    							72: [2, 95],
    							80: [2, 95],
    							81: [2, 95],
    							82: [2, 95],
    							83: [2, 95],
    							84: [2, 95],
    							85: [2, 95]
    						}, {
    							68: [2, 97]
    						}, {
    							5: [2, 21],
    							14: [2, 21],
    							15: [2, 21],
    							19: [2, 21],
    							29: [2, 21],
    							34: [2, 21],
    							39: [2, 21],
    							44: [2, 21],
    							47: [2, 21],
    							48: [2, 21],
    							51: [2, 21],
    							55: [2, 21],
    							60: [2, 21]
    						}, {
    							33: [1, 131]
    						}, {
    							33: [2, 63]
    						}, {
    							72: [1, 133],
    							76: 132
    						}, {
    							33: [1, 134]
    						}, {
    							33: [2, 69]
    						}, {
    							15: [2, 12]
    						}, {
    							14: [2, 26],
    							15: [2, 26],
    							19: [2, 26],
    							29: [2, 26],
    							34: [2, 26],
    							47: [2, 26],
    							48: [2, 26],
    							51: [2, 26],
    							55: [2, 26],
    							60: [2, 26]
    						}, {
    							23: [2, 31],
    							33: [2, 31],
    							54: [2, 31],
    							68: [2, 31],
    							72: [2, 31],
    							75: [2, 31]
    						}, {
    							33: [2, 74],
    							42: 135,
    							74: 136,
    							75: [1, 121]
    						}, {
    							33: [2, 71],
    							65: [2, 71],
    							72: [2, 71],
    							75: [2, 71],
    							80: [2, 71],
    							81: [2, 71],
    							82: [2, 71],
    							83: [2, 71],
    							84: [2, 71],
    							85: [2, 71]
    						}, {
    							33: [2, 73],
    							75: [2, 73]
    						}, {
    							23: [2, 29],
    							33: [2, 29],
    							54: [2, 29],
    							65: [2, 29],
    							68: [2, 29],
    							72: [2, 29],
    							75: [2, 29],
    							80: [2, 29],
    							81: [2, 29],
    							82: [2, 29],
    							83: [2, 29],
    							84: [2, 29],
    							85: [2, 29]
    						}, {
    							14: [2, 15],
    							15: [2, 15],
    							19: [2, 15],
    							29: [2, 15],
    							34: [2, 15],
    							39: [2, 15],
    							44: [2, 15],
    							47: [2, 15],
    							48: [2, 15],
    							51: [2, 15],
    							55: [2, 15],
    							60: [2, 15]
    						}, {
    							72: [1, 138],
    							77: [1, 137]
    						}, {
    							72: [2, 100],
    							77: [2, 100]
    						}, {
    							14: [2, 16],
    							15: [2, 16],
    							19: [2, 16],
    							29: [2, 16],
    							34: [2, 16],
    							44: [2, 16],
    							47: [2, 16],
    							48: [2, 16],
    							51: [2, 16],
    							55: [2, 16],
    							60: [2, 16]
    						}, {
    							33: [1, 139]
    						}, {
    							33: [2, 75]
    						}, {
    							33: [2, 32]
    						}, {
    							72: [2, 101],
    							77: [2, 101]
    						}, {
    							14: [2, 17],
    							15: [2, 17],
    							19: [2, 17],
    							29: [2, 17],
    							34: [2, 17],
    							39: [2, 17],
    							44: [2, 17],
    							47: [2, 17],
    							48: [2, 17],
    							51: [2, 17],
    							55: [2, 17],
    							60: [2, 17]
    						}],
    						defaultActions: {
    							4: [2, 1],
    							55: [2, 55],
    							57: [2, 20],
    							61: [2, 57],
    							74: [2, 81],
    							83: [2, 85],
    							87: [2, 18],
    							91: [2, 89],
    							102: [2, 53],
    							105: [2, 93],
    							111: [2, 19],
    							112: [2, 77],
    							117: [2, 97],
    							120: [2, 63],
    							123: [2, 69],
    							124: [2, 12],
    							136: [2, 75],
    							137: [2, 32]
    						},
    						parseError: function parseError(str, hash) {
    							throw new Error(str);
    						},
    						parse: function parse(input) {
    							var self = this,
    								stack = [0],
    								vstack = [null],
    								lstack = [],
    								table = this.table,
    								yytext = "",
    								yylineno = 0,
    								yyleng = 0,
    								recovering = 0,
    								TERROR = 2,
    								EOF = 1;
    							this.lexer.setInput(input);
    							this.lexer.yy = this.yy;
    							this.yy.lexer = this.lexer;
    							this.yy.parser = this;
    							if (typeof this.lexer.yylloc == "undefined") this.lexer.yylloc = {};
    							var yyloc = this.lexer.yylloc;
    							lstack.push(yyloc);
    							var ranges = this.lexer.options && this.lexer.options.ranges;
    							if (typeof this.yy.parseError === "function") this.parseError = this.yy.parseError;
    
    							function popStack(n) {
    								stack.length = stack.length - 2 * n;
    								vstack.length = vstack.length - n;
    								lstack.length = lstack.length - n;
    							}
    
    							function lex() {
    								var token;
    								token = self.lexer.lex() || 1;
    								if (typeof token !== "number") {
    									token = self.symbols_[token] || token;
    								}
    								return token;
    							}
    							var symbol,
    								preErrorSymbol,
    								state,
    								action,
    								a,
    								r,
    								yyval = {},
    								p,
    								len,
    								newState,
    								expected;
    							while (true) {
    								state = stack[stack.length - 1];
    								if (this.defaultActions[state]) {
    									action = this.defaultActions[state];
    								} else {
    									if (symbol === null || typeof symbol == "undefined") {
    										symbol = lex();
    									}
    									action = table[state] && table[state][symbol];
    								}
    								if (typeof action === "undefined" || !action.length || !action[0]) {
    									var errStr = "";
    									if (!recovering) {
    										expected = [];
    										for (p in table[state])
    											if (this.terminals_[p] && p > 2) {
    												expected.push("'" + this.terminals_[p] + "'");
    											}
    										if (this.lexer.showPosition) {
    											errStr = "Parse error on line " + (yylineno + 1) + ":\n" + this.lexer.showPosition() + "\nExpecting " + expected.join(", ") + ", got '" + (this.terminals_[symbol] || symbol) + "'";
    										} else {
    											errStr = "Parse error on line " + (yylineno + 1) + ": Unexpected " + (symbol == 1 ? "end of input" : "'" + (this.terminals_[symbol] || symbol) + "'");
    										}
    										this.parseError(errStr, {
    											text: this.lexer.match,
    											token: this.terminals_[symbol] || symbol,
    											line: this.lexer.yylineno,
    											loc: yyloc,
    											expected: expected
    										});
    									}
    								}
    								if (action[0] instanceof Array && action.length > 1) {
    									throw new Error("Parse Error: multiple actions possible at state: " + state + ", token: " + symbol);
    								}
    								switch (action[0]) {
    									case 1:
    										stack.push(symbol);
    										vstack.push(this.lexer.yytext);
    										lstack.push(this.lexer.yylloc);
    										stack.push(action[1]);
    										symbol = null;
    										if (!preErrorSymbol) {
    											yyleng = this.lexer.yyleng;
    											yytext = this.lexer.yytext;
    											yylineno = this.lexer.yylineno;
    											yyloc = this.lexer.yylloc;
    											if (recovering > 0) recovering--;
    										} else {
    											symbol = preErrorSymbol;
    											preErrorSymbol = null;
    										}
    										break;
    									case 2:
    										len = this.productions_[action[1]][1];
    										yyval.$ = vstack[vstack.length - len];
    										yyval._$ = {
    											first_line: lstack[lstack.length - (len || 1)].first_line,
    											last_line: lstack[lstack.length - 1].last_line,
    											first_column: lstack[lstack.length - (len || 1)].first_column,
    											last_column: lstack[lstack.length - 1].last_column
    										};
    										if (ranges) {
    											yyval._$.range = [lstack[lstack.length - (len || 1)].range[0], lstack[lstack.length - 1].range[1]];
    										}
    										r = this.performAction.call(yyval, yytext, yyleng, yylineno, this.yy, action[1], vstack, lstack);
    										if (typeof r !== "undefined") {
    											return r;
    										}
    										if (len) {
    											stack = stack.slice(0, -1 * len * 2);
    											vstack = vstack.slice(0, -1 * len);
    											lstack = lstack.slice(0, -1 * len);
    										}
    										stack.push(this.productions_[action[1]][0]);
    										vstack.push(yyval.$);
    										lstack.push(yyval._$);
    										newState = table[stack[stack.length - 2]][stack[stack.length - 1]];
    										stack.push(newState);
    										break;
    									case 3:
    										return true;
    								}
    							}
    							return true;
    						}
    					};
    					
    					var lexer = (function() {
    						var lexer = {
    							EOF: 1,
    							parseError: function parseError(str, hash) {
    								if (this.yy.parser) {
    									this.yy.parser.parseError(str, hash);
    								} else {
    									throw new Error(str);
    								}
    							},
    							setInput: function setInput(input) {
    								this._input = input;
    								this._more = this._less = this.done = false;
    								this.yylineno = this.yyleng = 0;
    								this.yytext = this.matched = this.match = '';
    								this.conditionStack = ['INITIAL'];
    								this.yylloc = {
    									first_line: 1,
    									first_column: 0,
    									last_line: 1,
    									last_column: 0
    								};
    								if (this.options.ranges) this.yylloc.range = [0, 0];
    								this.offset = 0;
    								return this;
    							},
    							input: function input() {
    								var ch = this._input[0];
    								this.yytext += ch;
    								this.yyleng++;
    								this.offset++;
    								this.match += ch;
    								this.matched += ch;
    								var lines = ch.match(/(?:\r\n?|\n).*/g);
    								if (lines) {
    									this.yylineno++;
    									this.yylloc.last_line++;
    								} else {
    									this.yylloc.last_column++;
    								}
    								if (this.options.ranges) this.yylloc.range[1]++;
    
    								this._input = this._input.slice(1);
    								return ch;
    							},
    							unput: function unput(ch) {
    								var len = ch.length;
    								var lines = ch.split(/(?:\r\n?|\n)/g);
    
    								this._input = ch + this._input;
    								this.yytext = this.yytext.substr(0, this.yytext.length - len - 1);
    								//this.yyleng -= len;
    								this.offset -= len;
    								var oldLines = this.match.split(/(?:\r\n?|\n)/g);
    								this.match = this.match.substr(0, this.match.length - 1);
    								this.matched = this.matched.substr(0, this.matched.length - 1);
    
    								if (lines.length - 1) this.yylineno -= lines.length - 1;
    								var r = this.yylloc.range;
    
    								this.yylloc = {
    									first_line: this.yylloc.first_line,
    									last_line: this.yylineno + 1,
    									first_column: this.yylloc.first_column,
    									last_column: lines ? (lines.length === oldLines.length ? this.yylloc.first_column : 0) + oldLines[oldLines.length - lines.length].length - lines[0].length : this.yylloc.first_column - len
    								};
    
    								if (this.options.ranges) {
    									this.yylloc.range = [r[0], r[0] + this.yyleng - len];
    								}
    								return this;
    							},
    							more: function more() {
    								this._more = true;
    								return this;
    							},
    							less: function less(n) {
    								this.unput(this.match.slice(n));
    							},
    							pastInput: function pastInput() {
    								var past = this.matched.substr(0, this.matched.length - this.match.length);
    								return (past.length > 20 ? '...' : '') + past.substr(-20).replace(/\n/g, "");
    							},
    							upcomingInput: function upcomingInput() {
    								var next = this.match;
    								if (next.length < 20) {
    									next += this._input.substr(0, 20 - next.length);
    								}
    								return (next.substr(0, 20) + (next.length > 20 ? '...' : '')).replace(/\n/g, "");
    							},
    							showPosition: function showPosition() {
    								var pre = this.pastInput();
    								var c = new Array(pre.length + 1).join("-");
    								return pre + this.upcomingInput() + "\n" + c + "^";
    							},
    							next: function next() {
    								if (this.done) {
    									return this.EOF;
    								}
    								if (!this._input) this.done = true;
    
    								var token, match, tempMatch, index, col, lines;
    								if (!this._more) {
    									this.yytext = '';
    									this.match = '';
    								}
    								var rules = this._currentRules();
    								for (var i = 0; i < rules.length; i++) {
    									tempMatch = this._input.match(this.rules[rules[i]]);
    									if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {
    										match = tempMatch;
    										index = i;
    										if (!this.options.flex) break;
    									}
    								}
    								if (match) {
    									lines = match[0].match(/(?:\r\n?|\n).*/g);
    									if (lines) this.yylineno += lines.length;
    									this.yylloc = {
    										first_line: this.yylloc.last_line,
    										last_line: this.yylineno + 1,
    										first_column: this.yylloc.last_column,
    										last_column: lines ? lines[lines.length - 1].length - lines[lines.length - 1].match(/\r?\n?/)[0].length : this.yylloc.last_column + match[0].length
    									};
    									this.yytext += match[0];
    									this.match += match[0];
    									this.matches = match;
    									this.yyleng = this.yytext.length;
    									if (this.options.ranges) {
    										this.yylloc.range = [this.offset, this.offset += this.yyleng];
    									}
    									this._more = false;
    									this._input = this._input.slice(match[0].length);
    									this.matched += match[0];
    									token = this.performAction.call(this, this.yy, this, rules[index], this.conditionStack[this.conditionStack.length - 1]);
    									if (this.done && this._input) this.done = false;
    									if (token) return token;
    									else return;
    								}
    								if (this._input === "") {
    									return this.EOF;
    								} else {
    									return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. Unrecognized text.\n' + this.showPosition(), {
    										text: "",
    										token: null,
    										line: this.yylineno
    									});
    								}
    							},
    							lex: function lex() {
    								var r = this.next();
    								if (typeof r !== 'undefined') {
    									return r;
    								} else {
    									return this.lex();
    								}
    							},
    							begin: function begin(condition) {
    								this.conditionStack.push(condition);
    							},
    							popState: function popState() {
    								return this.conditionStack.pop();
    							},
    							_currentRules: function _currentRules() {
    								return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules;
    							},
    							topState: function topState() {
    								return this.conditionStack[this.conditionStack.length - 2];
    							},
    							pushState: function begin(condition) {
    								this.begin(condition);
    							}
    						};
    						lexer.options = {};
    						lexer.performAction = function anonymous(yy, yy_, $avoiding_name_collisions, YY_START
    							
    						) {
    
    							function strip(start, end) {
    								return yy_.yytext = yy_.yytext.substr(start, yy_.yyleng - end);
    							}
    
    							var YYSTATE = YY_START;
    							switch ($avoiding_name_collisions) {
    								case 0:
    									if (yy_.yytext.slice(-2) === "\\\\") {
    										strip(0, 1);
    										this.begin("mu");
    									} else if (yy_.yytext.slice(-1) === "\\") {
    										strip(0, 1);
    										this.begin("emu");
    									} else {
    										this.begin("mu");
    									}
    									if (yy_.yytext) return 15;
    
    									break;
    								case 1:
    									return 15;
    									break;
    								case 2:
    									this.popState();
    									return 15;
    
    									break;
    								case 3:
    									this.begin('raw');
    									return 15;
    									break;
    								case 4:
    									this.popState();
    									// Should be using `this.topState()` below, but it currently
    									// returns the second top instead of the first top. Opened an
    									// issue about it at https://github.com/zaach/jison/issues/291
    									if (this.conditionStack[this.conditionStack.length - 1] === 'raw') {
    										return 15;
    									} else {
    										yy_.yytext = yy_.yytext.substr(5, yy_.yyleng - 9);
    										return 'END_RAW_BLOCK';
    									}
    
    									break;
    								case 5:
    									return 15;
    									break;
    								case 6:
    									this.popState();
    									return 14;
    
    									break;
    								case 7:
    									return 65;
    									break;
    								case 8:
    									return 68;
    									break;
    								case 9:
    									return 19;
    									break;
    								case 10:
    									this.popState();
    									this.begin('raw');
    									return 23;
    
    									break;
    								case 11:
    									return 55;
    									break;
    								case 12:
    									return 60;
    									break;
    								case 13:
    									return 29;
    									break;
    								case 14:
    									return 47;
    									break;
    								case 15:
    									this.popState();
    									return 44;
    									break;
    								case 16:
    									this.popState();
    									return 44;
    									break;
    								case 17:
    									return 34;
    									break;
    								case 18:
    									return 39;
    									break;
    								case 19:
    									return 51;
    									break;
    								case 20:
    									return 48;
    									break;
    								case 21:
    									this.unput(yy_.yytext);
    									this.popState();
    									this.begin('com');
    
    									break;
    								case 22:
    									this.popState();
    									return 14;
    
    									break;
    								case 23:
    									return 48;
    									break;
    								case 24:
    									return 73;
    									break;
    								case 25:
    									return 72;
    									break;
    								case 26:
    									return 72;
    									break;
    								case 27:
    									return 87;
    									break;
    								case 28:
    									// ignore whitespace
    									break;
    								case 29:
    									this.popState();
    									return 54;
    									break;
    								case 30:
    									this.popState();
    									return 33;
    									break;
    								case 31:
    									yy_.yytext = strip(1, 2).replace(/\\"/g, '"');
    									return 80;
    									break;
    								case 32:
    									yy_.yytext = strip(1, 2).replace(/\\'/g, "'");
    									return 80;
    									break;
    								case 33:
    									return 85;
    									break;
    								case 34:
    									return 82;
    									break;
    								case 35:
    									return 82;
    									break;
    								case 36:
    									return 83;
    									break;
    								case 37:
    									return 84;
    									break;
    								case 38:
    									return 81;
    									break;
    								case 39:
    									return 75;
    									break;
    								case 40:
    									return 77;
    									break;
    								case 41:
    									return 72;
    									break;
    								case 42:
    									yy_.yytext = yy_.yytext.replace(/\\([\\\]])/g, '$1');
    									return 72;
    									break;
    								case 43:
    									return 'INVALID';
    									break;
    								case 44:
    									return 5;
    									break;
    							}
    						};
    						lexer.rules = [/^(?:[^\x00]*?(?=(\{\{)))/, /^(?:[^\x00]+)/, /^(?:[^\x00]{2,}?(?=(\{\{|\\\{\{|\\\\\{\{|$)))/, /^(?:\{\{\{\{(?=[^/]))/, /^(?:\{\{\{\{\/[^\s!"#%-,\.\/;->@\[-\^`\{-~]+(?=[=}\s\/.])\}\}\}\})/, /^(?:[^\x00]*?(?=(\{\{\{\{)))/, /^(?:[\s\S]*?--(~)?\}\})/, /^(?:\()/, /^(?:\))/, /^(?:\{\{\{\{)/, /^(?:\}\}\}\})/, /^(?:\{\{(~)?>)/, /^(?:\{\{(~)?#>)/, /^(?:\{\{(~)?#\*?)/, /^(?:\{\{(~)?\/)/, /^(?:\{\{(~)?\^\s*(~)?\}\})/, /^(?:\{\{(~)?\s*else\s*(~)?\}\})/, /^(?:\{\{(~)?\^)/, /^(?:\{\{(~)?\s*else\b)/, /^(?:\{\{(~)?\{)/, /^(?:\{\{(~)?&)/, /^(?:\{\{(~)?!--)/, /^(?:\{\{(~)?![\s\S]*?\}\})/, /^(?:\{\{(~)?\*?)/, /^(?:=)/, /^(?:\.\.)/, /^(?:\.(?=([=~}\s\/.)|])))/, /^(?:[\/.])/, /^(?:\s+)/, /^(?:\}(~)?\}\})/, /^(?:(~)?\}\})/, /^(?:"(\\["]|[^"])*")/, /^(?:'(\\[']|[^'])*')/, /^(?:@)/, /^(?:true(?=([~}\s)])))/, /^(?:false(?=([~}\s)])))/, /^(?:undefined(?=([~}\s)])))/, /^(?:null(?=([~}\s)])))/, /^(?:-?[0-9]+(?:\.[0-9]+)?(?=([~}\s)])))/, /^(?:as\s+\|)/, /^(?:\|)/, /^(?:([^\s!"#%-,\.\/;->@\[-\^`\{-~]+(?=([=~}\s\/.)|]))))/, /^(?:\[(\\\]|[^\]])*\])/, /^(?:.)/, /^(?:$)/];
    						lexer.conditions = {
    							"mu": {
    								"rules": [7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44],
    								"inclusive": false
    							},
    							"emu": {
    								"rules": [2],
    								"inclusive": false
    							},
    							"com": {
    								"rules": [6],
    								"inclusive": false
    							},
    							"raw": {
    								"rules": [3, 4, 5],
    								"inclusive": false
    							},
    							"INITIAL": {
    								"rules": [0, 1, 44],
    								"inclusive": true
    							}
    						};
    						return lexer;
    					})();
    					parser.lexer = lexer;
    
    					function Parser() {
    						this.yy = {};
    					}
    					Parser.prototype = parser;
    					parser.Parser = Parser;
    					return new Parser();
    				})();
    				exports.__esModule = true;
    				exports['default'] = handlebars;
    
    				
    			},
    			
    			
    			function(module, exports, __webpack_require__) {
    
    				
    
    				var _interopRequireDefault = __webpack_require__(1)['default'];
    
    				exports.__esModule = true;
    
    				var _visitor = __webpack_require__(25);
    
    				var _visitor2 = _interopRequireDefault(_visitor);
    
    				function WhitespaceControl() {
    					var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
    
    					this.options = options;
    				}
    				WhitespaceControl.prototype = new _visitor2['default']();
    
    				WhitespaceControl.prototype.Program = function(program) {
    					var doStandalone = !this.options.ignoreStandalone;
    
    					var isRoot = !this.isRootSeen;
    					this.isRootSeen = true;
    
    					var body = program.body;
    					for (var i = 0, l = body.length; i < l; i++) {
    						var current = body[i],
    							strip = this.accept(current);
    
    						if (!strip) {
    							continue;
    						}
    
    						var _isPrevWhitespace = isPrevWhitespace(body, i, isRoot),
    							_isNextWhitespace = isNextWhitespace(body, i, isRoot),
    							openStandalone = strip.openStandalone && _isPrevWhitespace,
    							closeStandalone = strip.closeStandalone && _isNextWhitespace,
    							inlineStandalone = strip.inlineStandalone && _isPrevWhitespace && _isNextWhitespace;
    
    						if (strip.close) {
    							omitRight(body, i, true);
    						}
    						if (strip.open) {
    							omitLeft(body, i, true);
    						}
    
    						if (doStandalone && inlineStandalone) {
    							omitRight(body, i);
    
    							if (omitLeft(body, i)) {
    								// If we are on a standalone node, save the indent info for partials
    								if (current.type === 'PartialStatement') {
    									// Pull out the whitespace from the final line
    									current.indent = /([ \t]+$)/.exec(body[i - 1].original)[1];
    								}
    							}
    						}
    						if (doStandalone && openStandalone) {
    							omitRight((current.program || current.inverse).body);
    
    							// Strip out the previous content node if it's whitespace only
    							omitLeft(body, i);
    						}
    						if (doStandalone && closeStandalone) {
    							// Always strip the next node
    							omitRight(body, i);
    
    							omitLeft((current.inverse || current.program).body);
    						}
    					}
    
    					return program;
    				};
    
    				WhitespaceControl.prototype.BlockStatement = WhitespaceControl.prototype.DecoratorBlock = WhitespaceControl.prototype.PartialBlockStatement = function(block) {
    					this.accept(block.program);
    					this.accept(block.inverse);
    
    					// Find the inverse program that is involed with whitespace stripping.
    					var program = block.program || block.inverse,
    						inverse = block.program && block.inverse,
    						firstInverse = inverse,
    						lastInverse = inverse;
    
    					if (inverse && inverse.chained) {
    						firstInverse = inverse.body[0].program;
    
    						// Walk the inverse chain to find the last inverse that is actually in the chain.
    						while (lastInverse.chained) {
    							lastInverse = lastInverse.body[lastInverse.body.length - 1].program;
    						}
    					}
    
    					var strip = {
    						open: block.openStrip.open,
    						close: block.closeStrip.close,
    
    						// Determine the standalone candiacy. Basically flag our content as being possibly standalone
    						// so our parent can determine if we actually are standalone
    						openStandalone: isNextWhitespace(program.body),
    						closeStandalone: isPrevWhitespace((firstInverse || program).body)
    					};
    
    					if (block.openStrip.close) {
    						omitRight(program.body, null, true);
    					}
    
    					if (inverse) {
    						var inverseStrip = block.inverseStrip;
    
    						if (inverseStrip.open) {
    							omitLeft(program.body, null, true);
    						}
    
    						if (inverseStrip.close) {
    							omitRight(firstInverse.body, null, true);
    						}
    						if (block.closeStrip.open) {
    							omitLeft(lastInverse.body, null, true);
    						}
    
    						// Find standalone else statments
    						if (!this.options.ignoreStandalone && isPrevWhitespace(program.body) && isNextWhitespace(firstInverse.body)) {
    							omitLeft(program.body);
    							omitRight(firstInverse.body);
    						}
    					} else if (block.closeStrip.open) {
    						omitLeft(program.body, null, true);
    					}
    
    					return strip;
    				};
    
    				WhitespaceControl.prototype.Decorator = WhitespaceControl.prototype.MustacheStatement = function(mustache) {
    					return mustache.strip;
    				};
    
    				WhitespaceControl.prototype.PartialStatement = WhitespaceControl.prototype.CommentStatement = function(node) {
    					
    					var strip = node.strip || {};
    					return {
    						inlineStandalone: true,
    						open: strip.open,
    						close: strip.close
    					};
    				};
    
    				function isPrevWhitespace(body, i, isRoot) {
    					if (i === undefined) {
    						i = body.length;
    					}
    
    					// Nodes that end with newlines are considered whitespace (but are special
    					// cased for strip operations)
    					var prev = body[i - 1],
    						sibling = body[i - 2];
    					if (!prev) {
    						return isRoot;
    					}
    
    					if (prev.type === 'ContentStatement') {
    						return (sibling || !isRoot ? /\r?\n\s*?$/ : /(^|\r?\n)\s*?$/).test(prev.original);
    					}
    				}
    
    				function isNextWhitespace(body, i, isRoot) {
    					if (i === undefined) {
    						i = -1;
    					}
    
    					var next = body[i + 1],
    						sibling = body[i + 2];
    					if (!next) {
    						return isRoot;
    					}
    
    					if (next.type === 'ContentStatement') {
    						return (sibling || !isRoot ? /^\s*?\r?\n/ : /^\s*?(\r?\n|$)/).test(next.original);
    					}
    				}
    
    				// Marks the node to the right of the position as omitted.
    				// I.e. {{foo}}' ' will mark the ' ' node as omitted.
    				//
    				// If i is undefined, then the first child will be marked as such.
    				//
    				// If mulitple is truthy then all whitespace will be stripped out until non-whitespace
    				// content is met.
    				function omitRight(body, i, multiple) {
    					var current = body[i == null ? 0 : i + 1];
    					if (!current || current.type !== 'ContentStatement' || !multiple && current.rightStripped) {
    						return;
    					}
    
    					var original = current.value;
    					current.value = current.value.replace(multiple ? /^\s+/ : /^[ \t]*\r?\n?/, '');
    					current.rightStripped = current.value !== original;
    				}
    
    				// Marks the node to the left of the position as omitted.
    				// I.e. ' '{{foo}} will mark the ' ' node as omitted.
    				//
    				// If i is undefined then the last child will be marked as such.
    				//
    				// If mulitple is truthy then all whitespace will be stripped out until non-whitespace
    				// content is met.
    				function omitLeft(body, i, multiple) {
    					var current = body[i == null ? body.length - 1 : i - 1];
    					if (!current || current.type !== 'ContentStatement' || !multiple && current.leftStripped) {
    						return;
    					}
    
    					// We omit the last node if it's whitespace only and not preceeded by a non-content node.
    					var original = current.value;
    					current.value = current.value.replace(multiple ? /\s+$/ : /[ \t]+$/, '');
    					current.leftStripped = current.value !== original;
    					return current.leftStripped;
    				}
    
    				exports['default'] = WhitespaceControl;
    				module.exports = exports['default'];
    
    				
    			},
    			
    			
    			function(module, exports, __webpack_require__) {
    
    				
    
    				var _interopRequireDefault = __webpack_require__(1)['default'];
    
    				exports.__esModule = true;
    
    				var _exception = __webpack_require__(6);
    
    				var _exception2 = _interopRequireDefault(_exception);
    
    				function Visitor() {
    					this.parents = [];
    				}
    
    				Visitor.prototype = {
    					constructor: Visitor,
    					mutating: false,
    
    					// Visits a given value. If mutating, will replace the value if necessary.
    					acceptKey: function acceptKey(node, name) {
    						var value = this.accept(node[name]);
    						if (this.mutating) {
    							// Hacky sanity check: This may have a few false positives for type for the helper
    							// methods but will generally do the right thing without a lot of overhead.
    							if (value && !Visitor.prototype[value.type]) {
    								throw new _exception2['default']('Unexpected node type "' + value.type + '" found when accepting ' + name + ' on ' + node.type);
    							}
    							node[name] = value;
    						}
    					},
    
    					// Performs an accept operation with added sanity check to ensure
    					// required keys are not removed.
    					acceptRequired: function acceptRequired(node, name) {
    						this.acceptKey(node, name);
    
    						if (!node[name]) {
    							throw new _exception2['default'](node.type + ' requires ' + name);
    						}
    					},
    
    					// Traverses a given array. If mutating, empty respnses will be removed
    					// for child elements.
    					acceptArray: function acceptArray(array) {
    						for (var i = 0, l = array.length; i < l; i++) {
    							this.acceptKey(array, i);
    
    							if (!array[i]) {
    								array.splice(i, 1);
    								i--;
    								l--;
    							}
    						}
    					},
    
    					accept: function accept(object) {
    						if (!object) {
    							return;
    						}
    
    						
    						if (!this[object.type]) {
    							throw new _exception2['default']('Unknown type: ' + object.type, object);
    						}
    
    						if (this.current) {
    							this.parents.unshift(this.current);
    						}
    						this.current = object;
    
    						var ret = this[object.type](object);
    
    						this.current = this.parents.shift();
    
    						if (!this.mutating || ret) {
    							return ret;
    						} else if (ret !== false) {
    							return object;
    						}
    					},
    
    					Program: function Program(program) {
    						this.acceptArray(program.body);
    					},
    
    					MustacheStatement: visitSubExpression,
    					Decorator: visitSubExpression,
    
    					BlockStatement: visitBlock,
    					DecoratorBlock: visitBlock,
    
    					PartialStatement: visitPartial,
    					PartialBlockStatement: function PartialBlockStatement(partial) {
    						visitPartial.call(this, partial);
    
    						this.acceptKey(partial, 'program');
    					},
    
    					ContentStatement: function ContentStatement()  {},
    					CommentStatement: function CommentStatement()  {},
    
    					SubExpression: visitSubExpression,
    
    					PathExpression: function PathExpression()  {},
    
    					StringLiteral: function StringLiteral()  {},
    					NumberLiteral: function NumberLiteral()  {},
    					BooleanLiteral: function BooleanLiteral()  {},
    					UndefinedLiteral: function UndefinedLiteral()  {},
    					NullLiteral: function NullLiteral()  {},
    
    					Hash: function Hash(hash) {
    						this.acceptArray(hash.pairs);
    					},
    					HashPair: function HashPair(pair) {
    						this.acceptRequired(pair, 'value');
    					}
    				};
    
    				function visitSubExpression(mustache) {
    					this.acceptRequired(mustache, 'path');
    					this.acceptArray(mustache.params);
    					this.acceptKey(mustache, 'hash');
    				}
    
    				function visitBlock(block) {
    					visitSubExpression.call(this, block);
    
    					this.acceptKey(block, 'program');
    					this.acceptKey(block, 'inverse');
    				}
    
    				function visitPartial(partial) {
    					this.acceptRequired(partial, 'name');
    					this.acceptArray(partial.params);
    					this.acceptKey(partial, 'hash');
    				}
    
    				exports['default'] = Visitor;
    				module.exports = exports['default'];
    
    				
    			},
    			
    			
    			function(module, exports, __webpack_require__) {
    
    				
    
    				var _interopRequireDefault = __webpack_require__(1)['default'];
    
    				exports.__esModule = true;
    				exports.SourceLocation = SourceLocation;
    				exports.id = id;
    				exports.stripFlags = stripFlags;
    				exports.stripComment = stripComment;
    				exports.preparePath = preparePath;
    				exports.prepareMustache = prepareMustache;
    				exports.prepareRawBlock = prepareRawBlock;
    				exports.prepareBlock = prepareBlock;
    				exports.prepareProgram = prepareProgram;
    				exports.preparePartialBlock = preparePartialBlock;
    
    				var _exception = __webpack_require__(6);
    
    				var _exception2 = _interopRequireDefault(_exception);
    
    				function validateClose(open, close) {
    					close = close.path ? close.path.original : close;
    
    					if (open.path.original !== close) {
    						var errorNode = {
    							loc: open.path.loc
    						};
    
    						throw new _exception2['default'](open.path.original + " doesn't match " + close, errorNode);
    					}
    				}
    
    				function SourceLocation(source, locInfo) {
    					this.source = source;
    					this.start = {
    						line: locInfo.first_line,
    						column: locInfo.first_column
    					};
    					this.end = {
    						line: locInfo.last_line,
    						column: locInfo.last_column
    					};
    				}
    
    				function id(token) {
    					if (/^\[.*\]$/.test(token)) {
    						return token.substr(1, token.length - 2);
    					} else {
    						return token;
    					}
    				}
    
    				function stripFlags(open, close) {
    					return {
    						open: open.charAt(2) === '~',
    						close: close.charAt(close.length - 3) === '~'
    					};
    				}
    
    				function stripComment(comment) {
    					return comment.replace(/^\{\{~?\!-?-?/, '').replace(/-?-?~?\}\}$/, '');
    				}
    
    				function preparePath(data, parts, loc) {
    					loc = this.locInfo(loc);
    
    					var original = data ? '@' : '',
    						dig = [],
    						depth = 0,
    						depthString = '';
    
    					for (var i = 0, l = parts.length; i < l; i++) {
    						var part = parts[i].part,
    
    							// If we have [] syntax then we do not treat path references as operators,
    							// i.e. foo.[this] resolves to approximately context.foo['this']
    							isLiteral = parts[i].original !== part;
    						original += (parts[i].separator || '') + part;
    
    						if (!isLiteral && (part === '..' || part === '.' || part === 'this')) {
    							if (dig.length > 0) {
    								throw new _exception2['default']('Invalid path: ' + original, {
    									loc: loc
    								});
    							} else if (part === '..') {
    								depth++;
    								depthString += '../';
    							}
    						} else {
    							dig.push(part);
    						}
    					}
    
    					return {
    						type: 'PathExpression',
    						data: data,
    						depth: depth,
    						parts: dig,
    						original: original,
    						loc: loc
    					};
    				}
    
    				function prepareMustache(path, params, hash, open, strip, locInfo) {
    					// Must use charAt to support IE pre-10
    					var escapeFlag = open.charAt(3) || open.charAt(2),
    						escaped = escapeFlag !== '{' && escapeFlag !== '&';
    
    					var decorator = /\*/.test(open);
    					return {
    						type: decorator ? 'Decorator' : 'MustacheStatement',
    						path: path,
    						params: params,
    						hash: hash,
    						escaped: escaped,
    						strip: strip,
    						loc: this.locInfo(locInfo)
    					};
    				}
    
    				function prepareRawBlock(openRawBlock, contents, close, locInfo) {
    					validateClose(openRawBlock, close);
    
    					locInfo = this.locInfo(locInfo);
    					var program = {
    						type: 'Program',
    						body: contents,
    						strip: {},
    						loc: locInfo
    					};
    
    					return {
    						type: 'BlockStatement',
    						path: openRawBlock.path,
    						params: openRawBlock.params,
    						hash: openRawBlock.hash,
    						program: program,
    						openStrip: {},
    						inverseStrip: {},
    						closeStrip: {},
    						loc: locInfo
    					};
    				}
    
    				function prepareBlock(openBlock, program, inverseAndProgram, close, inverted, locInfo) {
    					if (close && close.path) {
    						validateClose(openBlock, close);
    					}
    
    					var decorator = /\*/.test(openBlock.open);
    
    					program.blockParams = openBlock.blockParams;
    
    					var inverse = undefined,
    						inverseStrip = undefined;
    
    					if (inverseAndProgram) {
    						if (decorator) {
    							throw new _exception2['default']('Unexpected inverse block on decorator', inverseAndProgram);
    						}
    
    						if (inverseAndProgram.chain) {
    							inverseAndProgram.program.body[0].closeStrip = close.strip;
    						}
    
    						inverseStrip = inverseAndProgram.strip;
    						inverse = inverseAndProgram.program;
    					}
    
    					if (inverted) {
    						inverted = inverse;
    						inverse = program;
    						program = inverted;
    					}
    
    					return {
    						type: decorator ? 'DecoratorBlock' : 'BlockStatement',
    						path: openBlock.path,
    						params: openBlock.params,
    						hash: openBlock.hash,
    						program: program,
    						inverse: inverse,
    						openStrip: openBlock.strip,
    						inverseStrip: inverseStrip,
    						closeStrip: close && close.strip,
    						loc: this.locInfo(locInfo)
    					};
    				}
    
    				function prepareProgram(statements, loc) {
    					if (!loc && statements.length) {
    						var firstLoc = statements[0].loc,
    							lastLoc = statements[statements.length - 1].loc;
    
    						
    						if (firstLoc && lastLoc) {
    							loc = {
    								source: firstLoc.source,
    								start: {
    									line: firstLoc.start.line,
    									column: firstLoc.start.column
    								},
    								end: {
    									line: lastLoc.end.line,
    									column: lastLoc.end.column
    								}
    							};
    						}
    					}
    
    					return {
    						type: 'Program',
    						body: statements,
    						strip: {},
    						loc: loc
    					};
    				}
    
    				function preparePartialBlock(open, program, close, locInfo) {
    					validateClose(open, close);
    
    					return {
    						type: 'PartialBlockStatement',
    						name: open.path,
    						params: open.params,
    						hash: open.hash,
    						program: program,
    						openStrip: open.strip,
    						closeStrip: close && close.strip,
    						loc: this.locInfo(locInfo)
    					};
    				}
    
    				
    			},
    			
    			
    			function(module, exports, __webpack_require__) {
    
    				
    
    				
    
    				var _interopRequireDefault = __webpack_require__(1)['default'];
    
    				exports.__esModule = true;
    				exports.Compiler = Compiler;
    				exports.precompile = precompile;
    				exports.compile = compile;
    
    				var _exception = __webpack_require__(6);
    
    				var _exception2 = _interopRequireDefault(_exception);
    
    				var _utils = __webpack_require__(5);
    
    				var _ast = __webpack_require__(21);
    
    				var _ast2 = _interopRequireDefault(_ast);
    
    				var slice = [].slice;
    
    				function Compiler() {}
    
    				// the foundHelper register will disambiguate helper lookup from finding a
    				// function in a context. This is necessary for mustache compatibility, which
    				// requires that context functions in blocks are evaluated by blockHelperMissing,
    				// and then proceed as if the resulting value was provided to blockHelperMissing.
    
    				Compiler.prototype = {
    					compiler: Compiler,
    
    					equals: function equals(other) {
    						var len = this.opcodes.length;
    						if (other.opcodes.length !== len) {
    							return false;
    						}
    
    						for (var i = 0; i < len; i++) {
    							var opcode = this.opcodes[i],
    								otherOpcode = other.opcodes[i];
    							if (opcode.opcode !== otherOpcode.opcode || !argEquals(opcode.args, otherOpcode.args)) {
    								return false;
    							}
    						}
    
    						// We know that length is the same between the two arrays because they are directly tied
    						// to the opcode behavior above.
    						len = this.children.length;
    						for (var i = 0; i < len; i++) {
    							if (!this.children[i].equals(other.children[i])) {
    								return false;
    							}
    						}
    
    						return true;
    					},
    
    					guid: 0,
    
    					compile: function compile(program, options) {
    						this.sourceNode = [];
    						this.opcodes = [];
    						this.children = [];
    						this.options = options;
    						this.stringParams = options.stringParams;
    						this.trackIds = options.trackIds;
    
    						options.blockParams = options.blockParams || [];
    
    						// These changes will propagate to the other compiler components
    						var knownHelpers = options.knownHelpers;
    						options.knownHelpers = {
    							'helperMissing': true,
    							'blockHelperMissing': true,
    							'each': true,
    							'if': true,
    							'unless': true,
    							'with': true,
    							'log': true,
    							'lookup': true
    						};
    						if (knownHelpers) {
    							for (var _name in knownHelpers) {
    								
    								if (_name in knownHelpers) {
    									options.knownHelpers[_name] = knownHelpers[_name];
    								}
    							}
    						}
    
    						return this.accept(program);
    					},
    
    					compileProgram: function compileProgram(program) {
    						var childCompiler = new this.compiler(),
    							// eslint-disable-line new-cap
    							result = childCompiler.compile(program, this.options),
    							guid = this.guid++;
    
    						this.usePartial = this.usePartial || result.usePartial;
    
    						this.children[guid] = result;
    						this.useDepths = this.useDepths || result.useDepths;
    
    						return guid;
    					},
    
    					accept: function accept(node) {
    						
    						if (!this[node.type]) {
    							throw new _exception2['default']('Unknown type: ' + node.type, node);
    						}
    
    						this.sourceNode.unshift(node);
    						var ret = this[node.type](node);
    						this.sourceNode.shift();
    						return ret;
    					},
    
    					Program: function Program(program) {
    						this.options.blockParams.unshift(program.blockParams);
    
    						var body = program.body,
    							bodyLength = body.length;
    						for (var i = 0; i < bodyLength; i++) {
    							this.accept(body[i]);
    						}
    
    						this.options.blockParams.shift();
    
    						this.isSimple = bodyLength === 1;
    						this.blockParams = program.blockParams ? program.blockParams.length : 0;
    
    						return this;
    					},
    
    					BlockStatement: function BlockStatement(block) {
    						transformLiteralToPath(block);
    
    						var program = block.program,
    							inverse = block.inverse;
    
    						program = program && this.compileProgram(program);
    						inverse = inverse && this.compileProgram(inverse);
    
    						var type = this.classifySexpr(block);
    
    						if (type === 'helper') {
    							this.helperSexpr(block, program, inverse);
    						} else if (type === 'simple') {
    							this.simpleSexpr(block);
    
    							// now that the simple mustache is resolved, we need to
    							// evaluate it by executing `blockHelperMissing`
    							this.opcode('pushProgram', program);
    							this.opcode('pushProgram', inverse);
    							this.opcode('emptyHash');
    							this.opcode('blockValue', block.path.original);
    						} else {
    							this.ambiguousSexpr(block, program, inverse);
    
    							// now that the simple mustache is resolved, we need to
    							// evaluate it by executing `blockHelperMissing`
    							this.opcode('pushProgram', program);
    							this.opcode('pushProgram', inverse);
    							this.opcode('emptyHash');
    							this.opcode('ambiguousBlockValue');
    						}
    
    						this.opcode('append');
    					},
    
    					DecoratorBlock: function DecoratorBlock(decorator) {
    						var program = decorator.program && this.compileProgram(decorator.program);
    						var params = this.setupFullMustacheParams(decorator, program, undefined),
    							path = decorator.path;
    
    						this.useDecorators = true;
    						this.opcode('registerDecorator', params.length, path.original);
    					},
    
    					PartialStatement: function PartialStatement(partial) {
    						this.usePartial = true;
    
    						var program = partial.program;
    						if (program) {
    							program = this.compileProgram(partial.program);
    						}
    
    						var params = partial.params;
    						if (params.length > 1) {
    							throw new _exception2['default']('Unsupported number of partial arguments: ' + params.length, partial);
    						} else if (!params.length) {
    							if (this.options.explicitPartialContext) {
    								this.opcode('pushLiteral', 'undefined');
    							} else {
    								params.push({
    									type: 'PathExpression',
    									parts: [],
    									depth: 0
    								});
    							}
    						}
    
    						var partialName = partial.name.original,
    							isDynamic = partial.name.type === 'SubExpression';
    						if (isDynamic) {
    							this.accept(partial.name);
    						}
    
    						this.setupFullMustacheParams(partial, program, undefined, true);
    
    						var indent = partial.indent || '';
    						if (this.options.preventIndent && indent) {
    							this.opcode('appendContent', indent);
    							indent = '';
    						}
    
    						this.opcode('invokePartial', isDynamic, partialName, indent);
    						this.opcode('append');
    					},
    					PartialBlockStatement: function PartialBlockStatement(partialBlock) {
    						this.PartialStatement(partialBlock);
    					},
    
    					MustacheStatement: function MustacheStatement(mustache) {
    						this.SubExpression(mustache);
    
    						if (mustache.escaped && !this.options.noEscape) {
    							this.opcode('appendEscaped');
    						} else {
    							this.opcode('append');
    						}
    					},
    					Decorator: function Decorator(decorator) {
    						this.DecoratorBlock(decorator);
    					},
    
    					ContentStatement: function ContentStatement(content) {
    						if (content.value) {
    							this.opcode('appendContent', content.value);
    						}
    					},
    
    					CommentStatement: function CommentStatement() {},
    
    					SubExpression: function SubExpression(sexpr) {
    						transformLiteralToPath(sexpr);
    						var type = this.classifySexpr(sexpr);
    
    						if (type === 'simple') {
    							this.simpleSexpr(sexpr);
    						} else if (type === 'helper') {
    							this.helperSexpr(sexpr);
    						} else {
    							this.ambiguousSexpr(sexpr);
    						}
    					},
    					ambiguousSexpr: function ambiguousSexpr(sexpr, program, inverse) {
    						var path = sexpr.path,
    							name = path.parts[0],
    							isBlock = program != null || inverse != null;
    
    						this.opcode('getContext', path.depth);
    
    						this.opcode('pushProgram', program);
    						this.opcode('pushProgram', inverse);
    
    						path.strict = true;
    						this.accept(path);
    
    						this.opcode('invokeAmbiguous', name, isBlock);
    					},
    
    					simpleSexpr: function simpleSexpr(sexpr) {
    						var path = sexpr.path;
    						path.strict = true;
    						this.accept(path);
    						this.opcode('resolvePossibleLambda');
    					},
    
    					helperSexpr: function helperSexpr(sexpr, program, inverse) {
    						var params = this.setupFullMustacheParams(sexpr, program, inverse),
    							path = sexpr.path,
    							name = path.parts[0];
    
    						if (this.options.knownHelpers[name]) {
    							this.opcode('invokeKnownHelper', params.length, name);
    						} else if (this.options.knownHelpersOnly) {
    							throw new _exception2['default']('You specified knownHelpersOnly, but used the unknown helper ' + name, sexpr);
    						} else {
    							path.strict = true;
    							path.falsy = true;
    
    							this.accept(path);
    							this.opcode('invokeHelper', params.length, path.original, _ast2['default'].helpers.simpleId(path));
    						}
    					},
    
    					PathExpression: function PathExpression(path) {
    						this.addDepth(path.depth);
    						this.opcode('getContext', path.depth);
    
    						var name = path.parts[0],
    							scoped = _ast2['default'].helpers.scopedId(path),
    							blockParamId = !path.depth && !scoped && this.blockParamIndex(name);
    
    						if (blockParamId) {
    							this.opcode('lookupBlockParam', blockParamId, path.parts);
    						} else if (!name) {
    							// Context reference, i.e. `{{foo .}}` or `{{foo ..}}`
    							this.opcode('pushContext');
    						} else if (path.data) {
    							this.options.data = true;
    							this.opcode('lookupData', path.depth, path.parts, path.strict);
    						} else {
    							this.opcode('lookupOnContext', path.parts, path.falsy, path.strict, scoped);
    						}
    					},
    
    					StringLiteral: function StringLiteral(string) {
    						this.opcode('pushString', string.value);
    					},
    
    					NumberLiteral: function NumberLiteral(number) {
    						this.opcode('pushLiteral', number.value);
    					},
    
    					BooleanLiteral: function BooleanLiteral(bool) {
    						this.opcode('pushLiteral', bool.value);
    					},
    
    					UndefinedLiteral: function UndefinedLiteral() {
    						this.opcode('pushLiteral', 'undefined');
    					},
    
    					NullLiteral: function NullLiteral() {
    						this.opcode('pushLiteral', 'null');
    					},
    
    					Hash: function Hash(hash) {
    						var pairs = hash.pairs,
    							i = 0,
    							l = pairs.length;
    
    						this.opcode('pushHash');
    
    						for (; i < l; i++) {
    							this.pushParam(pairs[i].value);
    						}
    						while (i--) {
    							this.opcode('assignToHash', pairs[i].key);
    						}
    						this.opcode('popHash');
    					},
    
    					// HELPERS
    					opcode: function opcode(name) {
    						this.opcodes.push({
    							opcode: name,
    							args: slice.call(arguments, 1),
    							loc: this.sourceNode[0].loc
    						});
    					},
    
    					addDepth: function addDepth(depth) {
    						if (!depth) {
    							return;
    						}
    
    						this.useDepths = true;
    					},
    
    					classifySexpr: function classifySexpr(sexpr) {
    						var isSimple = _ast2['default'].helpers.simpleId(sexpr.path);
    
    						var isBlockParam = isSimple && !!this.blockParamIndex(sexpr.path.parts[0]);
    
    						// a mustache is an eligible helper if:
    						// * its id is simple (a single part, not `this` or `..`)
    						var isHelper = !isBlockParam && _ast2['default'].helpers.helperExpression(sexpr);
    
    						// if a mustache is an eligible helper but not a definite
    						// helper, it is ambiguous, and will be resolved in a later
    						// pass or at runtime.
    						var isEligible = !isBlockParam && (isHelper || isSimple);
    
    						// if ambiguous, we can possibly resolve the ambiguity now
    						// An eligible helper is one that does not have a complex path, i.e. `this.foo`, `../foo` etc.
    						if (isEligible && !isHelper) {
    							var _name2 = sexpr.path.parts[0],
    								options = this.options;
    
    							if (options.knownHelpers[_name2]) {
    								isHelper = true;
    							} else if (options.knownHelpersOnly) {
    								isEligible = false;
    							}
    						}
    
    						if (isHelper) {
    							return 'helper';
    						} else if (isEligible) {
    							return 'ambiguous';
    						} else {
    							return 'simple';
    						}
    					},
    
    					pushParams: function pushParams(params) {
    						for (var i = 0, l = params.length; i < l; i++) {
    							this.pushParam(params[i]);
    						}
    					},
    
    					pushParam: function pushParam(val) {
    						var value = val.value != null ? val.value : val.original || '';
    
    						if (this.stringParams) {
    							if (value.replace) {
    								value = value.replace(/^(\.?\.\/)*/g, '').replace(/\//g, '.');
    							}
    
    							if (val.depth) {
    								this.addDepth(val.depth);
    							}
    							this.opcode('getContext', val.depth || 0);
    							this.opcode('pushStringParam', value, val.type);
    
    							if (val.type === 'SubExpression') {
    								// SubExpressions get evaluated and passed in
    								// in string params mode.
    								this.accept(val);
    							}
    						} else {
    							if (this.trackIds) {
    								var blockParamIndex = undefined;
    								if (val.parts && !_ast2['default'].helpers.scopedId(val) && !val.depth) {
    									blockParamIndex = this.blockParamIndex(val.parts[0]);
    								}
    								if (blockParamIndex) {
    									var blockParamChild = val.parts.slice(1).join('.');
    									this.opcode('pushId', 'BlockParam', blockParamIndex, blockParamChild);
    								} else {
    									value = val.original || value;
    									if (value.replace) {
    										value = value.replace(/^this(?:\.|$)/, '').replace(/^\.\//, '').replace(/^\.$/, '');
    									}
    
    									this.opcode('pushId', val.type, value);
    								}
    							}
    							this.accept(val);
    						}
    					},
    
    					setupFullMustacheParams: function setupFullMustacheParams(sexpr, program, inverse, omitEmpty) {
    						var params = sexpr.params;
    						this.pushParams(params);
    
    						this.opcode('pushProgram', program);
    						this.opcode('pushProgram', inverse);
    
    						if (sexpr.hash) {
    							this.accept(sexpr.hash);
    						} else {
    							this.opcode('emptyHash', omitEmpty);
    						}
    
    						return params;
    					},
    
    					blockParamIndex: function blockParamIndex(name) {
    						for (var depth = 0, len = this.options.blockParams.length; depth < len; depth++) {
    							var blockParams = this.options.blockParams[depth],
    								param = blockParams && _utils.indexOf(blockParams, name);
    							if (blockParams && param >= 0) {
    								return [depth, param];
    							}
    						}
    					}
    				};
    
    				function precompile(input, options, env) {
    					if (input == null || typeof input !== 'string' && input.type !== 'Program') {
    						throw new _exception2['default']('You must pass a string or Handlebars AST to Handlebars.precompile. You passed ' + input);
    					}
    
    					options = options || {};
    					if (!('data' in options)) {
    						options.data = true;
    					}
    					if (options.compat) {
    						options.useDepths = true;
    					}
    
    					var ast = env.parse(input, options),
    						environment = new env.Compiler().compile(ast, options);
    					return new env.JavaScriptCompiler().compile(environment, options);
    				}
    
    				function compile(input, options, env) {
    					if (options === undefined) options = {};
    
    					if (input == null || typeof input !== 'string' && input.type !== 'Program') {
    						throw new _exception2['default']('You must pass a string or Handlebars AST to Handlebars.compile. You passed ' + input);
    					}
    
    					if (!('data' in options)) {
    						options.data = true;
    					}
    					if (options.compat) {
    						options.useDepths = true;
    					}
    
    					var compiled = undefined;
    
    					function compileInput() {
    						var ast = env.parse(input, options),
    							environment = new env.Compiler().compile(ast, options),
    							templateSpec = new env.JavaScriptCompiler().compile(environment, options, undefined, true);
    						return env.template(templateSpec);
    					}
    
    					// Template is only compiled on first use and cached after that point.
    					function ret(context, execOptions) {
    						if (!compiled) {
    							compiled = compileInput();
    						}
    						return compiled.call(this, context, execOptions);
    					}
    					ret._setup = function(setupOptions) {
    						if (!compiled) {
    							compiled = compileInput();
    						}
    						return compiled._setup(setupOptions);
    					};
    					ret._child = function(i, data, blockParams, depths) {
    						if (!compiled) {
    							compiled = compileInput();
    						}
    						return compiled._child(i, data, blockParams, depths);
    					};
    					return ret;
    				}
    
    				function argEquals(a, b) {
    					if (a === b) {
    						return true;
    					}
    
    					if (_utils.isArray(a) && _utils.isArray(b) && a.length === b.length) {
    						for (var i = 0; i < a.length; i++) {
    							if (!argEquals(a[i], b[i])) {
    								return false;
    							}
    						}
    						return true;
    					}
    				}
    
    				function transformLiteralToPath(sexpr) {
    					if (!sexpr.path.parts) {
    						var literal = sexpr.path;
    						// Casting to string here to make false and 0 literal values play nicely with the rest
    						// of the system.
    						sexpr.path = {
    							type: 'PathExpression',
    							data: false,
    							depth: 0,
    							parts: [literal.original + ''],
    							original: literal.original + '',
    							loc: literal.loc
    						};
    					}
    				}
    
    				
    			},
    			
    			
    			function(module, exports, __webpack_require__) {
    
    				
    
    				var _interopRequireDefault = __webpack_require__(1)['default'];
    
    				exports.__esModule = true;
    
    				var _base = __webpack_require__(4);
    
    				var _exception = __webpack_require__(6);
    
    				var _exception2 = _interopRequireDefault(_exception);
    
    				var _utils = __webpack_require__(5);
    
    				var _codeGen = __webpack_require__(29);
    
    				var _codeGen2 = _interopRequireDefault(_codeGen);
    
    				function Literal(value) {
    					this.value = value;
    				}
    
    				function JavaScriptCompiler() {}
    
    				JavaScriptCompiler.prototype = {
    					// PUBLIC API: You can override these methods in a subclass to provide
    					// alternative compiled forms for name lookup and buffering semantics
    					nameLookup: function nameLookup(parent, name  ) {
    						if (JavaScriptCompiler.isValidJavaScriptVariableName(name)) {
    							return [parent, '.', name];
    						} else {
    							return [parent, '[', JSON.stringify(name), ']'];
    						}
    					},
    					depthedLookup: function depthedLookup(name) {
    						return [this.aliasable('container.lookup'), '(depths, "', name, '")'];
    					},
    
    					compilerInfo: function compilerInfo() {
    						var revision = _base.COMPILER_REVISION,
    							versions = _base.REVISION_CHANGES[revision];
    						return [revision, versions];
    					},
    
    					appendToBuffer: function appendToBuffer(source, location, explicit) {
    						// Force a source as this simplifies the merge logic.
    						if (!_utils.isArray(source)) {
    							source = [source];
    						}
    						source = this.source.wrap(source, location);
    
    						if (this.environment.isSimple) {
    							return ['return ', source, ';'];
    						} else if (explicit) {
    							// This is a case where the buffer operation occurs as a child of another
    							// construct, generally braces. We have to explicitly output these buffer
    							// operations to ensure that the emitted code goes in the correct location.
    							return ['buffer += ', source, ';'];
    						} else {
    							source.appendToBuffer = true;
    							return source;
    						}
    					},
    
    					initializeBuffer: function initializeBuffer() {
    						return this.quotedString('');
    					},
    					// END PUBLIC API
    
    					compile: function compile(environment, options, context, asObject) {
    						this.environment = environment;
    						this.options = options;
    						this.stringParams = this.options.stringParams;
    						this.trackIds = this.options.trackIds;
    						this.precompile = !asObject;
    
    						this.name = this.environment.name;
    						this.isChild = !!context;
    						this.context = context || {
    							decorators: [],
    							programs: [],
    							environments: []
    						};
    
    						this.preamble();
    
    						this.stackSlot = 0;
    						this.stackVars = [];
    						this.aliases = {};
    						this.registers = {
    							list: []
    						};
    						this.hashes = [];
    						this.compileStack = [];
    						this.inlineStack = [];
    						this.blockParams = [];
    
    						this.compileChildren(environment, options);
    
    						this.useDepths = this.useDepths || environment.useDepths || environment.useDecorators || this.options.compat;
    						this.useBlockParams = this.useBlockParams || environment.useBlockParams;
    
    						var opcodes = environment.opcodes,
    							opcode = undefined,
    							firstLoc = undefined,
    							i = undefined,
    							l = undefined;
    
    						for (i = 0, l = opcodes.length; i < l; i++) {
    							opcode = opcodes[i];
    
    							this.source.currentLocation = opcode.loc;
    							firstLoc = firstLoc || opcode.loc;
    							this[opcode.opcode].apply(this, opcode.args);
    						}
    
    						// Flush any trailing content that might be pending.
    						this.source.currentLocation = firstLoc;
    						this.pushSource('');
    
    						
    						if (this.stackSlot || this.inlineStack.length || this.compileStack.length) {
    							throw new _exception2['default']('Compile completed with content left on stack');
    						}
    
    						if (!this.decorators.isEmpty()) {
    							this.useDecorators = true;
    
    							this.decorators.prepend('var decorators = container.decorators;\n');
    							this.decorators.push('return fn;');
    
    							if (asObject) {
    								this.decorators = Function.apply(this, ['fn', 'props', 'container', 'depth0', 'data', 'blockParams', 'depths', this.decorators.merge()]);
    							} else {
    								this.decorators.prepend('function(fn, props, container, depth0, data, blockParams, depths) {\n');
    								this.decorators.push('}\n');
    								this.decorators = this.decorators.merge();
    							}
    						} else {
    							this.decorators = undefined;
    						}
    
    						var fn = this.createFunctionContext(asObject);
    						if (!this.isChild) {
    							var ret = {
    								compiler: this.compilerInfo(),
    								main: fn
    							};
    
    							if (this.decorators) {
    								ret.main_d = this.decorators; // eslint-disable-line camelcase
    								ret.useDecorators = true;
    							}
    
    							var _context = this.context;
    							var programs = _context.programs;
    							var decorators = _context.decorators;
    
    							for (i = 0, l = programs.length; i < l; i++) {
    								if (programs[i]) {
    									ret[i] = programs[i];
    									if (decorators[i]) {
    										ret[i + '_d'] = decorators[i];
    										ret.useDecorators = true;
    									}
    								}
    							}
    
    							if (this.environment.usePartial) {
    								ret.usePartial = true;
    							}
    							if (this.options.data) {
    								ret.useData = true;
    							}
    							if (this.useDepths) {
    								ret.useDepths = true;
    							}
    							if (this.useBlockParams) {
    								ret.useBlockParams = true;
    							}
    							if (this.options.compat) {
    								ret.compat = true;
    							}
    
    							if (!asObject) {
    								ret.compiler = JSON.stringify(ret.compiler);
    
    								this.source.currentLocation = {
    									start: {
    										line: 1,
    										column: 0
    									}
    								};
    								ret = this.objectLiteral(ret);
    
    								if (options.srcName) {
    									ret = ret.toStringWithSourceMap({
    										file: options.destName
    									});
    									ret.map = ret.map && ret.map.toString();
    								} else {
    									ret = ret.toString();
    								}
    							} else {
    								ret.compilerOptions = this.options;
    							}
    
    							return ret;
    						} else {
    							return fn;
    						}
    					},
    
    					preamble: function preamble() {
    						// track the last context pushed into place to allow skipping the
    						// getContext opcode when it would be a noop
    						this.lastContext = 0;
    						this.source = new _codeGen2['default'](this.options.srcName);
    						this.decorators = new _codeGen2['default'](this.options.srcName);
    					},
    
    					createFunctionContext: function createFunctionContext(asObject) {
    						var varDeclarations = '';
    
    						var locals = this.stackVars.concat(this.registers.list);
    						if (locals.length > 0) {
    							varDeclarations += ', ' + locals.join(', ');
    						}
    
    						// Generate minimizer alias mappings
    						//
    						// When using true SourceNodes, this will update all references to the given alias
    						// as the source nodes are reused in situ. For the non-source node compilation mode,
    						// aliases will not be used, but this case is already being run on the client and
    						// we aren't concern about minimizing the template size.
    						var aliasCount = 0;
    						for (var alias in this.aliases) {
    							// eslint-disable-line guard-for-in
    							var node = this.aliases[alias];
    
    							if (this.aliases.hasOwnProperty(alias) && node.children && node.referenceCount > 1) {
    								varDeclarations += ', alias' + ++aliasCount + '=' + alias;
    								node.children[0] = 'alias' + aliasCount;
    							}
    						}
    
    						var params = ['container', 'depth0', 'helpers', 'partials', 'data'];
    
    						if (this.useBlockParams || this.useDepths) {
    							params.push('blockParams');
    						}
    						if (this.useDepths) {
    							params.push('depths');
    						}
    
    						// Perform a second pass over the output to merge content when possible
    						var source = this.mergeSource(varDeclarations);
    
    						if (asObject) {
    							params.push(source);
    
    							return Function.apply(this, params);
    						} else {
    							return this.source.wrap(['function(', params.join(','), ') {\n  ', source, '}']);
    						}
    					},
    					mergeSource: function mergeSource(varDeclarations) {
    						var isSimple = this.environment.isSimple,
    							appendOnly = !this.forceBuffer,
    							appendFirst = undefined,
    							sourceSeen = undefined,
    							bufferStart = undefined,
    							bufferEnd = undefined;
    						this.source.each(function(line) {
    							if (line.appendToBuffer) {
    								if (bufferStart) {
    									line.prepend('  + ');
    								} else {
    									bufferStart = line;
    								}
    								bufferEnd = line;
    							} else {
    								if (bufferStart) {
    									if (!sourceSeen) {
    										appendFirst = true;
    									} else {
    										bufferStart.prepend('buffer += ');
    									}
    									bufferEnd.add(';');
    									bufferStart = bufferEnd = undefined;
    								}
    
    								sourceSeen = true;
    								if (!isSimple) {
    									appendOnly = false;
    								}
    							}
    						});
    
    						if (appendOnly) {
    							if (bufferStart) {
    								bufferStart.prepend('return ');
    								bufferEnd.add(';');
    							} else if (!sourceSeen) {
    								this.source.push('return "";');
    							}
    						} else {
    							varDeclarations += ', buffer = ' + (appendFirst ? '' : this.initializeBuffer());
    
    							if (bufferStart) {
    								bufferStart.prepend('return buffer + ');
    								bufferEnd.add(';');
    							} else {
    								this.source.push('return buffer;');
    							}
    						}
    
    						if (varDeclarations) {
    							this.source.prepend('var ' + varDeclarations.substring(2) + (appendFirst ? '' : ';\n'));
    						}
    
    						return this.source.merge();
    					},
    
    					// [blockValue]
    					//
    					// On stack, before: hash, inverse, program, value
    					// On stack, after: return value of blockHelperMissing
    					//
    					// The purpose of this opcode is to take a block of the form
    					// `{{#this.foo}}...{{/this.foo}}`, resolve the value of `foo`, and
    					// replace it on the stack with the result of properly
    					// invoking blockHelperMissing.
    					blockValue: function blockValue(name) {
    						var blockHelperMissing = this.aliasable('helpers.blockHelperMissing'),
    							params = [this.contextName(0)];
    						this.setupHelperArgs(name, 0, params);
    
    						var blockName = this.popStack();
    						params.splice(1, 0, blockName);
    
    						this.push(this.source.functionCall(blockHelperMissing, 'call', params));
    					},
    
    					// [ambiguousBlockValue]
    					//
    					// On stack, before: hash, inverse, program, value
    					// Compiler value, before: lastHelper=value of last found helper, if any
    					// On stack, after, if no lastHelper: same as [blockValue]
    					// On stack, after, if lastHelper: value
    					ambiguousBlockValue: function ambiguousBlockValue() {
    						// We're being a bit cheeky and reusing the options value from the prior exec
    						var blockHelperMissing = this.aliasable('helpers.blockHelperMissing'),
    							params = [this.contextName(0)];
    						this.setupHelperArgs('', 0, params, true);
    
    						this.flushInline();
    
    						var current = this.topStack();
    						params.splice(1, 0, current);
    
    						this.pushSource(['if (!', this.lastHelper, ') { ', current, ' = ', this.source.functionCall(blockHelperMissing, 'call', params), '}']);
    					},
    
    					// [appendContent]
    					//
    					// On stack, before: ...
    					// On stack, after: ...
    					//
    					// Appends the string value of `content` to the current buffer
    					appendContent: function appendContent(content) {
    						if (this.pendingContent) {
    							content = this.pendingContent + content;
    						} else {
    							this.pendingLocation = this.source.currentLocation;
    						}
    
    						this.pendingContent = content;
    					},
    
    					// [append]
    					//
    					// On stack, before: value, ...
    					// On stack, after: ...
    					//
    					// Coerces `value` to a String and appends it to the current buffer.
    					//
    					// If `value` is truthy, or 0, it is coerced into a string and appended
    					// Otherwise, the empty string is appended
    					append: function append() {
    						if (this.isInline()) {
    							this.replaceStack(function(current) {
    								return [' != null ? ', current, ' : ""'];
    							});
    
    							this.pushSource(this.appendToBuffer(this.popStack()));
    						} else {
    							var local = this.popStack();
    							this.pushSource(['if (', local, ' != null) { ', this.appendToBuffer(local, undefined, true), ' }']);
    							if (this.environment.isSimple) {
    								this.pushSource(['else { ', this.appendToBuffer("''", undefined, true), ' }']);
    							}
    						}
    					},
    
    					// [appendEscaped]
    					//
    					// On stack, before: value, ...
    					// On stack, after: ...
    					//
    					// Escape `value` and append it to the buffer
    					appendEscaped: function appendEscaped() {
    						this.pushSource(this.appendToBuffer([this.aliasable('container.escapeExpression'), '(', this.popStack(), ')']));
    					},
    
    					// [getContext]
    					//
    					// On stack, before: ...
    					// On stack, after: ...
    					// Compiler value, after: lastContext=depth
    					//
    					// Set the value of the `lastContext` compiler value to the depth
    					getContext: function getContext(depth) {
    						this.lastContext = depth;
    					},
    
    					// [pushContext]
    					//
    					// On stack, before: ...
    					// On stack, after: currentContext, ...
    					//
    					// Pushes the value of the current context onto the stack.
    					pushContext: function pushContext() {
    						this.pushStackLiteral(this.contextName(this.lastContext));
    					},
    
    					// [lookupOnContext]
    					//
    					// On stack, before: ...
    					// On stack, after: currentContext[name], ...
    					//
    					// Looks up the value of `name` on the current context and pushes
    					// it onto the stack.
    					lookupOnContext: function lookupOnContext(parts, falsy, strict, scoped) {
    						var i = 0;
    
    						if (!scoped && this.options.compat && !this.lastContext) {
    							// The depthed query is expected to handle the undefined logic for the root level that
    							// is implemented below, so we evaluate that directly in compat mode
    							this.push(this.depthedLookup(parts[i++]));
    						} else {
    							this.pushContext();
    						}
    
    						this.resolvePath('context', parts, i, falsy, strict);
    					},
    
    					// [lookupBlockParam]
    					//
    					// On stack, before: ...
    					// On stack, after: blockParam[name], ...
    					//
    					// Looks up the value of `parts` on the given block param and pushes
    					// it onto the stack.
    					lookupBlockParam: function lookupBlockParam(blockParamId, parts) {
    						this.useBlockParams = true;
    
    						this.push(['blockParams[', blockParamId[0], '][', blockParamId[1], ']']);
    						this.resolvePath('context', parts, 1);
    					},
    
    					// [lookupData]
    					//
    					// On stack, before: ...
    					// On stack, after: data, ...
    					//
    					// Push the data lookup operator
    					lookupData: function lookupData(depth, parts, strict) {
    						if (!depth) {
    							this.pushStackLiteral('data');
    						} else {
    							this.pushStackLiteral('container.data(data, ' + depth + ')');
    						}
    
    						this.resolvePath('data', parts, 0, true, strict);
    					},
    
    					resolvePath: function resolvePath(type, parts, i, falsy, strict) {
    						// istanbul ignore next
    
    						var _this = this;
    
    						if (this.options.strict || this.options.assumeObjects) {
    							this.push(strictLookup(this.options.strict && strict, this, parts, type));
    							return;
    						}
    
    						var len = parts.length;
    						for (; i < len; i++) {
    							
    							this.replaceStack(function(current) {
    								var lookup = _this.nameLookup(current, parts[i], type);
    								// We want to ensure that zero and false are handled properly if the context (falsy flag)
    								// needs to have the special handling for these values.
    								if (!falsy) {
    									return [' != null ? ', lookup, ' : ', current];
    								} else {
    									// Otherwise we can use generic falsy handling
    									return [' && ', lookup];
    								}
    							});
    							
    						}
    					},
    
    					// [resolvePossibleLambda]
    					//
    					// On stack, before: value, ...
    					// On stack, after: resolved value, ...
    					//
    					// If the `value` is a lambda, replace it on the stack by
    					// the return value of the lambda
    					resolvePossibleLambda: function resolvePossibleLambda() {
    						this.push([this.aliasable('container.lambda'), '(', this.popStack(), ', ', this.contextName(0), ')']);
    					},
    
    					// [pushStringParam]
    					//
    					// On stack, before: ...
    					// On stack, after: string, currentContext, ...
    					//
    					// This opcode is designed for use in string mode, which
    					// provides the string value of a parameter along with its
    					// depth rather than resolving it immediately.
    					pushStringParam: function pushStringParam(string, type) {
    						this.pushContext();
    						this.pushString(type);
    
    						// If it's a subexpression, the string result
    						// will be pushed after this opcode.
    						if (type !== 'SubExpression') {
    							if (typeof string === 'string') {
    								this.pushString(string);
    							} else {
    								this.pushStackLiteral(string);
    							}
    						}
    					},
    
    					emptyHash: function emptyHash(omitEmpty) {
    						if (this.trackIds) {
    							this.push('{}'); // hashIds
    						}
    						if (this.stringParams) {
    							this.push('{}'); // hashContexts
    							this.push('{}'); // hashTypes
    						}
    						this.pushStackLiteral(omitEmpty ? 'undefined' : '{}');
    					},
    					pushHash: function pushHash() {
    						if (this.hash) {
    							this.hashes.push(this.hash);
    						}
    						this.hash = {
    							values: [],
    							types: [],
    							contexts: [],
    							ids: []
    						};
    					},
    					popHash: function popHash() {
    						var hash = this.hash;
    						this.hash = this.hashes.pop();
    
    						if (this.trackIds) {
    							this.push(this.objectLiteral(hash.ids));
    						}
    						if (this.stringParams) {
    							this.push(this.objectLiteral(hash.contexts));
    							this.push(this.objectLiteral(hash.types));
    						}
    
    						this.push(this.objectLiteral(hash.values));
    					},
    
    					// [pushString]
    					//
    					// On stack, before: ...
    					// On stack, after: quotedString(string), ...
    					//
    					// Push a quoted version of `string` onto the stack
    					pushString: function pushString(string) {
    						this.pushStackLiteral(this.quotedString(string));
    					},
    
    					// [pushLiteral]
    					//
    					// On stack, before: ...
    					// On stack, after: value, ...
    					//
    					// Pushes a value onto the stack. This operation prevents
    					// the compiler from creating a temporary variable to hold
    					// it.
    					pushLiteral: function pushLiteral(value) {
    						this.pushStackLiteral(value);
    					},
    
    					// [pushProgram]
    					//
    					// On stack, before: ...
    					// On stack, after: program(guid), ...
    					//
    					// Push a program expression onto the stack. This takes
    					// a compile-time guid and converts it into a runtime-accessible
    					// expression.
    					pushProgram: function pushProgram(guid) {
    						if (guid != null) {
    							this.pushStackLiteral(this.programExpression(guid));
    						} else {
    							this.pushStackLiteral(null);
    						}
    					},
    
    					// [registerDecorator]
    					//
    					// On stack, before: hash, program, params..., ...
    					// On stack, after: ...
    					//
    					// Pops off the decorator's parameters, invokes the decorator,
    					// and inserts the decorator into the decorators list.
    					registerDecorator: function registerDecorator(paramSize, name) {
    						var foundDecorator = this.nameLookup('decorators', name, 'decorator'),
    							options = this.setupHelperArgs(name, paramSize);
    
    						this.decorators.push(['fn = ', this.decorators.functionCall(foundDecorator, '', ['fn', 'props', 'container', options]), ' || fn;']);
    					},
    
    					// [invokeHelper]
    					//
    					// On stack, before: hash, inverse, program, params..., ...
    					// On stack, after: result of helper invocation
    					//
    					// Pops off the helper's parameters, invokes the helper,
    					// and pushes the helper's return value onto the stack.
    					//
    					// If the helper is not found, `helperMissing` is called.
    					invokeHelper: function invokeHelper(paramSize, name, isSimple) {
    						var nonHelper = this.popStack(),
    							helper = this.setupHelper(paramSize, name),
    							simple = isSimple ? [helper.name, ' || '] : '';
    
    						var lookup = ['('].concat(simple, nonHelper);
    						if (!this.options.strict) {
    							lookup.push(' || ', this.aliasable('helpers.helperMissing'));
    						}
    						lookup.push(')');
    
    						this.push(this.source.functionCall(lookup, 'call', helper.callParams));
    					},
    
    					// [invokeKnownHelper]
    					//
    					// On stack, before: hash, inverse, program, params..., ...
    					// On stack, after: result of helper invocation
    					//
    					// This operation is used when the helper is known to exist,
    					// so a `helperMissing` fallback is not required.
    					invokeKnownHelper: function invokeKnownHelper(paramSize, name) {
    						var helper = this.setupHelper(paramSize, name);
    						this.push(this.source.functionCall(helper.name, 'call', helper.callParams));
    					},
    
    					// [invokeAmbiguous]
    					//
    					// On stack, before: hash, inverse, program, params..., ...
    					// On stack, after: result of disambiguation
    					//
    					// This operation is used when an expression like `{{foo}}`
    					// is provided, but we don't know at compile-time whether it
    					// is a helper or a path.
    					//
    					// This operation emits more code than the other options,
    					// and can be avoided by passing the `knownHelpers` and
    					// `knownHelpersOnly` flags at compile-time.
    					invokeAmbiguous: function invokeAmbiguous(name, helperCall) {
    						this.useRegister('helper');
    
    						var nonHelper = this.popStack();
    
    						this.emptyHash();
    						var helper = this.setupHelper(0, name, helperCall);
    
    						var helperName = this.lastHelper = this.nameLookup('helpers', name, 'helper');
    
    						var lookup = ['(', '(helper = ', helperName, ' || ', nonHelper, ')'];
    						if (!this.options.strict) {
    							lookup[0] = '(helper = ';
    							lookup.push(' != null ? helper : ', this.aliasable('helpers.helperMissing'));
    						}
    
    						this.push(['(', lookup, helper.paramsInit ? ['),(', helper.paramsInit] : [], '),', '(typeof helper === ', this.aliasable('"function"'), ' ? ', this.source.functionCall('helper', 'call', helper.callParams), ' : helper))']);
    					},
    
    					// [invokePartial]
    					//
    					// On stack, before: context, ...
    					// On stack after: result of partial invocation
    					//
    					// This operation pops off a context, invokes a partial with that context,
    					// and pushes the result of the invocation back.
    					invokePartial: function invokePartial(isDynamic, name, indent) {
    						var params = [],
    							options = this.setupParams(name, 1, params);
    
    						if (isDynamic) {
    							name = this.popStack();
    							delete options.name;
    						}
    
    						if (indent) {
    							options.indent = JSON.stringify(indent);
    						}
    						options.helpers = 'helpers';
    						options.partials = 'partials';
    						options.decorators = 'container.decorators';
    
    						if (!isDynamic) {
    							params.unshift(this.nameLookup('partials', name, 'partial'));
    						} else {
    							params.unshift(name);
    						}
    
    						if (this.options.compat) {
    							options.depths = 'depths';
    						}
    						options = this.objectLiteral(options);
    						params.push(options);
    
    						this.push(this.source.functionCall('container.invokePartial', '', params));
    					},
    
    					// [assignToHash]
    					//
    					// On stack, before: value, ..., hash, ...
    					// On stack, after: ..., hash, ...
    					//
    					// Pops a value off the stack and assigns it to the current hash
    					assignToHash: function assignToHash(key) {
    						var value = this.popStack(),
    							context = undefined,
    							type = undefined,
    							id = undefined;
    
    						if (this.trackIds) {
    							id = this.popStack();
    						}
    						if (this.stringParams) {
    							type = this.popStack();
    							context = this.popStack();
    						}
    
    						var hash = this.hash;
    						if (context) {
    							hash.contexts[key] = context;
    						}
    						if (type) {
    							hash.types[key] = type;
    						}
    						if (id) {
    							hash.ids[key] = id;
    						}
    						hash.values[key] = value;
    					},
    
    					pushId: function pushId(type, name, child) {
    						if (type === 'BlockParam') {
    							this.pushStackLiteral('blockParams[' + name[0] + '].path[' + name[1] + ']' + (child ? ' + ' + JSON.stringify('.' + child) : ''));
    						} else if (type === 'PathExpression') {
    							this.pushString(name);
    						} else if (type === 'SubExpression') {
    							this.pushStackLiteral('true');
    						} else {
    							this.pushStackLiteral('null');
    						}
    					},
    
    					// HELPERS
    
    					compiler: JavaScriptCompiler,
    
    					compileChildren: function compileChildren(environment, options) {
    						var children = environment.children,
    							child = undefined,
    							compiler = undefined;
    
    						for (var i = 0, l = children.length; i < l; i++) {
    							child = children[i];
    							compiler = new this.compiler(); // eslint-disable-line new-cap
    
    							var index = this.matchExistingProgram(child);
    
    							if (index == null) {
    								this.context.programs.push(''); // Placeholder to prevent name conflicts for nested children
    								index = this.context.programs.length;
    								child.index = index;
    								child.name = 'program' + index;
    								this.context.programs[index] = compiler.compile(child, options, this.context, !this.precompile);
    								this.context.decorators[index] = compiler.decorators;
    								this.context.environments[index] = child;
    
    								this.useDepths = this.useDepths || compiler.useDepths;
    								this.useBlockParams = this.useBlockParams || compiler.useBlockParams;
    							} else {
    								child.index = index;
    								child.name = 'program' + index;
    
    								this.useDepths = this.useDepths || child.useDepths;
    								this.useBlockParams = this.useBlockParams || child.useBlockParams;
    							}
    						}
    					},
    					matchExistingProgram: function matchExistingProgram(child) {
    						for (var i = 0, len = this.context.environments.length; i < len; i++) {
    							var environment = this.context.environments[i];
    							if (environment && environment.equals(child)) {
    								return i;
    							}
    						}
    					},
    
    					programExpression: function programExpression(guid) {
    						var child = this.environment.children[guid],
    							programParams = [child.index, 'data', child.blockParams];
    
    						if (this.useBlockParams || this.useDepths) {
    							programParams.push('blockParams');
    						}
    						if (this.useDepths) {
    							programParams.push('depths');
    						}
    
    						return 'container.program(' + programParams.join(', ') + ')';
    					},
    
    					useRegister: function useRegister(name) {
    						if (!this.registers[name]) {
    							this.registers[name] = true;
    							this.registers.list.push(name);
    						}
    					},
    
    					push: function push(expr) {
    						if (!(expr instanceof Literal)) {
    							expr = this.source.wrap(expr);
    						}
    
    						this.inlineStack.push(expr);
    						return expr;
    					},
    
    					pushStackLiteral: function pushStackLiteral(item) {
    						this.push(new Literal(item));
    					},
    
    					pushSource: function pushSource(source) {
    						if (this.pendingContent) {
    							this.source.push(this.appendToBuffer(this.source.quotedString(this.pendingContent), this.pendingLocation));
    							this.pendingContent = undefined;
    						}
    
    						if (source) {
    							this.source.push(source);
    						}
    					},
    
    					replaceStack: function replaceStack(callback) {
    						var prefix = ['('],
    							stack = undefined,
    							createdStack = undefined,
    							usedLiteral = undefined;
    
    						
    						if (!this.isInline()) {
    							throw new _exception2['default']('replaceStack on non-inline');
    						}
    
    						// We want to merge the inline statement into the replacement statement via ','
    						var top = this.popStack(true);
    
    						if (top instanceof Literal) {
    							// Literals do not need to be inlined
    							stack = [top.value];
    							prefix = ['(', stack];
    							usedLiteral = true;
    						} else {
    							// Get or create the current stack name for use by the inline
    							createdStack = true;
    							var _name = this.incrStack();
    
    							prefix = ['((', this.push(_name), ' = ', top, ')'];
    							stack = this.topStack();
    						}
    
    						var item = callback.call(this, stack);
    
    						if (!usedLiteral) {
    							this.popStack();
    						}
    						if (createdStack) {
    							this.stackSlot--;
    						}
    						this.push(prefix.concat(item, ')'));
    					},
    
    					incrStack: function incrStack() {
    						this.stackSlot++;
    						if (this.stackSlot > this.stackVars.length) {
    							this.stackVars.push('stack' + this.stackSlot);
    						}
    						return this.topStackName();
    					},
    					topStackName: function topStackName() {
    						return 'stack' + this.stackSlot;
    					},
    					flushInline: function flushInline() {
    						var inlineStack = this.inlineStack;
    						this.inlineStack = [];
    						for (var i = 0, len = inlineStack.length; i < len; i++) {
    							var entry = inlineStack[i];
    							
    							if (entry instanceof Literal) {
    								this.compileStack.push(entry);
    							} else {
    								var stack = this.incrStack();
    								this.pushSource([stack, ' = ', entry, ';']);
    								this.compileStack.push(stack);
    							}
    						}
    					},
    					isInline: function isInline() {
    						return this.inlineStack.length;
    					},
    
    					popStack: function popStack(wrapped) {
    						var inline = this.isInline(),
    							item = (inline ? this.inlineStack : this.compileStack).pop();
    
    						if (!wrapped && item instanceof Literal) {
    							return item.value;
    						} else {
    							if (!inline) {
    								
    								if (!this.stackSlot) {
    									throw new _exception2['default']('Invalid stack pop');
    								}
    								this.stackSlot--;
    							}
    							return item;
    						}
    					},
    
    					topStack: function topStack() {
    						var stack = this.isInline() ? this.inlineStack : this.compileStack,
    							item = stack[stack.length - 1];
    
    						
    						if (item instanceof Literal) {
    							return item.value;
    						} else {
    							return item;
    						}
    					},
    
    					contextName: function contextName(context) {
    						if (this.useDepths && context) {
    							return 'depths[' + context + ']';
    						} else {
    							return 'depth' + context;
    						}
    					},
    
    					quotedString: function quotedString(str) {
    						return this.source.quotedString(str);
    					},
    
    					objectLiteral: function objectLiteral(obj) {
    						return this.source.objectLiteral(obj);
    					},
    
    					aliasable: function aliasable(name) {
    						var ret = this.aliases[name];
    						if (ret) {
    							ret.referenceCount++;
    							return ret;
    						}
    
    						ret = this.aliases[name] = this.source.wrap(name);
    						ret.aliasable = true;
    						ret.referenceCount = 1;
    
    						return ret;
    					},
    
    					setupHelper: function setupHelper(paramSize, name, blockHelper) {
    						var params = [],
    							paramsInit = this.setupHelperArgs(name, paramSize, params, blockHelper);
    						var foundHelper = this.nameLookup('helpers', name, 'helper'),
    							callContext = this.aliasable(this.contextName(0) + ' != null ? ' + this.contextName(0) + ' : {}');
    
    						return {
    							params: params,
    							paramsInit: paramsInit,
    							name: foundHelper,
    							callParams: [callContext].concat(params)
    						};
    					},
    
    					setupParams: function setupParams(helper, paramSize, params) {
    						var options = {},
    							contexts = [],
    							types = [],
    							ids = [],
    							objectArgs = !params,
    							param = undefined;
    
    						if (objectArgs) {
    							params = [];
    						}
    
    						options.name = this.quotedString(helper);
    						options.hash = this.popStack();
    
    						if (this.trackIds) {
    							options.hashIds = this.popStack();
    						}
    						if (this.stringParams) {
    							options.hashTypes = this.popStack();
    							options.hashContexts = this.popStack();
    						}
    
    						var inverse = this.popStack(),
    							program = this.popStack();
    
    						// Avoid setting fn and inverse if neither are set. This allows
    						// helpers to do a check for `if (options.fn)`
    						if (program || inverse) {
    							options.fn = program || 'container.noop';
    							options.inverse = inverse || 'container.noop';
    						}
    
    						// The parameters go on to the stack in order (making sure that they are evaluated in order)
    						// so we need to pop them off the stack in reverse order
    						var i = paramSize;
    						while (i--) {
    							param = this.popStack();
    							params[i] = param;
    
    							if (this.trackIds) {
    								ids[i] = this.popStack();
    							}
    							if (this.stringParams) {
    								types[i] = this.popStack();
    								contexts[i] = this.popStack();
    							}
    						}
    
    						if (objectArgs) {
    							options.args = this.source.generateArray(params);
    						}
    
    						if (this.trackIds) {
    							options.ids = this.source.generateArray(ids);
    						}
    						if (this.stringParams) {
    							options.types = this.source.generateArray(types);
    							options.contexts = this.source.generateArray(contexts);
    						}
    
    						if (this.options.data) {
    							options.data = 'data';
    						}
    						if (this.useBlockParams) {
    							options.blockParams = 'blockParams';
    						}
    						return options;
    					},
    
    					setupHelperArgs: function setupHelperArgs(helper, paramSize, params, useRegister) {
    						var options = this.setupParams(helper, paramSize, params);
    						options = this.objectLiteral(options);
    						if (useRegister) {
    							this.useRegister('options');
    							params.push('options');
    							return ['options=', options];
    						} else if (params) {
    							params.push(options);
    							return '';
    						} else {
    							return options;
    						}
    					}
    				};
    
    				(function() {
    					var reservedWords = ('break else new var' + ' case finally return void' + ' catch for switch while' + ' continue function this with' + ' default if throw' + ' delete in try' + ' do instanceof typeof' + ' abstract enum int short' + ' boolean export interface static' + ' byte extends long super' + ' char final native synchronized' + ' class float package throws' + ' const goto private transient' + ' debugger implements protected volatile' + ' double import public let yield await' + ' null true false').split(' ');
    
    					var compilerWords = JavaScriptCompiler.RESERVED_WORDS = {};
    
    					for (var i = 0, l = reservedWords.length; i < l; i++) {
    						compilerWords[reservedWords[i]] = true;
    					}
    				})();
    
    				JavaScriptCompiler.isValidJavaScriptVariableName = function(name) {
    					return !JavaScriptCompiler.RESERVED_WORDS[name] && /^[a-zA-Z_$][0-9a-zA-Z_$]*$/.test(name);
    				};
    
    				function strictLookup(requireTerminal, compiler, parts, type) {
    					var stack = compiler.popStack(),
    						i = 0,
    						len = parts.length;
    					if (requireTerminal) {
    						len--;
    					}
    
    					for (; i < len; i++) {
    						stack = compiler.nameLookup(stack, parts[i], type);
    					}
    
    					if (requireTerminal) {
    						return [compiler.aliasable('container.strict'), '(', stack, ', ', compiler.quotedString(parts[i]), ')'];
    					} else {
    						return stack;
    					}
    				}
    
    				exports['default'] = JavaScriptCompiler;
    				module.exports = exports['default'];
    
    				
    			},
    			
    			
    			function(module, exports, __webpack_require__) {
    
    				
    				
    
    				exports.__esModule = true;
    
    				var _utils = __webpack_require__(5);
    
    				var SourceNode = undefined;
    
    				try {
    					
    					if (true) {
    						// We don't support this in AMD environments. For these environments, we asusme that
    						// they are running on the browser and thus have no need for the source-map library.
    						// var SourceMap = require('source-map');
    						// SourceNode = SourceMap.SourceNode;
    					}
    				} catch (err) {}
    				
    
    				
    				if (!SourceNode) {
    					SourceNode = function(line, column, srcFile, chunks) {
    						this.src = '';
    						if (chunks) {
    							this.add(chunks);
    						}
    					};
    					
    					SourceNode.prototype = {
    						add: function add(chunks) {
    							if (_utils.isArray(chunks)) {
    								chunks = chunks.join('');
    							}
    							this.src += chunks;
    						},
    						prepend: function prepend(chunks) {
    							if (_utils.isArray(chunks)) {
    								chunks = chunks.join('');
    							}
    							this.src = chunks + this.src;
    						},
    						toStringWithSourceMap: function toStringWithSourceMap() {
    							return {
    								code: this.toString()
    							};
    						},
    						toString: function toString() {
    							return this.src;
    						}
    					};
    				}
    
    				function castChunk(chunk, codeGen, loc) {
    					if (_utils.isArray(chunk)) {
    						var ret = [];
    
    						for (var i = 0, len = chunk.length; i < len; i++) {
    							ret.push(codeGen.wrap(chunk[i], loc));
    						}
    						return ret;
    					} else if (typeof chunk === 'boolean' || typeof chunk === 'number') {
    						// Handle primitives that the SourceNode will throw up on
    						return chunk + '';
    					}
    					return chunk;
    				}
    
    				function CodeGen(srcFile) {
    					this.srcFile = srcFile;
    					this.source = [];
    				}
    
    				CodeGen.prototype = {
    					isEmpty: function isEmpty() {
    						return !this.source.length;
    					},
    					prepend: function prepend(source, loc) {
    						this.source.unshift(this.wrap(source, loc));
    					},
    					push: function push(source, loc) {
    						this.source.push(this.wrap(source, loc));
    					},
    
    					merge: function merge() {
    						var source = this.empty();
    						this.each(function(line) {
    							source.add(['  ', line, '\n']);
    						});
    						return source;
    					},
    
    					each: function each(iter) {
    						for (var i = 0, len = this.source.length; i < len; i++) {
    							iter(this.source[i]);
    						}
    					},
    
    					empty: function empty() {
    						var loc = this.currentLocation || {
    							start: {}
    						};
    						return new SourceNode(loc.start.line, loc.start.column, this.srcFile);
    					},
    					wrap: function wrap(chunk) {
    						var loc = arguments.length <= 1 || arguments[1] === undefined ? this.currentLocation || {
    							start: {}
    						} : arguments[1];
    
    						if (chunk instanceof SourceNode) {
    							return chunk;
    						}
    
    						chunk = castChunk(chunk, this, loc);
    
    						return new SourceNode(loc.start.line, loc.start.column, this.srcFile, chunk);
    					},
    
    					functionCall: function functionCall(fn, type, params) {
    						params = this.generateList(params);
    						return this.wrap([fn, type ? '.' + type + '(' : '(', params, ')']);
    					},
    
    					quotedString: function quotedString(str) {
    						return '"' + (str + '').replace(/\\/g, '\\\\').replace(/"/g, '\\"').replace(/\n/g, '\\n').replace(/\r/g, '\\r').replace(/\u2028/g, '\\u2028') // Per Ecma-262 7.3 + 7.8.4
    							.replace(/\u2029/g, '\\u2029') + '"';
    					},
    
    					objectLiteral: function objectLiteral(obj) {
    						var pairs = [];
    
    						for (var key in obj) {
    							if (obj.hasOwnProperty(key)) {
    								var value = castChunk(obj[key], this);
    								if (value !== 'undefined') {
    									pairs.push([this.quotedString(key), ':', value]);
    								}
    							}
    						}
    
    						var ret = this.generateList(pairs);
    						ret.prepend('{');
    						ret.add('}');
    						return ret;
    					},
    
    					generateList: function generateList(entries) {
    						var ret = this.empty();
    
    						for (var i = 0, len = entries.length; i < len; i++) {
    							if (i) {
    								ret.add(',');
    							}
    
    							ret.add(castChunk(entries[i], this));
    						}
    
    						return ret;
    					},
    
    					generateArray: function generateArray(entries) {
    						var ret = this.generateList(entries);
    						ret.prepend('[');
    						ret.add(']');
    
    						return ret;
    					}
    				};
    
    				exports['default'] = CodeGen;
    				module.exports = exports['default'];
    
    				
    			}
    			
    		])
    });
    
    define('basic/tools/template',function() {
    	var Handlebars = require('lib/handlebars'),
    		templatesHTML = {},
    		template = {};
    
    	templatesHTML.BODYTEMPLATE = '<div class="main-layout">';
    	templatesHTML.BODYTEMPLATE += '<table class="cui-grid" cellspacing="0" cellpadding="0" id="tableContainer">';
    	templatesHTML.BODYTEMPLATE += '<tbody><tr><td><div class="left-corner"></div></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr></tbody>';
    	templatesHTML.BODYTEMPLATE += '</table></div>';
    	templatesHTML.BODYTEMPLATE += '<div class="sheet-layout"><div class="sheet-body">';
    	templatesHTML.BODYTEMPLATE += '<div class="sheet-cf-box glyphicons glyphicon-plus"></div>';
    	templatesHTML.BODYTEMPLATE += '<div class="sheet-cf-box active glyphicons glyphicon-th-list"></div>';
    	templatesHTML.BODYTEMPLATE += '<div class="sheet-cf-list"></div></div></div>';
    	templatesHTML.BODYTEMPLATE += '<div class="mask"><div class="mask-bg"></div>';
    	templatesHTML.BODYTEMPLATE += '<div class="mask-text">加载中..&nbsp;. &nbsp;. &nbsp;&nbsp;.</div></div>';
    	templatesHTML.BODYTEMPLATE += '</div>';
    
    	templatesHTML.SHEETTEMPLATE = '<span>{{name}}</span>';
    
    	templatesHTML.ROWHEADTEMPLATE = '<div class="item">{{displayName}}</div>';
    	templatesHTML.COLHEADTEMPLATE = '<div class="item">{{displayName}}</div>';
    
    	templatesHTML.INPUTTEMPLATE = '<div class="textarea"><textarea class="input-container"></textarea><div>';
    
    	templatesHTML.SELECTTEMPLATE = '<div class="box"><div class="expand"></div><div class="bg"></div></div>';
    
    	templatesHTML.CELLTEMPLATE = '<div class="bg" style="display:table-cell;"></div>';
    
    	templatesHTML.COLGRIDTEMPLATE = '<div class="col" style="left:{{left}}px;"></div>';
    	templatesHTML.ROWGRIDTEMPLATE = '<div class="row" style="top:{{top}}px;"></div>';
    
    	templatesHTML.COMMENTTEMPLAET = '<div></div>';
    
    	templatesHTML.SIDERBARTEMPLATE = '<div class="siderbar-title"><span>{{title}}</span>';
    	templatesHTML.SIDERBARTEMPLATE += '<a href="#" class="fui-cf-bg-extend2-ico ico-close close" title="关闭"></a></div>';
    	templatesHTML.SIDERBARTEMPLATE += '<div class="siderbar-body"></div></div>';
    
    	templatesHTML.LOCKCONTAINER = '<div class="siderbar-item clearfix"><div class="lock-content">';
    	templatesHTML.LOCKCONTAINER += '<div class="title"><span>锁定</span><div class="checkbox lock-toggle"></div></div>';
    	templatesHTML.LOCKCONTAINER += '<div class="content"><label>所选区域：</label><input type="text" disabled="disabled"></div>';
    	templatesHTML.LOCKCONTAINER += '<div class="oper"><a href="#" class="confirm">确定</a><a href="#" class="cancel">取消</a></div></div></div>';
    
    	templatesHTML.PROTECTCONTAINER = '<div class="siderbar-item clearfix"><div class="protect-content">';
    	templatesHTML.PROTECTCONTAINER += '<div class="content"><label>密码：</label><input type="password"></div>';
    	templatesHTML.PROTECTCONTAINER += '<div class="oper"><a href="#" class="confirm">确定</a><a href="#" class="cancel">取消</a></div></div></div>';
    
    	templatesHTML.VALIDATETEMPLATE = '<div class="siderbar-item clearfix"><div class="validate-title">验证条件:</div>';
    	templatesHTML.VALIDATETEMPLATE += '<form class="validate-content"><div><label>类型:</label><select name="type" class=""><option class="default" value="default">任意值</option>';
    	templatesHTML.VALIDATETEMPLATE += '<option value="intType" class="intType">整数</option><option value="decimalType" class="decimalType">小数</option><option value="textType" class="textType">文本长度</option>';
    
    	templatesHTML.VALIDATETEMPLATE += '<option value="sequenceType">序列</option>';
    	templatesHTML.VALIDATETEMPLATE += '</select></div>';
    	templatesHTML.VALIDATETEMPLATE += '<div class="range"><label>最小值:</label><input type="text" name="min" class="min"><br><label>最大值:</label><input type="text" name="max" class="max"></div>';
    	templatesHTML.VALIDATETEMPLATE += '<div class="source"><label>来源:</label><input type="text" class="source-data" maxlength="50" name="source"><div class="select-out"></div></div></form>';
    
    	templatesHTML.VALIDATETEMPLATE += '<div class="error">选中区域内包含多种验证规则</div>';
    	templatesHTML.VALIDATETEMPLATE += '<div class="oper"><a href="#" class="confirm">确定</a><a href="#" class="cancel">取消</a></div></div>';
    
    	templatesHTML.MSGCONTAINER = '<div class="msg"><span class="msg-content">{{msg}}</span></div>';
    
    	templatesHTML.SEQUENCETEMPLATE = '<div class="sequence-btn"><div class="sequence-btn-arrow"></div></div>';
    	templatesHTML.SEQUENCETEMPLATE += '<ul class="sequence-list"></ul>';
    
    	templatesHTML.SEQUENCEITEMTEMPLATE = '<li class="sequence-list-item"><a href="">{{content}}</a></li>';
    
    	function getTemplate(type) {
    		var tmpType;
    		if (tmpType = template[type]) {
    			return tmpType;
    		}
    		tmpType = template[type] = Handlebars.compile(templatesHTML[type]);
    		return tmpType;
    	}
    	return getTemplate;
    });
    define('views/sheetContainer',function() {
    	
    	var $ = require('lib/jquery'),
    		Backbone = require('lib/backbone'),
    		getTemplate = require('basic/tools/template');
    	
    	var sheetContainer = Backbone.View.extend({
    		tagName: 'li',
    
    		initialize: function(option) {
    			var modelJSON = this.model.toJSON();
    			this.listenTo(this.model, 'destroy', this.destroy);
    			this.template = getTemplate('SHEETTEMPLATE');
    			this.$el.html(this.template(modelJSON));
    			if(option.active ===true){
    				this.$el.addClass('active');
    			}
    		},
    		
    		render: function() {
    			return this;
    		},
    		destroy: function() {
    			this.remove();
    		}
    	});
    	return sheetContainer;
    });
    define('views/sheetsContainer',function() {
    	
    	var Backbone = require('lib/backbone'),
    		sheets = require('collections/sheets'),
    		SheetContainer = require('views/sheetContainer');
    	
    	var SheetsContainer = Backbone.View.extend({
    
    		tagName: 'ul',
    		
    		className: 'sheet-list',
    		
    		initialize: function(option) {
    			if (sheets.length < 1) {
    				sheets.add({
    					name: 'Sheet1',
    					sort: 0
    				});
    			}
    		},
    		render: function() {
    			var i, sheetView, active;
    			for (i = 0; i < sheets.length; i++) {
    				if (i === 0) {
    					active = true;
    				} else {
    					active = false;
    				}
    				sheetView = new SheetContainer({
    					model: sheets.models[i],
    					active: active
    				});
    				this.$el.append(sheetView.render().el);
    			}
    			return this;
    		},
    		destroy:function(){
    			this.remove();
    		}
    	});
    	return SheetsContainer;
    });
     
    define('basic/util/clone',function() {
        var BUILTIN_OBJECT = {
            '[object Function]': 1,
            '[object RegExp]': 1,
            '[object Date]': 1,
            '[object Error]': 1,
            '[object CanvasGradient]': 1
        };
    
        
        return {
            clone: function(source) {
                if (typeof source === 'object' && source !== null) {
                    var result = source;
                    if (source instanceof Array) {
                        result = [];
                        for (var i = 0, len = source.length; i < len; i++) {
                            result[i] = this.clone(source[i]);
                        }
                    } else if (!BUILTIN_OBJECT[Object.prototype.toString.call(source)]) {
                        result = {};
                        for (var key in source) {
                            if (source.hasOwnProperty(key)) {
                                result[key] = this.clone(source[key]);
                            }
                        }
                    }
    
                    return result;
                }
                return source;
            }
        };
    });
    define('views/gridLineRowContainer',function() {
    	
    	var $ = require('lib/jquery'),
    		_ = require('lib/underscore'),
    		Backbone = require('lib/backbone'),
    		headItemRows = require('collections/headItemRow'),
    		cache = require('basic/tools/cache'),
    		util = require('basic/util/clone'),
    		config = require('spreadsheet/config');
    	
    	var GridLineRowContainer = Backbone.View.extend({
    		
    		className: 'row',
    		
    		initialize: function(option) {
    			var modelList,
    				currentIndex;
    
    			this.offsetTop = cache.TempProp.isFrozen ? (option.frozenTop || 0) : 0;
    			this.endIndex = option.endIndex;
    			this.listenTo(this.model, 'change:top', this.changeTop);
    			this.listenTo(this.model, 'change:height', this.changeHeight);
    			this.listenTo(this.model, 'destroy', this.remove);
    			this.currentRule = util.clone(cache.CurrentRule);
    			modelList = headItemRows;
    
    			if (cache.TempProp.isFrozen !== true || this.endIndex === undefined) {
    				this.listenTo(this.model, 'change:isView', this.destroy);
    			}
    		},
    		
    		render: function() {
    			this.changeTop();
    			this.changeHeight();
    			return this;
    		},
    		
    		changeTop: function() {
    			var userViewTop = 0,
    				userViewModel;
    			if (cache.TempProp.isFrozen) {
    				userViewModel = headItemRows.getModelByAlias(cache.UserView.rowAlias);
    				userViewTop = userViewModel.toJSON().top;
    			}
    			this.$el.css({
    				top: this.model.toJSON().top - this.offsetTop - userViewTop
    			});
    		},
    		
    		changeHeight: function() {
    			this.$el.css({
    				height: this.model.toJSON().height
    			});
    		},
    		
    		destroy: function() {
    			this.remove();
    		}
    	});
    	return GridLineRowContainer;
    });
    define('views/rowsGridContainer',function() {
    	
    	var $ = require('lib/jquery'),
    		_ = require('lib/underscore'),
    		Backbone = require('lib/backbone'),
    		observerPattern = require('basic/util/observer.pattern'),
    		config = require('spreadsheet/config'),
    		cache = require('basic/tools/cache'),
    		headItemRows = require('collections/headItemRow'),
    		cells = require('collections/cells'),
    		GridLineRowContainer = require('views/gridLineRowContainer');
    
    	
    	var RowsGridContainer = Backbone.View.extend({
    		
    		className: 'row-container',
    		
    		initialize: function(option) {
    			// _.bindAll(this, 'callScreenContainer');
    			
    			this.rowNumber = 0;
    			this.currentRule = cache.CurrentRule;
    			if (this.currentRule.displayPosition.endRowIndex === undefined) {
    				this.listenTo(headItemRows, 'add', this.addGridLineRow);
    
    				//订阅滚动行视图还原
    				observerPattern.buildSubscriber(this);
    				this.subscribe('mainContainer', 'restoreRowView', 'restoreRowView');
    			}
    			Backbone.on('call:rowsGridContainer', this.rowsGridContainer, this);
    		},
    		rowsGridContainer: function(receiveFunc) {
    			receiveFunc(this);
    		},
    		
    		render: function() {
    			var i = 0,
    				gridLineRowList,
    				gridLineRowRegionList,
    				len;
    			gridLineRowList = gridLineRowRegionList = headItemRows.models;
    			if (cache.TempProp.isFrozen) {
    				if (this.currentRule.displayPosition.endRowIndex !== undefined) {
    					gridLineRowRegionList = gridLineRowList.slice(this.currentRule.displayPosition.startRowIndex, this.currentRule.displayPosition.endRowIndex);
    				} else {
    					gridLineRowRegionList = gridLineRowList.slice(this.currentRule.displayPosition.startRowIndex);
    				}
    			}
    			len = gridLineRowRegionList.length;
    			for (; i < len; i++) {
    				this.addGridLineRow(gridLineRowRegionList[i]);
    				this.rowNumber++;
    			}
    			return this;
    		},
    		restoreRowView: function(model, direction) {
    			this.addGridLineRow(model, direction);
    		},
    		
    		addGridLineRow: function(modelGridLineRow, direction) {
    			//处理冻结状态
    			var gridLineRow = new GridLineRowContainer({
    				model: modelGridLineRow,
    				frozenTop: this.currentRule.displayPosition.offsetTop,
    				endIndex: this.currentRule.displayPosition.endRowIndex
    			});
    			if (direction !== 'down') {
    				this.$el.append(gridLineRow.render().el);
    			} else {
    				this.$el.prepend(gridLineRow.render().el);
    			}
    		},
    
    		
    		newAttrRow: function() {
    			var currentObject = {
    				alias: (this.rowNumber + 1).toString(),
    				top: this.rowNumber * config.User.cellHeight,
    				height: config.User.cellHeight - 1,
    				displayName: app.basic.getRowDisplayName(this.rowNumber)
    			};
    			return currentObject;
    		},
    		
    		destroy: function() {
    			this.remove();
    		}
    	});
    	return RowsGridContainer;
    });
    
    define('views/gridLineColContainer',function() {
    	
    	var Backbone = require('lib/backbone');
    	var headItemCols = require('collections/headItemCol');
    	var cache = require('basic/tools/cache');
    	var config = require('spreadsheet/config');
    	var util = require('basic/util/clone');
    	
    	var GridLineColContainer = Backbone.View.extend({
    		
    		className: 'col',
    		
    		initialize: function() {
    			var modelList, currentIndex, currentModel;
    			this.offsetLeft = 0;
    			this.listenTo(this.model, 'change:isView', this.destroy);
    			this.listenTo(this.model, 'change:hidden', this.destroy);
    			this.listenTo(this.model, 'change:left', this.changeLeft);
    			this.listenTo(this.model, 'change:width', this.changeWidth);
    			this.listenTo(this.model, 'destroy', this.remove);
    			modelList = headItemCols;
    			currentModel = modelList.getModelByAlias(cache.TempProp.colAlias);
    			this.userViewLeft = cache.TempProp.isFrozen ? modelList.getModelByAlias(cache.UserView.colAlias).get('left') : 0;
    			this.offsetLeft = cache.TempProp.isFrozen && cache.CurrentRule.autoColAlign ? ((currentModel.get('left') - this.userViewLeft) || 0) : 0;
    		},
    		
    		render: function() {
    			this.changeLeft();
    			this.changeWidth();
    			return this;
    		},
    		changeLeft: function() {
    			this.$el.css({
    				left: this.model.toJSON().left - this.offsetLeft - this.userViewLeft
    			});
    		},
    		changeWidth: function() {
    			this.$el.css({
    				width: this.model.toJSON().width
    			});
    		},
    		destroy: function() {
    			if (!this.model.get('isView') || this.model.get('hidden')) {
    				this.remove();
    			}
    		}
    	});
    	return GridLineColContainer;
    });
    //attention bug , bettwen this.number has mixed and user configure file. isn't exist worth
    
    define('views/colsGridContainer',function() {
    	
    	var Backbone = require('lib/backbone'),
    		config = require('spreadsheet/config'),
    		binary = require('basic/util/binary'),
    		cache = require('basic/tools/cache'),
    		headItemCols = require('collections/headItemCol'),
    		getDisplayName = require('basic/tools/getdisplayname'),
    		GridLineColContainer = require('views/gridLineColContainer'),
    		ColsGridContainer;
    
    	
    	ColsGridContainer = Backbone.View.extend({
    		
    		className: 'col-container',
    		
    		initialize: function(option) {
    			
    			this.colNumber = 0;
    			this.listenTo(headItemCols, 'add', this.addGridLineCol);
    			Backbone.on('event:restoreHideCols', this.restoreHideCols, this);
    
    		},
    		
    		render: function() {
    			var i = 0,
    				gridLineColList,
    				gridLineColRegionList,
    				len;
    			gridLineColList = gridLineColRegionList = headItemCols.models;
    			if (cache.TempProp.isFrozen) {
    				this.currentRule = cache.CurrentRule;
    				if (this.currentRule.displayPosition.endColIndex !== undefined) {
    					gridLineColRegionList = headItemCols.models.slice(this.currentRule.displayPosition.startColIndex, this.currentRule.displayPosition.endColIndex);
    				} else {
    					gridLineColRegionList = headItemCols.models.slice(this.currentRule.displayPosition.startColIndex);
    				}
    			}
    			len = gridLineColRegionList.length;
    			for (; i < len; i++) {
    				if (!gridLineColRegionList[i].get('hidden')) {
    					this.addGridLineCol(gridLineColRegionList[i]);
    				}
    				this.colNumber++;
    			}
    			return this;
    		},
    		restoreHideCols: function() {
    			var headItemColList = headItemCols.models,
    				len = headItemColList.length,
    				i = 0;
    			for (; i < len; i++) {
    				if (headItemColList[i].get('hidden')) {
    					this.addGridLineCol(headItemColList[i]);
    				}
    			}
    		},
    		
    		addGridLineCol: function(modelGridLineCol) {
    			var gridLineCol = new GridLineColContainer({
    				model: modelGridLineCol,
    				frozenLeft: 0
    			});
    			this.$el.append(gridLineCol.render().el);
    		},
    		
    		createGridLineCol: function() {
    			headItemCols.add(this.newAttrCol());
    		},
    		
    		newAttrCol: function() {
    			var currentObject;
    			currentObject = {
    				alias: (this.colNumber + 1).toString(),
    				left: this.colNumber * config.User.cellWidth,
    				width: config.User.cellWidth - 1,
    				displayName: getDisplayName.getColDisplayName(this.colNumber)
    			};
    			return currentObject;
    		},
    		
    		destroy: function() {
    			Backbone.off('event:restoreHideCols');
    			this.remove();
    		}
    	});
    	return ColsGridContainer;
    });
    define('views/gridLineContainer',function() {
        
        var $ = require('lib/jquery'),
            _ = require('lib/underscore'),
            Backbone = require('lib/backbone'),
            RowsGridContainer = require('views/rowsGridContainer'),
            ColsGridContainer = require('views/colsGridContainer');
        
        var GridLineContainer = Backbone.View.extend({
            
            className: 'line-container',
            
            initialize: function() {
    
            },
            
            render: function() {
                this.rowsGridContainer = new RowsGridContainer();
                this.$el.append(this.rowsGridContainer.render().el);
    
                this.colsGridContainer = new ColsGridContainer();
                this.$el.append(this.colsGridContainer.render().el);
                return this;
            },
            
            destroy: function() {
                this.rowsGridContainer.destroy();
                this.colsGridContainer.destroy();
                this.remove();
            }
        });
        return GridLineContainer;
    });
    
    define('basic/tools/gettextbox',function() {
    	var $ = require('lib/jquery');
    	return {
    		getTextHeight: function(text, fontSize, width) {
    			var tempDiv,
    				height,
    				inputText = '',
    				texts,
    				i = 0,
    				len;
    			texts = text.split('\n');
    			len = texts.length;
    			for (; i < len; i++) {
    				inputText += (texts[i] + '<br>');
    			}
    			// textarea.scrollHeight;
    			inputText = inputText.replace(/\u0020/g, '&nbsp;');
    			tempDiv = $('<div/>').html(inputText);
    			tempDiv.css({
    				'display': 'none',
    				'font-size': fontSize + 'pt',
    				'wordBreak': 'break-word',
    			});
    			if (width !== undefined) {
    				tempDiv.css({
    					'width': width
    				});
    			}
    			$('body').append(tempDiv);
    			height = parseInt(tempDiv.height());
    			tempDiv.remove();
    			return height;
    		},
    		getInputHeight: function(text, fontSize, width) {
    			var tempTextarea,
    				height;
    			tempTextarea = $('<textarea>');
    			tempTextarea.css({
    				'visibility': 'hidden',
    				'font-size': fontSize + 'pt',
    				'height': 0,
    				'width': width + 'px',
    				'overflow': 'scroll',
    			});
    			$('body').append(tempTextarea);
    			tempTextarea.val(text);
    			height = parseInt(tempTextarea[0].scrollHeight);
    			tempTextarea.remove();
    			return height;
    		},
    		getInputWidth: function(text, fontSize) {
    			var tempTextarea,
    				width;
    			tempTextarea = $('<textarea>');
    			tempTextarea.css({
    				'position': 'absolute',
    				'visibility': 'hidden',
    				'font-size': fontSize + 'pt',
    				'height': 0,
    				'width': 0,
    				'overflow': 'scroll',
    			});
    			tempTextarea.attr('wrap','off');
    			$('body').append(tempTextarea);
    			tempTextarea.val(text);
    			width = parseInt(tempTextarea[0].scrollWidth);
    			tempTextarea.remove();
    			return width;
    		}
    	};
    });
    define('views/cellContainer',function() {
    	
    	var $ = require('lib/jquery'),
    		_ = require('lib/underscore'),
    		Backbone = require('lib/backbone'),
    		getTemplate = require('basic/tools/template'),
    		binary = require('basic/util/binary'),
    		headItemRows = require('collections/headItemRow'),
    		headItemCols = require('collections/headItemCol'),
    		selectRegions = require('collections/selectRegion'),
    		cache = require('basic/tools/cache'),
    		config = require('spreadsheet/config'),
    		getTextBox = require('basic/tools/gettextbox'),
    		setCellHeight = require('entrance/cell/setcellheight'),
    		formatHandler = require('entrance/tool/settexttype'),
    		headItemColList = headItemCols.models,
    		CellContainer;
    
    	
    	CellContainer = Backbone.View.extend({
    		
    		className: 'item',
    		
    		initialize: function(options) {
    			var modelRowList = headItemRows,
    				modelColList = headItemCols;
    
    			this.listenTo(this.model, 'change:physicsBox.width', this.changeWidth);
    			this.listenTo(this.model, 'change:physicsBox.height', this.changeHeight);
    			this.listenTo(this.model, 'change:physicsBox.left', this.changeLeft);
    			this.listenTo(this.model, 'change:physicsBox.top', this.changeTop);
    
    			this.listenTo(this.model, 'change:content.size', this.changeFontSize);
    			this.listenTo(this.model, 'change:content.family', this.changeFontFamily);
    			this.listenTo(this.model, 'change:content.italic', this.changeItalic);
    			this.listenTo(this.model, 'change:content.bd', this.changeBold);
    			this.listenTo(this.model, 'change:content.underline', this.changeUnderline);
    			this.listenTo(this.model, 'change:content.color', this.changeColor);
    			this.listenTo(this.model, 'change:content.alignRow', this.changeTransverseAlign);
    			this.listenTo(this.model, 'change:content.alignCol', this.changeVerticalAlign);
    			this.listenTo(this.model, 'change:content.texts', this.generateDisplayText);
    
    			this.listenTo(this.model, 'change:border.left', this.changeLeftBorder);
    			this.listenTo(this.model, 'change:border.right', this.changeRightBorder);
    			this.listenTo(this.model, 'change:border.top', this.changeTopBorder);
    			this.listenTo(this.model, 'change:border.bottom', this.changeBottomBorder);
    
    			this.listenTo(this.model, 'change:customProp.background', this.changeBackground);
    
    			this.listenTo(this.model, 'change:customProp.comment', this.showCommentSign);
    			//初始化不走该方法，直接将显示文本贴到html中
    			this.listenTo(this.model, 'change:format', this.generateDisplayText);
    
    			this.listenTo(this.model, 'change:wordWrap', this.changeWordWrap);
    
    			this.currentRule = options.currentRule;
    
    			if (cache.TempProp.isFrozen !== true ||
    				this.currentRule.displayPosition.endRowIndex === undefined) {
    				this.listenTo(this.model, 'change:showState', this.destroy);
    			}
    			//待修改：需要验证现删除DOM，视图对象是否得到了释放
    			this.listenTo(this.model, 'change:isDestroy', this.destroy);
    			this.listenTo(this.model, 'change:hidden', this.destroy);
    			this.listenTo(this.model, 'destroy', this.remove);
    
    			this.offsetLeft = cache.TempProp.isFrozen ? (this.currentRule.displayPosition.offsetLeft || 0) : 0;
    			this.offsetTop = cache.TempProp.isFrozen ? (this.currentRule.displayPosition.offsetTop || 0) : 0;
    
    			this.userViewLeft = cache.TempProp.isFrozen ? modelColList.getModelByAlias(cache.UserView.colAlias).get('left') : 0;
    			this.userViewTop = cache.TempProp.isFrozen ? modelRowList.getModelByAlias(cache.UserView.rowAlias).get('top') : 0;
    		},
    		
    		render: function() {
    			var modelAttr = this.model.attributes;
    			this.template = getTemplate('CELLTEMPLATE');
    
    			this.$el.html(this.template());
    
    			this.$contentBody = $('.bg', this.$el);
    			this.$contentBody[0].innerText = modelAttr.content.displayTexts;
    
    			this.changeFontFamily(modelAttr);
    			this.changeFontSize(modelAttr);
    			this.changeColor(modelAttr);
    
    			this.changeWidth(modelAttr);
    			this.changeHeight(modelAttr);
    			this.changeLeft(modelAttr);
    			this.changeTop(modelAttr);
    
    			this.changeItalic(modelAttr);
    			this.changeBold(modelAttr);
    			this.changeTransverseAlign(modelAttr);
    			this.changeVerticalAlign(modelAttr);
    
    			this.changeTopBorder(modelAttr);
    			this.changeLeftBorder(modelAttr);
    			this.changeBottomBorder(modelAttr);
    			this.changeRightBorder(modelAttr);
    			this.changeUnderline(modelAttr);
    
    			this.changeBackground(modelAttr);
    			this.changeWordWrap(modelAttr);
    			this.showCommentSign(modelAttr);
    			return this;
    		},
    		changeWidth: function(modelAttr) {
    			if (modelAttr.attributes) {
    				modelAttr = this.model.attributes;
    			}
    			this.$el.css({
    				width: modelAttr.physicsBox.width
    			});
    		},
    		changeHeight: function(modelAttr) {
    			if (modelAttr.attributes) {
    				modelAttr = this.model.attributes;
    			}
    			this.$el.css({
    				height: modelAttr.physicsBox.height
    			});
    		},
    		changeLeft: function(modelAttr) {
    			if (modelAttr.attributes) {
    				modelAttr = this.model.attributes;
    			}
    			this.$el.css({
    				left: modelAttr.physicsBox.left - this.offsetLeft - this.userViewLeft - 1
    			});
    		},
    		changeTop: function(modelAttr) {
    			if (modelAttr.attributes) {
    				modelAttr = this.model.attributes;
    			}
    			this.$el.css({
    				top: modelAttr.physicsBox.top - this.offsetTop - this.userViewTop - 1
    			});
    		},
    		changeBold: function(modelAttr) {
    			if (modelAttr.attributes) {
    				modelAttr = this.model.attributes;
    			}
    			if (modelAttr.content.bd) {
    				this.$contentBody.css({
    					'fontWeight': 'bold'
    				});
    			} else {
    				this.$contentBody.css({
    					'fontWeight': 'normal'
    				});
    			}
    		},
    		changeUnderline: function(modelAttr) {
    			if (modelAttr.attributes) {
    				modelAttr = this.model.attributes;
    			}
    			if (modelAttr.content.underline) {
    				this.$contentBody.css({
    					'textDecoration': 'underline'
    				});
    			} else {
    				this.$contentBody.css({
    					'textDecoration': 'none'
    				});
    			}
    		},
    		
    		changeItalic: function(modelAttr) {
    			if (modelAttr.attributes) {
    				modelAttr = this.model.attributes;
    			}
    			if (modelAttr.content.italic) {
    				this.$contentBody.css({
    					'fontStyle': 'italic'
    				});
    			} else {
    				this.$contentBody.css({
    					'fontStyle': 'normal'
    				});
    			}
    		},
    		changeTransverseAlign: function(modelAttr) {
    			if (modelAttr.attributes) {
    				modelAttr = this.model.attributes;
    			}
    			var format = modelAttr.format,
    				isValid = format.isValid,
    				type = format.type,
    				text = modelAttr.content.texts,
    				alignRow = modelAttr.content.alignRow;
    			if (alignRow) {
    				this.$contentBody.css({
    					'textAlign': alignRow
    				});
    				return;
    			}
    			if (type !== 'text' && type !== 'normal' && isValid === true) {
    				this.$contentBody.css({
    					'textAlign': 'right'
    				});
    				return;
    			}
    			if (type === 'normal' && formatHandler.isNum(text)) {
    				this.$contentBody.css({
    					'textAlign': 'right'
    				});
    				return;
    			}
    			this.$contentBody.css({
    				'textAlign': 'left'
    			});
    		},
    		
    		changeVerticalAlign: function(modelAttr) {
    			if (modelAttr.attributes) {
    				modelAttr = this.model.attributes;
    			}
    			this.$contentBody.css({
    				'verticalAlign': this.model.attributes.content.alignCol
    			});
    		},
    		
    		changeTopBorder: function(modelAttr) {
    			if (modelAttr.attributes) {
    				modelAttr = this.model.attributes;
    			}
    			if (modelAttr.border.top) {
    				this.$el.css({
    					'borderTopColor': '#000'
    				});
    			} else {
    				this.$el.css({
    					'borderTopColor': 'transparent'
    				});
    			}
    		},
    		
    		changeBottomBorder: function(modelAttr) {
    			if (modelAttr.attributes) {
    				modelAttr = this.model.attributes;
    			}
    			if (modelAttr.border.bottom) {
    				this.$el.css({
    					'borderBottomColor': '#000'
    				});
    			} else {
    				this.$el.css({
    					'borderBottomColor': 'transparent'
    				});
    			}
    		},
    		
    		changeLeftBorder: function(modelAttr) {
    			var headItemModel;
    
    			if (modelAttr.attributes) {
    				modelAttr = this.model.attributes;
    			}
    			if (!modelAttr.border.left) {
    				this.$el.css({
    					'borderLeftColor': 'transparent'
    				});
    			} else {
    				headItemModel = headItemCols.getModelByAlias(modelAttr.occupy.x[0]);
    				if (headItemModel.attributes.isLeftAjacentHide) {
    					this.$el.css({
    						'borderLeftColor': 'transparent'
    					});
    				} else {
    					this.$el.css({
    						'borderLeftColor': '#000'
    					});
    				}
    			}
    		},
    		
    		changeRightBorder: function(modelAttr) {
    			var headItemModel,
    				occupyX;
    
    			if (modelAttr.attributes) {
    				modelAttr = this.model.attributes;
    			}
    			occupyX = modelAttr.occupy.x;
    			if (!modelAttr.border.right) {
    				this.$el.css({
    					'borderRightColor': 'transparent'
    				});
    			} else {
    				headItemModel = headItemCols.getModelByAlias(occupyX[occupyX.length - 1]);
    				if (headItemModel.attributes.isRightAjacentHide) {
    					this.$el.css({
    						'borderRightColor': 'transparent'
    					});
    				} else {
    					this.$el.css({
    						'borderRightColor': '#000'
    					});
    				}
    			}
    		},
    		
    		changeBackground: function(modelAttr) {
    			if (modelAttr.attributes) {
    				modelAttr = this.model.attributes;
    			}
    			if (modelAttr.customProp.background !== '') {
    				this.$contentBody.css({
    					'backgroundColor': modelAttr.customProp.background
    				});
    			} else {
    				this.$contentBody.css({
    					'backgroundColor': '#fff'
    				});
    			}
    		},
    		changeWordWrap: function(modelAttr) {
    			if (modelAttr.attributes) {
    				modelAttr = this.model.attributes;
    			}
    			if (modelAttr.wordWrap === true) {
    				this.$contentBody.css({
    					'wordBreak': 'break-word',
    					'whiteSpace': 'pre-line'
    				});
    			} else {
    				this.$contentBody.css({
    					'whiteSpace': 'pre'
    				});
    			}
    		},
    		
    		showCommentSign: function(modelAttr) {
    			if (modelAttr.attributes) {
    				modelAttr = this.model.attributes;
    			}
    			if (modelAttr.customProp.comment !== null &&
    				modelAttr.customProp.comment !== undefined) {
    				this.$el.prepend('<div class="comment-ico"><div class="triangle"></div></div>');
    			} else {
    				var commentSign = this.$el.find('.comment-ico');
    				commentSign.remove();
    			}
    		},
    		generateDisplayText: function() {
    			formatHandler.typeRecognize(this.model);
    			formatHandler.generateDisplayText(this.model);
    
    			var modelAttr = this.model.attributes;
    			this.changeTransverseAlign(modelAttr);
    			this.$contentBody[0].innerText = modelAttr.content.displayTexts;
    
    		},
    		changeFontFamily: function() {
    			this.$contentBody.css({
    				'fontFamily': this.model.attributes.content.family,
    			});
    		},
    		changeFontSize: function() {
    			this.$contentBody.css({
    				'fontSize': this.model.attributes.content.size + 'pt',
    			});
    		},
    		changeColor: function() {
    			this.$contentBody.css({
    				'color': this.model.attributes.content.color,
    			});
    		},
    		adaptCellHight: function() {
    			var text,
    				height,
    				occupyY,
    				occupyX,
    				initHeight,
    				colItemIndex,
    				rowItemIndex,
    				headModelRow,
    				headModelCol,
    				fontsize;
    			initHeight = config.User.cellHeight;
    			occupyY = this.model.get('occupy').y;
    			occupyX = this.model.get('occupy').x;
    			fontsize = this.model.get('content').size;
    			if (this.model.get('wordWrap') === true && occupyX.length === 1 && occupyY.length === 1) {
    				headModelRow = headItemRows.getModelByAlias(occupyY[0]);
    				headModelCol = headItemCols.getModelByAlias(occupyX[0]);
    				text = this.model.get('content').displayTexts;
    				height = getTextBox.getTextHeight(text, fontsize, headModelCol.get('width'));
    				if (height > initHeight && headModelRow.get('height') < height) {
    					setCellHeight('sheetId', headModelRow.get('displayName'), height);
    					if (cache.TempProp.isFrozen) {
    						Backbone.trigger('event:bodyContainer:executiveFrozen');
    					};
    				}
    				return;
    			}
    			if (fontsize > 11) {
    				//处理设置字体问题
    				headModelRow = headItemRows.getModelByAlias(occupyY[0]);
    				height = getTextBox.getTextHeight('', fontsize, 200);
    				if (height > initHeight && headModelRow.get('height') < height) {
    					setCellHeight('sheetId', headModelRow.get('displayName'), height);
    					if (cache.TempProp.isFrozen) {
    						Backbone.trigger('event:bodyContainer:executiveFrozen');
    					};
    				}
    			}
    		},
    		
    		destroy: function() {
    			var attr = this.model.attributes;
    			if (attr.hidden || !attr.showState || attr.isDestroy) {
    				this.remove();
    			}
    		},
    	});
    	return CellContainer;
    });
    define('views/contentCellsContainer',function() {
    	
    	var Backbone = require('lib/backbone'),
    		cache = require('basic/tools/cache'),
    		config = require('spreadsheet/config'),
    		util = require('basic/util/clone'),
    		send = require('basic/tools/send'),
    		observerPattern = require('basic/util/observer.pattern'),
    		loadRecorder = require('basic/tools/loadrecorder'),
    		original = require('basic/tools/original'),
    		headItemCols = require('collections/headItemCol'),
    		headItemRows = require('collections/headItemRow'),
    		cells = require('collections/cells'),
    		CellContainer = require('views/cellContainer'),
    		headItemRowList = headItemRows.models,
    		headItemColList = headItemCols.models,
    		ContentCellsContainer;
    
    
    	
    	ContentCellsContainer = Backbone.View.extend({
    		
    		className: 'content-list',
    		
    		initialize: function() {
    			this.currentRule = util.clone(cache.CurrentRule);
    			// 取消列隐藏时使用
    			Backbone.on('event:restoreHideCellView', this.restoreHideCellView, this);
    			// 重新拉取所有单元格数据
    			Backbone.on('event:contentCellsContainer:reloadCells', this.reloadCells, this);
    			// 撤销操作重新还原单元格视图
    			Backbone.on('event:contentCellsContainer:restoreCell', this.addCell, this);
    			Backbone.on('event:contentCellsContainer:destroy');
    			this.listenTo(cells, 'add', this.addCell);
    
    			if (this.currentRule.displayPosition.endIndex === undefined) {
    				//订阅滚动行视图还原
    				observerPattern.buildSubscriber(this);
    				this.subscribe('mainContainer', 'restoreCellView', 'restoreCellView');
    			}
    		},
    		
    		render: function() {
    			this.fillCells();
    			return this;
    		},
    		
    		fillCells: function() {
    			var len, i, cellsList = cells.models;
    			len = cellsList.length;
    			for (i = 0; i < len; i++) {
    				if (!cellsList[i].get('isDestroy')) {
    					this.addCell(cellsList[i]);
    				}
    			}
    		},
    		
    		reloadCells: function() {
    			var i = 0,
    				len = cells.length,
    				cellModel,
    				top,
    				bottom;
    
    			for (; i < len; i++) {
    				cellModel = cells.models[0].destroy();
    			}
    			cache.CellsPosition.strandX = {};
    			cache.CellsPosition.strandY = {};
    			cache.cellRegionPosi.vertical = [];
    			cells.reset();
    			top = cache.viewRegion.top;
    			bottom = cache.viewRegion.bottom;
    			this.getCells(top, bottom);
    		},
    		restoreHideCellView: function() {
    			var headItemColList = headItemCols.models,
    				headItemRowList = headItemRows.models,
    				len = headItemColList.length,
    				headItemModel,
    				startRowIndex,
    				endRowIndex,
    				colAlias,
    				rowAlias,
    				strandX,
    				tempCell,
    				rowLen,
    				i = 0,
    				j;
    
    			startRowIndex = headItemRows.getIndexByPosi(cache.viewRegion.top);
    			endRowIndex = headItemRows.getIndexByPosi(cache.viewRegion.bottom);
    			strandX = cache.CellsPosition.strandX;
    			if (endRowIndex > startRowIndex) {
    				rowLen = endRowIndex + 1;
    			} else {
    				rowLen = headItemRows.length;
    			}
    			for (; i < len; i++) {
    				headItemModel = headItemColList[i];
    				if (headItemModel.get('hidden') === true) {
    					colAlias = headItemModel.get('alias');
    					for (j = startRowIndex; j < rowLen; j++) {
    						rowAlias = headItemRowList[j].get('alias');
    						if (strandX[colAlias] !== undefined && strandX[colAlias][rowAlias] !== undefined) {
    							tempCell = cells.models[strandX[colAlias][rowAlias]];
    							if (tempCell.get('hidden') === true) {
    								this.addCell(tempCell);
    							}
    						}
    					}
    				}
    			}
    		},
    		getCells: function(top, bottom) {
    			send.PackAjax({
    				url: config.url.sheet.load,
    				isPublic: false,
    				async: false,
    				data: JSON.stringify({
    					sheetId: '1',
    					top: top,
    					bottom: bottom
    				}),
    				success: function(data) {
    					if (data === '') {
    						return;
    					}
    					data = data.returndata;
    					var cellJSON = data.spreadSheet[0].sheet.cells;
    					original.analysisCellData(cellJSON);
    					loadRecorder.insertPosi(top, bottom, cache.cellRegionPosi.vertical);
    				}
    			});
    		},
    		restoreCellView: function(model) {
    			this.addCell(model);
    		},
    		
    		addCell: function(cell) {
    			if (cache.TempProp.isFrozen) {
    				var displayPosition = this.currentRule.displayPosition,
    					startRowIndex = displayPosition.startRowIndex,
    					startColIndex = displayPosition.startColIndex,
    					endRowIndex = displayPosition.endRowIndex,
    					endColIndex = displayPosition.endColIndex,
    					cellBox = cell.get('physicsBox'),
    					top, left, bottom, right;
    
    				top = cellBox.top;
    				bottom = top + cellBox.height;
    				left = cellBox.left;
    				right = left + cellBox.width;
    
    				//判断单元格是否不再当前区域内
    				if (bottom < headItemRowList[startRowIndex].get('top') ||
    					right < headItemColList[startColIndex].get('left')) {
    					return;
    				}
    
    				if (typeof endRowIndex === 'number') {
    					endRowIndex = endRowIndex - 1;
    					if (endRowIndex < 0 || top > headItemRowList[endRowIndex].get('top')) {
    						return;
    					}
    				}
    				if (typeof endColIndex === 'number') {
    					endColIndex = endColIndex - 1;
    					if (endColIndex < 0 || left > headItemColList[endColIndex].get('left')) {
    						return;
    					}
    				}
    			}
    
    			this.cellView = new CellContainer({
    				model: cell,
    				currentRule: this.currentRule
    			});
    			this.$el.append(this.cellView.render().el);
    		},
    		
    		destroy: function() {
    			Backbone.tigger('event:cellConainer:destroy');
    			Backbone.off('event:contentCellsContainer:reloadCells');
    			Backbone.off('event:contentCellsContainer:restoreCell');
    			Backbone.off('event:restoreHideCellView');
    			Backbone.off('event:contentCellsContainer:destroy');
    			this.remove();
    		}
    	});
    	return ContentCellsContainer;
    });
    define('views/selectRegion',function() {
    	
    	var $ = require('lib/jquery'),
    		Backbone = require('lib/backbone'),
    		getTemplate = require('basic/tools/template'),
    		util = require('basic/util/clone'),
    		binary = require('basic/util/binary'),
    		cache = require('basic/tools/cache'),
    		config = require('spreadsheet/config'),
    		send = require('basic/tools/send'),
    		Cell = require('models/cell'),
    		listener = require('basic/util/listener'),
    		headItemRows = require('collections/headItemRow'),
    		headItemCols = require('collections/headItemCol'),
    		siderLineRows = require('collections/siderLineRow'),
    		siderLineCols = require('collections/siderLineCol'),
    		cells = require('collections/cells'),
    		protect = require('entrance/tool/protect'),
    		rowModelList = headItemRows.models,
    		colModelList = headItemCols.models,
    		SelectRegion;
    
    	
    
    	SelectRegion = Backbone.View.extend({
    		
    		className: 'selected-container',
    		
    		events: {
    			'dblclick': 'editState',
    		},
    		
    		initialize: function(options) {
    			this.viewCellsContainer = options.parentView;
    			if (this.model.get('selectType') === 'selected') {
    				Backbone.on('event:selectRegion:patchOprCell', this.patchOprCell, this);
    			}
    			Backbone.on('event:selectRegionContainer:adapt', this.adapt, this);
    			//添加视图
    			this.listenTo(this.model, 'change:tempPosi', this.changePosi);
    			this.listenTo(this.model, 'change:physicsBox', this.changeBox);
    			this.listenTo(this.model, 'destroy', this.destroy);
    
    			if (options.currentRule !== undefined) {
    				this.currentRule = options.currentRule;
    			} else {
    				this.currentRule = util.clone(cache.CurrentRule);
    			}
    
    			this.userViewTop = cache.TempProp.isFrozen ? headItemRows.getModelByAlias(cache.UserView.rowAlias).get('top') : 0;
    			this.userViewLeft = cache.TempProp.isFrozen ? headItemCols.getModelByAlias(cache.UserView.colAlias).get('left') : 0;
    			this.offsetLeft = cache.TempProp.isFrozen ? (this.currentRule.displayPosition.offsetLeft || 0) : 0;
    			this.offsetTop = cache.TempProp.isFrozen ? (this.currentRule.displayPosition.offsetTop || 0) : 0;
    		},
    		
    		render: function() {
    			this.template = getTemplate('SELECTTEMPLATE');
    			this.$el.html(this.template());
    			this.changeBox();
    			return this;
    		},
    		
    		changeBox: function() {
    			var modelJSON = this.model.toJSON(),
    				height = modelJSON.physicsBox.height,
    				width = modelJSON.physicsBox.width,
    				left = modelJSON.physicsBox.left,
    				top = modelJSON.physicsBox.top,
    				state = modelJSON.showState;
    
    			if (left === 0) {
    				left = left - 1;
    				width = width - 1;
    			} else {
    				width = width - 2;
    			}
    			if (top === 0) {
    				top = top - 1;
    				height = height - 1;
    			} else {
    				height = height - 2;
    			}
    
    			this.$el.css({
    				width: width,
    				height: height,
    				left: left - this.offsetLeft - this.userViewLeft,
    				top: top - this.offsetTop - this.userViewTop
    			});
    		},
    		callView: function(name) {
    			var object = this;
    			return function(callback) {
    				object[name] = callback;
    			};
    		},
    		
    		changePosi: function() {
    			var modelJSON = this.model.toJSON(),
    				colDisplayNames = [],
    				rowDisplayNames = [],
    				startColIndex,
    				startRowIndex,
    				endColIndex,
    				endRowIndex,
    				region,
    				width,
    				height,
    				temp,
    				e = {},
    				i;
    
    
    			region = cells.getFullOperationRegion(
    				modelJSON.tempPosi.initColIndex,
    				modelJSON.tempPosi.initRowIndex,
    				modelJSON.tempPosi.mouseColIndex,
    				modelJSON.tempPosi.mouseRowIndex
    			);
    			startColIndex = region.startColIndex;
    			startRowIndex = region.startRowIndex;
    			endColIndex = region.endColIndex;
    			endRowIndex = region.endRowIndex;
    
    			width = colModelList[endColIndex].get('width') + colModelList[endColIndex].get('left') - colModelList[startColIndex].get('left');
    			height = rowModelList[endRowIndex].get('height') + rowModelList[endRowIndex].get('top') - rowModelList[startRowIndex].get('top');
    
    			if (this.model.get('selectType') === 'selected') {
    				this.changeHeadLineModel(startColIndex, startRowIndex, endColIndex, endRowIndex);
    				siderLineRows.models[0].set({
    					top: rowModelList[startRowIndex].get('top'),
    					height: height
    				});
    				siderLineCols.models[0].set({
    					left: colModelList[startColIndex].get('left'),
    					width: width
    				});
    			}
    			this.model.set('physicsBox', {
    				top: rowModelList[startRowIndex].get('top'),
    				left: colModelList[startColIndex].get('left'),
    				width: width,
    				height: height
    			});
    			temp = {
    				startX: colModelList[startColIndex].get('alias'),
    				startY: rowModelList[startRowIndex].get('alias'),
    				endX: colModelList[endColIndex].get('alias'),
    				endY: rowModelList[endRowIndex].get('alias')
    			}
    
    			//判断是否为整行或整列操作
    			if (modelJSON.tempPosi.mouseColIndex === 'MAX' || modelJSON.tempPosi.initColIndex === 'MAX') {
    				temp.endX = 'MAX';
    				colDisplayNames.push('1');
    				colDisplayNames.push('MAX');
    				rowDisplayNames.push(rowModelList[startRowIndex].get('displayName'));
    				rowDisplayNames.push(rowModelList[endRowIndex].get('displayName'));
    			} else if (modelJSON.tempPosi.mouseRowIndex === 'MAX' || modelJSON.tempPosi.initRowIndex === 'MAX') {
    				temp.endY = 'MAX';
    				rowDisplayNames.push('1');
    				rowDisplayNames.push('MAX');
    				colDisplayNames.push(colModelList[startColIndex].get('displayName'));
    				colDisplayNames.push(colModelList[endColIndex].get('displayName'));
    			} else {
    				for (i = startColIndex; i < endColIndex + 1; i++) {
    					colDisplayNames.push(colModelList[i].get('displayName'));
    				}
    				for (i = startRowIndex; i < endRowIndex + 1; i++) {
    					rowDisplayNames.push(rowModelList[i].get('displayName'));
    				}
    			}
    			this.model.set('wholePosi', temp);
    
    			e.point = {
    				col: colDisplayNames,
    				row: rowDisplayNames
    			};
    			listener.excute('regionChange', e);
    			if (modelJSON.selectType === 'selected') {
    				listener.excute('selectRegionChange', e);
    			} else {
    				listener.excute('dataSourceRegionChange', e);
    			}
    		},
    		changeHeadLineModel: function(currentStartCol, currentStartRow, currentEndCol, currentEndRow) {
    			var modelJSON = this.model.toJSON(),
    				originalStartRow,
    				originalStartCol,
    				originalEndRow,
    				originalEndCol, i;
    
    			originalStartRow = headItemRows.getIndexByAlias(modelJSON.wholePosi.startY);
    			originalStartCol = headItemCols.getIndexByAlias(modelJSON.wholePosi.startX);
    			originalEndRow = headItemRows.getIndexByAlias(modelJSON.wholePosi.endY);
    			originalEndCol = headItemCols.getIndexByAlias(modelJSON.wholePosi.endX);
    
    			originalEndRow = originalEndRow !== 'MAX' ? originalEndRow : headItemRows.length - 1;
    			originalEndCol = originalEndCol !== 'MAX' ? originalEndCol : headItemCols.length - 1;
    			for (i = originalStartRow; i <= originalEndRow; i++) {
    				rowModelList[i].set({
    					activeState: false
    				});
    			}
    
    			for (i = originalStartCol; i <= originalEndCol; i++) {
    				colModelList[i].set({
    					activeState: false
    				});
    			}
    			for (i = currentStartRow; i <= currentEndRow; i++) {
    				rowModelList[i].set({
    					activeState: true
    				});
    			}
    			for (i = currentStartCol; i <= currentEndCol; i++) {
    				colModelList[i].set({
    					activeState: true
    				});
    			}
    		},
    		
    		patchOprCell: function(cycleCallback, appointList) {
    			var currentCell,
    				currentCellList,
    				partModelList,
    				i = 0,
    				len,
    				partModel,
    				modelCellList;
    			appointList = appointList === undefined || appointList === null ? {
    				cellModel: undefined,
    				headModel: undefined
    			} : appointList;
    			getLastStatus();
    			cycleCallback = cycleCallback === undefined || cycleCallback === null ? function() {} : cycleCallback;
    			partModelList = appointList.headModel === undefined ? cells.getHeadModelByWholeSelectRegion() : appointList.headModel;
    
    			len = currentCellList.length;
    			var start = new Date();
    			for (; i < len; i++) {
    				currentCell = getLastStatus()[i];
    				partModel = partModelList[i];
    				if (currentCell === null) {
    					cells.add({
    						'occupy': {
    							'x': [partModel.occupy.x],
    							'y': [partModel.occupy.y]
    						},
    						'physicsBox': {
    							'top': partModel.physicsBox.top,
    							'left': partModel.physicsBox.left,
    							'width': partModel.physicsBox.width,
    							'height': partModel.physicsBox.height
    						}
    					});
    					cache.cachePosition(partModel.occupy.y, partModel.occupy.x, cells.length - 1);
    					modelCellList = cells.models;
    					currentCell = modelCellList[modelCellList.length - 1];
    				}
    				cycleCallback(currentCell);
    			}
    
    			function getLastStatus() {
    				currentCellList = appointList.cellModel === undefined ? cells.getCellsByWholeSelectRegion() : appointList.cellModel;
    				return currentCellList;
    			}
    		},
    		
    		editState: function() {
    			var modelJSON = this.model.toJSON(),
    				startRowIndex,
    				startColIndex,
    				endRowIndex,
    				endColIndex,
    				isAble;
    
    			if (cache.mouseOperateState !== config.mouseOperateState.select) {
    				return;
    			}
    
    			startRowIndex = headItemRows.getIndexByAlias(modelJSON.wholePosi.startY);
    			startColIndex = headItemCols.getIndexByAlias(modelJSON.wholePosi.startX);
    			endRowIndex = headItemRows.getIndexByAlias(modelJSON.wholePosi.endY);
    			endColIndex = headItemCols.getIndexByAlias(modelJSON.wholePosi.endX);
    			isAble = protect.interceptor({
    				startRowIndex: startRowIndex,
    				startColIndex: startColIndex,
    				endColIndex: endColIndex,
    				endRowIndex: endRowIndex
    			});
    			if (isAble) {
    				return;
    			}
    			Backbone.trigger('event:InputContainer:show', true);
    		},
    		
    		destroy: function() {
    			if (this.model.get('selectType') === 'selected') {
    				Backbone.off('event:selectRegion:patchOprCell');
    			}
    			Backbone.off('event:selectRegionContainer:adapt');
    			this.remove();
    		}
    	});
    	return SelectRegion;
    });
    define('views/cellsContainer',function() {
    	
    	var $ = require('lib/jquery'),
    		_ = require('lib/underscore'),
    		Backbone = require('lib/backbone'),
    		binary = require('basic/util/binary'),
    		cache = require('basic/tools/cache'),
    		config = require('spreadsheet/config'),
    		util = require('basic/util/clone'),
    		Cell = require('models/cell'),
    		listener = require('basic/util/listener'),
    		SelectRegionModel = require('models/selectRegion'),
    		headItemCols = require('collections/headItemCol'),
    		headItemRows = require('collections/headItemRow'),
    		selectRegions = require('collections/selectRegion'),
    		cells = require('collections/cells'),
    		GridLineContainer = require('views/gridLineContainer'),
    		ContentCellsContainer = require('views/contentCellsContainer'),
    		SelectRegionView = require('views/selectRegion'),
    		headItemColList = headItemCols.models,
    		headItemRowList = headItemRows.models;
    
    
    	
    	var CellsContainer = Backbone.View.extend({
    		
    		className: 'cells-container',
    
    		
    		events: {
    			'mousedown': 'mouseDownHandle',
    			'mousemove': 'mouseMoveHandle',
    			'mouseout': 'outHandle'
    		},
    		locatedState: null,
    		moveState: null,
    		
    		initialize: function(options) {
    
    			Backbone.on('event:cellsContainer:adaptWidth', this.adaptWidth, this);
    			Backbone.on('event:cellsContainer:adaptHeight', this.adaptHeight, this);
    
    			//鼠标拖动事件绑定与解绑（解决冻结拆分情况下拖动绑定问题）
    			Backbone.on('event:cellsContainer:unBindDrag', this.unBindDragSelect, this);
    			Backbone.on('event:cellsContainer:bindDrag', this.bindDragSelect, this);
    
    			//像素点转换为excel的坐标点
    			Backbone.on('event:cellsContainer:getCoordinateDisplayName', this.getCoordinateDisplayName, this);
    
    			Backbone.on('event:cellsContainer:destroy', this.destroy, this);
    
    			Backbone.on('event:cellsContainer:setMouseState', this.setMouseState, this);
    
    			this.currentRule = util.clone(cache.CurrentRule);
    			//记录冻结情况下导致视图移动大小
    			if (cache.TempProp.isFrozen === true) {
    				this.userViewTop = headItemRows.getModelByAlias(cache.UserView.rowAlias).get('top');
    				this.userViewLeft = headItemCols.getModelByAlias(cache.UserView.colAlias).get('left');
    				this.offsetTop = this.currentRule.displayPosition.offsetTop;
    				this.offsetLeft = this.currentRule.displayPosition.offsetLeft;
    			} else {
    				this.userViewTop = 0;
    				this.userViewLeft = 0;
    				this.offsetTop = 0;
    				this.offsetLeft = 0;
    			}
    
    			//监听剪切板选中区域创建
    			this.listenTo(selectRegions, 'add', this.addSelectRegionView);
    			_.bindAll(this, 'mouseDownHandle', 'mouseMoveHandle');
    
    			this.boxAttributes = options.boxAttributes;
    			//需要保留对父级视图的引用，需要父级视图的滚动像素，进行定位 
    			this.parentView = options.parentView;
    			//避免冻结情况下多个视图绑定该事件
    			if (!cache.TempProp.isFrozen ||
    				(this.currentRule.displayPosition.endRowIndex &&
    					this.currentRule.displayPosition.endColIndex)) {
    				Backbone.on('event:cellsContainer:moveSelectRegion', this.moveSelectRegion, this);
    			}
    			this.locatedState = this.selectLocatedState;
    			this.moveState = this.commonMoveState;
    			this.mouseCoordinate = {};
    			this.mouseLastCell = null;
    			this.mouseOverEventId = null;
    
    		},
    		mouseDownHandle: function(event) {
    			var temp = $('.comment');
    			if (temp.length && temp.attr('disabled') === undefined) {
    				return;
    			}
    			if ($(event.target).attr('class') === 'edit-frame') {
    				return;
    			}
    			if (cache.commentEditState) {
    				return;
    			}
    			this.locatedState(event);
    		},
    		mouseMoveHandle: function(event) {
    			var temp = $('.comment');
    			if (temp.length && temp.attr('disabled') === undefined) {
    				return;
    			}
    			if ($(event.target).attr('class') === 'edit-frame') {
    				return;
    			}
    			this.moveState(event);
    		},
    		outHandle: function() {
    			var temp = $('.comment');
    			if (temp.length && temp.attr('disabled') === undefined) {
    				return;
    			}
    			clearTimeout(this.mouseOverEventId);
    			this.mouseCoordinate = {};
    			this.mouseLastCell = null;
    			Backbone.trigger('event:bodyContainer:handleComment', {
    				action: 'hide'
    			});
    		},
    		
    		render: function() {
    			var modelList = selectRegions.models,
    				contentCellsContainer,
    				gridLineContainer,
    				len,
    				i;
    
    			this.$el.css({
    				'width': this.boxAttributes.width,
    				'height': this.boxAttributes.height
    			});
    			//待修改：父类不保存子类的引用（修改还原行列方式为订阅方式后，再进行修改）
    			this.gridLineContainer = new GridLineContainer();
    			this.contentCellsContainer = new ContentCellsContainer();
    			this.$el.append(this.gridLineContainer.render().el);
    			this.$el.append(this.contentCellsContainer.render().el);
    			len = modelList.length;
    			for (i = 0; i < len; i++) {
    				this.addSelectRegionView(modelList[i]);
    			}
    			return this;
    		},
    		
    		adaptWidth: function() {
    			var width = 0,
    				left = 0,
    				len, i;
    
    			len = this.currentRule.displayPosition.endColIndex || headItemColList.length - 1;
    			for (i = len; i > -1; i--) {
    				if (!headItemColList[i].get('hidden')) {
    					left = headItemColList[i].get('left');
    					width = headItemColList[i].get('width');
    					break;
    				}
    			}
    			this.$el.css('width', left + width);
    		},
    		
    		adaptHeight: function() {
    			var userViewTop = this.userViewTop,
    				offsetTop = this.offsetTop,
    				height = 0,
    				top = 0,
    				len, i;
    
    			len = this.currentRule.displayPosition.endRowIndex || headItemRowList.length - 1;
    			for (i = len; i > -1; i--) {
    				if (!headItemRowList[i].get('hidden')) {
    					top = headItemRowList[i].get('top');
    					height = headItemRowList[i].get('height');
    					break;
    				}
    			}
    			this.$el.css('height', top + height - userViewTop - offsetTop);
    		},
    		
    		setMouseState: function(type, state) {
    			this[type] = this[state];
    		},
    		selectLocatedState: function(event) {
    			var selectModel = selectRegions.getModelByType('selected');
    			this.located(event.clientX, event.clientY, selectModel, event.shiftKey);
    			Backbone.trigger('event:cellsContainer:setMouseState', 'moveState', 'selectMoveState');
    			Backbone.trigger('event:colsHeadContainer:setMouseState', 'moveState', null);
    		},
    		dataSourceLocatedState: function(event) {
    			var selectModel = selectRegions.getModelByType('datasource');
    			if (typeof selectModel === 'undefined') {
    				selectModel = new SelectRegionModel();
    				selectModel.set('selectType', 'datasource');
    				selectRegions.add(selectModel);
    			}
    			this.located(event.clientX, event.clientY, selectModel, event.shiftKey);
    			Backbone.trigger('event:cellsContainer:setMouseState', 'moveState', 'dataSourceMoveState');
    			Backbone.trigger('event:colsHeadContainer:setMouseState', 'moveState', null);
    		},
    		ruleSourceLocatedState: function(event) {
    			var selectModel = selectRegions.getModelByType('rulesource');
    			if (typeof selectModel === 'undefined') {
    				selectModel = new SelectRegionModel();
    				selectModel.set('selectType', 'rulesource');
    				selectRegions.add(selectModel);
    			}
    			this.located(event.clientX, event.clientY, selectModel, event.shiftKey);
    			Backbone.trigger('event:cellsContainer:setMouseState', 'moveState', 'ruleSourceMoveState');
    			Backbone.trigger('event:colsHeadContainer:setMouseState', 'moveState', null);
    		},
    		selectMoveState: function(event) {
    			var selectModel = selectRegions.getModelByType('selected');
    			this.select(event.clientX, event.clientY, selectModel);
    		},
    		dataSourceMoveState: function(event) {
    			var selectModel = selectRegions.getModelByType('datasource');
    			this.select(event.clientX, event.clientY, selectModel);
    		},
    		ruleSourceMoveState: function(event) {
    			var selectModel = selectRegions.getModelByType('rulesource');
    			this.select(event.clientX, event.clientY, selectModel);
    		},
    		commonMoveState: function(event) {
    			var cell,
    				colIndex,
    				rowIndex,
    				colAlias,
    				rowAlias,
    				startRowIndex,
    				coordinate,
    				options,
    				occupyX,
    				occupyY,
    				comment;
    
    			coordinate = this.getCoordinateByMouseEvent(event);
    			rowIndex = coordinate.rowIndex;
    			colIndex = coordinate.colIndex;
    			rowAlias = headItemRowList[rowIndex].get('alias');
    			colAlias = headItemColList[colIndex].get('alias');
    
    			if (this.mouseCoordinate.colAlias === colAlias && this.mouseCoordinate.rowAlias === rowAlias) {
    				return;
    			}
    			cell = cells.getCellByVertical(colIndex, rowIndex)[0];
    			cell = cell || null;
    			if (this.mouseLastCell === cell) {
    				return;
    			}
    			this.mouseLastCell = cell;
    			if (cell && (comment = cell.get('customProp').comment) !== null && comment !== undefined) {
    				occupyX = cell.get('occupy').x;
    				occupyY = cell.get('occupy').y;
    				options = {
    					colIndex: colIndex + occupyX.length - occupyX.indexOf(colAlias) - 1,
    					rowIndex: rowIndex - occupyY.indexOf(rowAlias),
    					comment: cell.get('customProp').comment,
    					action: 'show'
    				};
    			} else {
    				options = {
    					action: 'hide'
    				};
    			}
    			clearTimeout(this.mouseOverEventId);
    			if (options.action === 'hide') {
    				Backbone.trigger('event:bodyContainer:handleComment', options);
    			} else {
    				this.mouseOverEventId = setTimeout(function() {
    					Backbone.trigger('event:bodyContainer:handleComment', options);
    				}, 400);
    			}
    			this.mouseCoordinate = {
    				colAlias: colAlias,
    				rowAlias: rowAlias
    			};
    		},
    		
    		getCoordinate: function(colPosi, rowPosi) {
    			var containerId = cache.containerId,
    				clientColPosi,
    				clientRowPosi,
    				relativeColPosi,
    				relativeRowPosi,
    				endColIndex,
    				endRowIndex,
    				endColPosi,
    				endRowPosi,
    				colIndex,
    				rowIndex,
    				coordinate;
    
    			//相对于父级容器的坐标
    			clientColPosi = colPosi - config.System.outerLeft - $('#' + containerId).offset().left;
    			clientRowPosi = rowPosi - config.System.outerTop - $('#' + containerId).offset().top;
    
    			//过滤掉不在当前视图区域的坐标点
    			if (cache.TempProp.isFrozen === true) {
    				endColIndex = this.currentRule.displayPosition.endColIndex;
    				endRowIndex = this.currentRule.displayPosition.endRowIndex;
    				endColPosi = endColIndex && headItemColList[endColIndex].get('left') + headItemColList[endColIndex].get('width') - this.userViewLeft;
    				endRowPosi = endRowIndex && headItemRowList[endRowIndex].get('top') + headItemRowList[endRowIndex].get('height') - this.userViewTop;
    
    				if (clientColPosi < this.offsetLeft || (endColIndex && clientColPosi > endColPosi)) {
    					return;
    				}
    				if (clientRowPosi < this.offsetTop || (endRowIndex && clientRowPosi > endRowPosi)) {
    					return;
    				}
    			}
    			relativeColPosi = clientColPosi + this.parentView.el.scrollLeft + this.userViewLeft;
    			relativeRowPosi = clientRowPosi + this.parentView.el.scrollTop + this.userViewTop;
    
    			colIndex = binary.modelBinary(relativeColPosi, headItemColList, 'left', 'width');
    			rowIndex = binary.modelBinary(relativeRowPosi, headItemRowList, 'top', 'height');
    			return {
    				colIndex: colIndex,
    				rowIndex: rowIndex,
    				relativeRowPosi: relativeRowPosi,
    				relativeColPosi: relativeColPosi
    			}
    		},
    		
    		getCoordinateByMouseEvent: function(event) {
    			var mouseColPosi = event.clientX,
    				mouseRowPosi = event.clientY;
    			return this.getCoordinate(mouseColPosi, mouseRowPosi);
    		},
    		
    		getCoordinateDisplayName: function(colPosi, rowPosi, fn) {
    			var containerId = cache.containerId,
    				region = this.currentRule.displayPosition,
    				coordinate,
    				clientColPosi,
    				clientRowPosi,
    				limitLeft = 0,
    				limitTop = 0,
    				limitRight,
    				limitBottom;
    
    			limitLeft = headItemColList[region.startColIndex].get('left');
    			limitTop = headItemRowList[region.startRowIndex].get('top');
    
    			if (typeof region.endColIndex !== 'undefined') {
    				limitRight = headItemColList[region.endColIndex].get('left') +
    					headItemColList[region.endColIndex].get('width');
    			}
    			if (typeof region.endRowIndex !== 'undefined') {
    				limitTop = headItemRowList[region.endRowIndex].get('top') +
    					headItemRowList[region.endRowIndex].get('height');
    			}
    
    			clientColPosi = colPosi - config.System.outerLeft - $('#' + containerId).offset().left;
    			clientRowPosi = rowPosi - config.System.outerTop - $('#' + containerId).offset().top;
    			//判断坐标是否在当前的视图区域内
    			if (clientColPosi > limitRight || clientColPosi < limitLeft ||
    				clientRowPosi > limitBottom || clientRowPosi < limitTop) {
    				return;
    			}
    
    			var coordinate = this.getCoordinate(colPosi, rowPosi);
    			if (typeof fn === 'function' && typeof coordinate !== 'undefined') {
    				fn({
    					col: headItemColList[coordinate.colIndex].get('displayName'),
    					row: headItemRowList[coordinate.rowIndex].get('displayName')
    				});
    			}
    		},
    		
    		moveSelectRegion: function(direction) {
    			switch (direction) {
    				case 'LEFT':
    					break;
    				case 'RIGHT':
    					break;
    				case 'UP':
    					break;
    				case 'DOWN':
    					this.downSelectRegion();
    					break;
    				default:
    					break;
    			}
    		},
    		downSelectRegion: function() {
    			var endRowIndex,
    				startColIndex,
    				modelCell,
    				bottomIndex,
    				selectModel;
    
    			selectModel = selectRegions.getModelByType('selected');
    
    			endRowIndex = headItemRows.getIndexByAlias(selectModel.get('wholePosi').endY);
    			startColIndex = headItemCols.getIndexByAlias(selectModel.get('wholePosi').startX);
    
    			//向下移动超出已加载区域，不进行滚动操作
    			if (endRowIndex === headItemRows.length - 1) {
    				return;
    			}
    			selectModel.set('tempPosi', {
    				initColIndex: startColIndex,
    				initRowIndex: endRowIndex + 1,
    				mouseColIndex: startColIndex,
    				mouseRowIndex: endRowIndex + 1
    			});
    			Backbone.trigger('event:mainContainer:showSelectRegion', 'DOWN');
    		},
    		
    		addSelectRegionView: function(model) {
    			var className,
    				selectRegionView,
    				type = model.get('selectType');
    
    			className = type + '-container';
    			selectRegionView = new SelectRegionView({
    				model: model,
    				className: className,
    				currentRule: this.currentRule,
    				parentView: this
    			});
    			this.$el.append(selectRegionView.render().el);
    		},
    		
    		located: function(colPosi, rowPosi, selectModel, shift) {
    			if (shift) {
    				this.select(colPosi, rowPosi, selectModel);
    			} else {
    				this.changePosi(colPosi, rowPosi, selectModel);
    			}
    		},
    		
    		changePosi: function(colPosi, rowPosi, selectModel) {
    			var strandCol = cache.CellsPosition.strandX,
    				occupyCol,
    				occupyRow,
    				coordinate,
    				modelCell,
    				startColIndex,
    				startRowIndex,
    				endColIndex,
    				endRowIndex,
    				colDisplayNames = [],
    				rowDisplayNames = [],
    				aliasCol,
    				aliasRow,
    				text = '',
    				i;
    
    			//获取点击位置信息
    			coordinate = this.getCoordinate(colPosi, rowPosi);
    			endColIndex = startColIndex = coordinate.colIndex;
    			endRowIndex = startRowIndex = coordinate.rowIndex;
    			aliasCol = headItemColList[startColIndex].get('alias');
    			aliasRow = headItemRowList[startRowIndex].get('alias');
    
    			if (strandCol[aliasCol] && typeof strandCol[aliasCol][aliasRow] !== 'undefined') {
    				modelCell = cells.models[strandCol[aliasCol][aliasRow]];
    				occupyCol = modelCell.get('occupy').x;
    				occupyRow = modelCell.get('occupy').y;
    				startColIndex = startColIndex - occupyCol.indexOf(aliasCol);
    				startRowIndex = startRowIndex - occupyRow.indexOf(aliasRow);
    				endColIndex = endColIndex + occupyCol.length - occupyCol.indexOf(aliasCol) - 1;
    				endRowIndex = endRowIndex + occupyRow.length - occupyRow.indexOf(aliasRow) - 1;
    				//对单元格未完全加载做处理
    				endRowIndex = endRowIndex < headItemRows.length ? endRowIndex : headItemRows.length - 1;
    				text = modelCell.get('content.texts');
    			}
    
    			selectModel.set('tempPosi', {
    				initColIndex: startColIndex,
    				initRowIndex: startRowIndex,
    				mouseColIndex: endColIndex,
    				mouseRowIndex: endRowIndex
    			});
    
    			var result = {};
    			for (i = startColIndex; i < endColIndex + 1; i++) {
    				colDisplayNames.push(headItemColList[i].get('displayName'));
    			}
    			for (i = startRowIndex; i < endRowIndex + 1; i++) {
    				rowDisplayNames.push(headItemRowList[i].get('displayName'));
    			}
    			result.point = {
    				col: colDisplayNames,
    				row: rowDisplayNames
    			};
    			result.text = text;
    			result.property = fillCellProperty(modelCell);
    			listener.excute('mousedown', result);
    
    			function fillCellProperty(model) {
    				var modelJSON;
    				if (typeof model === 'undefined') {
    					model = new Cell();
    				}
    				modelJSON = model.toJSON();
    				return {
    					size: modelJSON.content.size,
    					family: modelJSON.content.family,
    					bd: modelJSON.content.bd,
    					italic: modelJSON.content.italic,
    					color: modelJSON.content.color,
    					alignRow: modelJSON.content.alignRow,
    					alignCol: modelJSON.content.alignCol,
    					background: modelJSON.customProp.background,
    					format: modelJSON.customProp.format,
    					wordWrap: modelJSON.wordWrap
    				}
    			}
    		},
    		
    		select: function(colPosi, rowPosi, selectModel) {
    			var initColIndex,
    				initRowIndex,
    				lastColMouse,
    				lastRowMouse,
    				mouseColIndex,
    				mouseRowIndex,
    				selectModel,
    				coordinate,
    				colIndex,
    				rowIndex;
    
    
    			coordinate = this.getCoordinate(colPosi, rowPosi);
    			mouseColIndex = coordinate.colIndex;
    			mouseRowIndex = coordinate.rowIndex;
    
    			//鼠标开始移动索引
    			initColIndex = selectModel.get('tempPosi').initColIndex;
    			initRowIndex = selectModel.get('tempPosi').initRowIndex;
    			//上次移动鼠标坐标
    			lastColMouse = selectModel.get('tempPosi').mouseColIndex;
    			lastRowMouse = selectModel.get('tempPosi').mouseRowIndex;
    
    			//判断是否需要渲染
    			if (lastColMouse === mouseColIndex && lastRowMouse === mouseRowIndex) {
    				return;
    			}
    			selectModel.set('tempPosi', {
    				initColIndex: initColIndex,
    				initRowIndex: initRowIndex,
    				mouseColIndex: mouseColIndex,
    				mouseRowIndex: mouseRowIndex
    			});
    		},
    		
    		destroy: function() {
    			var i = 0,
    				len,
    				selectModelList;
    			Backbone.off('event:cellsContainer:destroy');
    			Backbone.off('event:cellsContainer:adaptWidth');
    			Backbone.off('event:cellsContainer:adaptHeight');
    			Backbone.off('event:cellsContainer:moveSelectRegion');
    			Backbone.off('event:cellsContainer:setMouseState');
    			Backbone.trigger('event:contentCellsContainer:destroy');
    			//待修改：需要销毁包含视图
    			selectModelList = selectRegions.models;
    			len = selectModelList.length;
    			for (; i < len; i++) {
    				if (selectModelList[i].get('selectType') !== 'selected') {
    					selectModelList[i].destroy();
    				}
    			}
    			this.remove();
    		}
    	});
    	return CellsContainer;
    });
    
    define('views/mainContainer',function() {
    	
    	var $ = require('lib/jquery'),
    		Backbone = require('lib/backbone'),
    		binary = require('basic/util/binary'),
    		cache = require('basic/tools/cache'),
    		config = require('spreadsheet/config'),
    		original = require('basic/tools/original'),
    		clone = require('basic/util/clone'),
    		send = require('basic/tools/send'),
    		loadRecorder = require('basic/tools/loadrecorder'),
    		headItemCols = require('collections/headItemCol'),
    		headItemRows = require('collections/headItemRow'),
    		siderLineRows = require('collections/siderLineRow'),
    		cells = require('collections/cells'),
    		selectRegions = require('collections/selectRegion'),
    		CellsContainer = require('views/cellsContainer'),
    		headItemRowList = headItemRows.models,
    		headItemColList = headItemCols.models;
    
    	
    	var MainContainer = Backbone.View.extend({
    
    		
    		initialize: function(options) {
    			var lineRowList,
    				lineColList,
    				lastLineRow,
    				lastLineCol,
    				startRowIndex,
    				startColIndex,
    				endRowIndex,
    				endColIndex,
    				len;
    
    			Backbone.on('event:mainContainer:destroy', this.destroy, this);
    			this.currentRule = clone.clone(cache.CurrentRule);
    
    			if (cache.TempProp.isFrozen === true) {
    				this.offsetTop = this.currentRule.displayPosition.offsetTop;
    				this.userViewTop = headItemRows.getModelByAlias(cache.UserView.rowAlias).get('top');
    			} else {
    				this.offsetTop = 0;
    				this.userViewTop = 0;
    			}
    			this.boxModel = {};
    
    			this.boxAttributes = this.currentRule.boxAttributes;
    
    			// for reduction position , prevent event scroll auto trigger.
    
    			lineRowList = headItemRowList;
    			lineColList = headItemColList;
    
    			startRowIndex = this.currentRule.displayPosition.startRowIndex;
    			startColIndex = this.currentRule.displayPosition.startColIndex;
    			endRowIndex = this.currentRule.displayPosition.endRowIndex;
    			endColIndex = this.currentRule.displayPosition.endColIndex;
    
    			this.parentNode = options.parentNode;
    
    			//计算容器高度
    			if (cache.TempProp.isFrozen) {
    				if (endRowIndex) {
    					lineRowList = lineRowList.slice(startRowIndex, endRowIndex);
    				} else {
    					lineRowList = lineRowList.slice(startRowIndex);
    				}
    				if (endColIndex) {
    					lineColList = lineColList.slice(startColIndex, endColIndex);
    				} else {
    					lineColList = lineColList.slice(startColIndex);
    				}
    			}
    			//避免len为0的情况
    			if (len = lineRowList.length) {
    				lastLineRow = lineRowList[len - 1];
    				this.boxModel.height = lastLineRow.get('top') + lastLineRow.get('height') -
    					lineRowList[0].get('top');
    			} else {
    				this.boxModel.height = 0;
    			}
    			//避免len为0的情况
    			if (len = lineColList.length) {
    				lastLineCol = lineColList[len - 1];
    				this.boxModel.width = lastLineCol.get('left') + lastLineCol.get('width') -
    					lineColList[0].get('left');
    			} else {
    				this.boxModel.width = 0;
    			}
    
    			if (endRowIndex === undefined) {
    				Backbone.on('event:changeSidebarContainer', this.shrink, this);
    			}
    			if (this.currentRule.eventScroll) {
    				
    				this.delegateEvents({
    					'scroll': 'syncScroll'
    				});
    				Backbone.on('call:mainContainer', this.callMainContainer, this);
    				Backbone.on('event:mainContainer:showSelectRegion', this.showSelectRegion, this);
    				Backbone.on('event:mainContainer:adaptRowHeightChange', this.adaptRowHeightChange, this);
    				cache.viewRegion.top = lineRowList[0].get('top');
    				cache.viewRegion.bottom = lastLineRow.get('top') + lastLineRow.get('height');
    				cache.viewRegion.scrollTop = 0;
    				cache.viewRegion.scrollLeft = 0;
    				this.loadRowState = 'FULFILL';
    			} else {
    				Backbone.on('event:mainContainer:appointPosition', this.appointPosition, this);
    			}
    		},
    		
    		addBackGround: function(cellsContainer) {
    			if (this.currentRule.displayPosition.endColAlias !== undefined &&
    				this.currentRule.displayPosition.endRowAlias !== undefined) {
    				//修改为模板
    				this.$el.append('<div style="position:absolute;width:inherit;height:inherit;background-color:white;top:0;left:0;z-index:13"></div>');
    				cellsContainer.$el.css({
    					'z-index': '14'
    				});
    			} else if (this.currentRule.displayPosition.endColAlias !== undefined ||
    				this.currentRule.displayPosition.endRowAlias !== undefined) {
    				this.$el.append('<div style="position:absolute;width:inherit;height:inherit;background-color:white;top:0;left:0;z-index:10"></div>');
    				cellsContainer.$el.css({
    					'z-index': '11'
    				});
    			}
    		},
    		
    		render: function() {
    			this.attributesRender(this.boxAttributes);
    			var cellsContainer = new CellsContainer({
    				boxAttributes: {
    					height: this.boxModel.height,
    					width: this.boxModel.width
    				},
    				parentView: this
    			});
    			this.$el.append(cellsContainer.render().el);
    			this.addBackGround(cellsContainer);
    			return this;
    		},
    		shrink: function() {
    			if (cache.sidebarState) {
    				this.$el.width(this.boxAttributes.width - config.sidebarWidth);
    			} else {
    				this.$el.width(this.boxAttributes.width);
    			}
    		},
    		//for new diff object, subscribe it self object.
    		subscribeScroll: function(value, direction) {
    			this.appointPosition(value, direction);
    		},
    		// appoint position , don't pass preventScroll action .
    		appointPosition: function(value, direction) {
    			this.isPreventScroll = false;
    			if (direction === 'TRANSVERSE') {
    				this.$el.scrollLeft(value);
    			}
    			if (direction === 'VERTICAL') {
    				this.$el.scrollTop(value);
    			}
    		},
    		
    		callMainContainer: function(receiveFunc) {
    			receiveFunc(this);
    		},
    		
    		attributesRender: function(newAttributes) {
    			var width = newAttributes.width,
    				endColIndex =this.currentRule.displayPosition.endColIndex ;
    			if (typeof endColIndex === 'undefined' && cache.sidebarState) {
    				width = width - config.sidebarWidth;
    				width = width < 0 ? 0 : width;
    			}
    			this.$el.css({
    				'width': width,
    				'height': newAttributes.height
    			});
    			if (newAttributes.style) {
    				this.$el.addClass(newAttributes.style);
    			}
    		},
    		showSelectRegion: function(direction) {
    			switch (direction) {
    				case 'LEFT':
    					break;
    				case 'RIGHT':
    					break;
    				case 'UP':
    					break;
    				case 'DOWN':
    					this.downScroll();
    					break;
    				default:
    					break;
    			}
    		},
    		
    		downScroll: function() {
    			var limitBottomPosi,
    				bottomRowModel,
    				selectModel,
    				adjustPosi;
    
    			selectModel = selectRegions.getModelByType('selected');
    			bottomRowModel = headItemRows.getModelByAlias(selectModel.get('wholePosi').startY);
    			limitBottomPosi = bottomRowModel.get('top') + bottomRowModel.get('height');
    
    			adjustPosi = limitBottomPosi - this.offsetTop - this.userViewTop -
    				this.el.scrollTop - this.el.offsetHeight;
    			if (adjustPosi > 0) {
    				this.el.scrollTop += adjustPosi + 17;
    			}
    
    		},
    		
    		syncScroll: function(e, direction) {
    			var verticalDirection,
    				recordScrollTop = cache.viewRegion.scrollTop,
    				recordScrollLeft = cache.viewRegion.scrollLeft,
    				currentViewTop = cache.viewRegion.top,
    				currentViewBottom = cache.viewRegion.bottom;
    
    			cache.viewRegion.scrollTop = this.el.scrollTop;
    			cache.viewRegion.scrollLeft = this.el.scrollLeft;
    
    			verticalDirection = recordScrollTop - this.el.scrollTop;
    
    			//as scrollbar scroll up
    			if (verticalDirection > 0 || direction === 'up') {
    				this.addTop(currentViewTop);
    				this.deleteBottom(currentViewBottom);
    				this.publish('mainContainer', 'verticalPublish', this.el.scrollTop, 'VERTICAL');
    			}
    			//as scrollbar scroll down
    			if (verticalDirection < 0 || direction === 'down') {
    				//delete top row
    				this.addBottom(currentViewBottom);
    				this.deleteTop(currentViewTop);
    				this.publish('mainContainer', 'verticalPublish', this.el.scrollTop, 'VERTICAL');
    			}
    			if (recordScrollLeft !== this.el.scrollLeft) {
    				this.publish('mainContainer', 'transversePublish', this.el.scrollLeft, 'TRANSVERSE');
    			}
    			this.updateUserView();
    		},
    		
    		deleteTop: function(recordTop) {
    			var headItemRowList = headItemRows.models,
    				limitIndex, //预加载区域边界索引 
    				limitTop, //预加载区域边界高度
    				limitAlias, //预加载区域边界别名
    				recordIndex,
    				tempCells, //区域内单元格数组
    				cellPositionArray,
    				offsetTop,
    				userViewTop,
    				i, len;
    
    			offsetTop = this.offsetTop;
    			userViewTop = this.userViewTop;
    			//当前状态预加载标线高度
    			limitTop = this.el.scrollTop - config.System.prestrainHeight + offsetTop + userViewTop;
    			if (recordTop < 0) {
    				recordTop = 0;
    			}
    			if (limitTop < 0) {
    				limitTop = 0;
    			}
    
    			limitIndex = binary.indexModelBinary(limitTop, headItemRowList, 'top', 'height');
    			recordIndex = binary.indexModelBinary(recordTop, headItemRowList, 'top', 'height');
    
    			if (recordIndex >= limitIndex) {
    				return;
    			}
    
    			for (i = recordIndex; i < limitIndex; i++) {
    				headItemRowList[i].destroyView();
    			}
    
    			tempCells = cells.getCellByRow(recordIndex, limitIndex - 1);
    			limitAlias = headItemRowList[i].get('alias');
    			for (i = 0, len = tempCells.length; i < len; i++) {
    				//判断cell最下端是否超出了显示界限
    				cellPositionArray = tempCells[i].get('occupy').y;
    				if (cellPositionArray.indexOf(limitAlias) === -1) {
    					tempCells[i].hide();
    				}
    			}
    			cache.viewRegion.top = headItemRowList[limitIndex].get('top');
    		},
    		
    		addTop: function(recordTop) {
    			var headItemRowList = headItemRows.models,
    				limitTopPosi,
    				limitBottomPosi,
    				offsetTop,
    				userViewTop,
    				self = this;
    
    			//冻结情况，计算视图的偏移量
    			offsetTop = this.offsetTop;
    			userViewTop = this.userViewTop;
    
    			//计算新的边界高度
    			limitTopPosi = this.el.scrollTop - config.System.prestrainHeight + offsetTop + userViewTop;
    			limitTopPosi = limitTopPosi < 0 ? 0 : limitTopPosi;
    			limitBottomPosi = this.el.scrollTop + this.el.offsetHeight + config.System.prestrainHeight + offsetTop + userViewTop;
    			limitBottomPosi = recordTop < limitBottomPosi ? recordTop : limitBottomPosi;
    
    			this.loadRegion(limitTopPosi, limitBottomPosi, restoreView);
    
    			
    			function restoreView(top, bottom) {
    				var headItemRowModel,
    					cellModel,
    					cellList,
    					startIndex,
    					endIndex,
    					len, i;
    
    				startIndex = binary.indexModelBinary(top, headItemRowList, 'top', 'height');
    				endIndex = binary.indexModelBinary(bottom, headItemRowList, 'top', 'height');
    				for (i = endIndex; i >= startIndex; i--) {
    					headItemRowModel = headItemRowList[i];
    					if (headItemRowModel.get('isView') === false) {
    						headItemRowModel.set('isView', true);
    						self.publish('mainContainer', 'restoreRowView', headItemRowModel, 'up');
    					}
    				}
    				cellList = cells.getCellByRow(startIndex, endIndex);
    				for (i = 0, len = cellList.length; i < len; i++) {
    					cellModel = cellList[i];
    					if (cellModel.get('showState') === false) {
    						cellModel.set('showState', true);
    						self.publish('mainContainer', 'restoreCellView', cellModel);
    					}
    				}
    				self.adjustColPropCell(startIndex, endIndex);
    				cache.viewRegion.top = headItemRowList[startIndex].get('top');
    			}
    		},
    		
    		deleteBottom: function(recordPosi) {
    			var headItemRowList = headItemRows.models,
    				cellRowAliasArray,
    				recordIndex,
    				limitPosi,
    				limitIndex,
    				limitAlias,
    				tempCells,
    				offsetTop,
    				userViewTop,
    				i, len;
    
    			if (this.loadRowState === 'PENDING') {
    				return;
    			}
    
    			offsetTop = this.offsetTop;
    			userViewTop = this.userViewTop;
    
    			recordIndex = binary.indexModelBinary(recordPosi, headItemRowList, 'top', 'height');
    
    			limitPosi = this.el.scrollTop + this.el.offsetHeight + config.System.prestrainHeight + offsetTop + userViewTop;
    			limitIndex = binary.indexModelBinary(limitPosi, headItemRowList, 'top', 'height');
    			limitAlias = headItemRowList[limitIndex].get('alias');
    			for (i = limitIndex + 1; i <= recordIndex; i++) {
    				headItemRowList[i].set('isView', false);
    			}
    			//删除超过加载区域cell视图对象
    			tempCells = cells.getCellByRow(limitIndex + 1, recordIndex);
    			for (i = 0, len = tempCells.length; i < len; i++) {
    				cellRowAliasArray = tempCells[i].get('occupy').y;
    				if (cellRowAliasArray.indexOf(limitAlias) === -1) {
    					tempCells[i].hide();
    				}
    			}
    			cache.viewRegion.bottom = headItemRowList[limitIndex].get('top') + headItemRowList[limitIndex].get('height');
    		},
    
    		
    		addBottom: function(recordPosi) {
    			var limitTopPosi,
    				limitBottomPosi,
    				offsetTop,
    				userViewTop,
    				self = this;
    
    			if (this.loadRowState === 'PENDING') {
    				return;
    			}
    
    			offsetTop = this.offsetTop;
    			userViewTop = this.userViewTop;
    
    			limitTopPosi = this.el.scrollTop - config.System.prestrainHeight + offsetTop + userViewTop;
    			limitBottomPosi = limitTopPosi + this.el.offsetHeight + config.System.prestrainHeight * 2;
    
    			//自动增长行或者是后台请求数据，已将加载高度可能会超过新的预加载区
    			if (recordPosi >= limitBottomPosi) {
    				return;
    			}
    
    			limitTopPosi = recordPosi + 1 > limitTopPosi ? recordPosi + 1 : limitTopPosi;
    
    			this.loadRegion(limitTopPosi, limitBottomPosi, restoreView);
    
    			
    			function restoreView(top, bottom) {
    				var headItemRowModel,
    					cellList,
    					cellModel,
    					maxBottom,
    					startIndex,
    					endIndex,
    					i, len;
    
    				maxBottom = headItemRows.getMaxDistanceHeight();
    				maxBottom = maxBottom < bottom ? maxBottom : bottom;
    
    				startIndex = binary.indexModelBinary(top, headItemRowList, 'top', 'height');
    				endIndex = binary.indexModelBinary(maxBottom, headItemRowList, 'top', 'height');
    				for (i = startIndex; i <= endIndex; i++) {
    					headItemRowModel = headItemRowList[i];
    					if (headItemRowModel.get('isView') === false) {
    						headItemRowModel.set('isView', true);
    						self.publish('mainContainer', 'restoreRowView', headItemRowModel, 'down');
    					}
    				}
    				cellList = cells.getCellByRow(startIndex, endIndex);
    				for (i = 0, len = cellList.length; i < len; i++) {
    					cellModel = cellList[i];
    					if (cellModel.get('showState') === false) {
    						cellModel.set('showState', true);
    						self.publish('mainContainer', 'restoreCellView', cellModel);
    					}
    				}
    				if (maxBottom < bottom) {
    					bottom = self.addRows(bottom);
    					endIndex = binary.indexModelBinary(bottom, headItemRowList, 'top', 'height');
    				}
    
    				self.adjustColPropCell(startIndex, endIndex);
    				self.adaptSelectRegion();
    				cache.viewRegion.bottom = headItemRowList[endIndex].get('top') + headItemRowList[endIndex].get('height');
    				self.adjustContainerHeight();
    			}
    		},
    		
    		loadRegion: function(top, bottom, restoreView) {
    			var existUnloads;
    
    			//超出表格的最大高度或新建表格，直接进行视图的还原和添加
    			if (top > cache.localRowPosi || cache.localRowPosi === 0) {
    				restoreView.call(this, top, bottom);
    				return;
    			}
    			bottom = bottom < cache.localRowPosi ? bottom : cache.localRowPosi;
    
    			existUnloads = loadRecorder.isUnloadPosi(top, bottom, cache.rowRegionPosi);
    
    			if (existUnloads) {
    				this.doRequest(top, bottom, restoreView);
    			} else {
    				restoreView.call(this, top, bottom);
    			}
    		},
    		doRequest: function(top, bottom, restoreView) {
    			var self = this;
    
    			this.loadRowState = 'PENDING';
    			bottom = bottom + cache.scrollBufferHeight;
    
    			send.PackAjax({
    				url: config.url.sheet.load,
    				isPublic: false,
    				dataType: 'json',
    				data: JSON.stringify({
    					top: top,
    					bottom: bottom
    				}),
    				success: analysisData
    			});
    
    			function analysisData(data) {
    				var bottomIndex,
    					startRowSort,
    					rowList,
    					cellList,
    					validate,
    					topIndex;
    				if (!data) {
    					return;
    				}
    
    				startRowSort = data.dataRowStartIndex;
    				cache.localRowPosi = data.maxRowPixel;
    				rowList = data.returndata.spreadSheet[0].sheet.glY;
    				cellList = data.returndata.spreadSheet[0].sheet.cells;
    				validate = data.returndata.spreadSheet[0].validate;
    				original.analysisRowData(rowList, startRowSort);
    				original.analysisCellData(cellList);
    				original.analysisValidateRule(validate.rules);
    				topIndex = binary.indexModelBinary(top, headItemRowList, 'top', 'height');
    				bottomIndex = binary.indexModelBinary(bottom, headItemRowList, 'top', 'height');
    
    				top = headItemRowList[topIndex].get('top');
    				bottom = headItemRowList[bottomIndex].get('top') + headItemRowList[bottomIndex].get('height');
    				loadRecorder.insertPosi(top, bottom, cache.rowRegionPosi);
    				restoreView.call(self, top, bottom);
    				self.loadRowState = 'FULFILL';
    			}
    		},
    		
    		adaptSelectRegion: function() {
    			var select = selectRegions.getModelByType('selected'),
    				headLineRowModelList = headItemRows.models,
    				endColAlias = select.get('wholePosi').endX,
    				endRowAlias = select.get('wholePosi').endY,
    				currentModelIndex,
    				height,
    				len, i,
    				model;
    
    			if (endColAlias !== 'MAX' && endRowAlias !== 'MAX') {
    				return;
    			}
    			//暂时只做整列选中的调节
    			if (endRowAlias === 'MAX') {
    				height = select.get('physicsBox').height;
    				currentModelIndex = binary.modelBinary(height - 1, headLineRowModelList, 'top', 'height', 0, headLineRowModelList.length - 1);
    				len = headItemRows.length;
    				model = headItemRows.models[len - 1];
    				height = model.get('top') + model.get('height') - 1;
    				select.set('physicsBox.height', height);
    				siderLineRows.models[0].set({
    					height: height
    				});
    			}
    			for (i = currentModelIndex + 1; i < len; i++) {
    				headLineRowModelList[i].set('activeState', true);
    			}
    		},
    		adaptRowHeightChange: function(startPosi, diff) {
    			if (cache.localRowPosi !== 0) {
    				cache.localRowPosi += diff;
    				loadRecorder.adaptPosi(startPosi, diff, cache.rowRegionPosi);
    			}
    
    			if (cache.viewRegion.top > startPosi) {
    				cache.viewRegion.top += diff;
    				if (diff > 0) {
    					this.addTop(cache.viewRegion.top);
    				} else {
    					this.deleteTop(cache.viewRegion.top);
    				}
    			}
    			if (cache.viewRegion.bottom > startPosi) {
    				cache.viewRegion.bottom += diff;
    				//处理末尾行删除情况
    				if (cache.viewRegion.bottom < cache.viewRegion.top) {
    					cache.viewRegion.top = cache.viewRegion.bottom;
    				}
    				if (diff > 0) {
    					this.deleteBottom(cache.viewRegion.bottom);
    				} else {
    					this.addBottom(cache.viewRegion.bottom);
    				}
    			}
    			this.updateUserView();
    		},
    		updateUserView: function() {
    			if (cache.TempProp.isFrozen) {
    				return;
    			}
    			var startRowModel, endRowModel, startColModel, endColModel;
    
    			startRowModel = headItemRows.getModelByPosition(this.el.scrollTop);
    			endRowModel = headItemRows.getModelByPosition(this.el.scrollTop + this.el.offsetHeight);
    			cache.UserView.rowAlias = startRowModel.get('alias');
    			cache.UserView.rowEndAlias = endRowModel.get('alias');
    
    			startColModel = headItemCols.getModelByPosition(cache.viewRegion.scrollLeft);
    			endColModel = headItemCols.getModelByPosition(cache.viewRegion.scrollLeft + this.el.offsetWidth);
    			cache.UserView.colAlias = startColModel.get('alias');
    			cache.UserView.colEndAlias = endColModel.get('alias');
    		},
    		addRows: function(height) {
    			var maxheadItemHeight = headItemRows.getMaxDistanceHeight(),
    				maxLocalHeight = cache.localRowPosi,
    				startIndex = headItemRows.length,
    				len;
    
    			if (height <= maxheadItemHeight || height <= maxLocalHeight) {
    				return height;
    			}
    			maxheadItemHeight = maxheadItemHeight > maxLocalHeight ? maxheadItemHeight : maxLocalHeight;
    			len = Math.ceil((height + cache.scrollBufferHeight - maxheadItemHeight) / config.User.cellHeight);
    			headItemRows.generate(len);
    			send.PackAjax({
    				url: config.url.row.plusBatch,
    				data: JSON.stringify({
    					num: len
    				})
    			});
    			this.adjustColPropCell(startIndex, startIndex + len - 1);
    			height = headItemRows.getMaxDistanceHeight();
    			return height;
    		},
    		
    		adjustColPropCell: function(startIndex, endIndex) {
    			var headItemModel,
    				aliasCol,
    				aliasRow,
    				occupyCol,
    				colProp,
    				len, i = 0,
    				j;
    
    			len = headItemColList.length;
    			occupyCol = cache.CellsPosition.strandX;
    			for (; i < len; i++) {
    				headItemModel = headItemColList[i];
    				colProp = headItemModel.get('operProp');
    				if (!$.isEmptyObject(colProp)) {
    					for (j = startIndex; j < endIndex + 1; j++) {
    						aliasCol = headItemColList[i].get('alias');
    						aliasRow = headItemRowList[j].get('alias');
    						if (occupyCol[aliasCol] === undefined || occupyCol[aliasCol][aliasRow] === undefined) {
    							cells.createCellModel(i, j, colProp);
    						}
    					}
    				}
    			}
    		},
    		adjustContainerHeight: function() {
    			Backbone.trigger('event:cellsContainer:adaptHeight');
    			Backbone.trigger('event:rowsAllHeadContainer:adaptHeight');
    		},
    		
    		destroy: function() {
    			if (this.unsubscribe) {
    				this.unsubscribe('mainContainer', 'transversePublish');
    				this.unsubscribe('mainContainer', 'verticalPublish');
    			}
    			Backbone.trigger('event:cellsContainer:destroy');
    			Backbone.off('call:mainContainer');
    			Backbone.off('event:mainContainer:destroy');
    			Backbone.off('event:mainContainer:adaptRowHeightChange');
    			Backbone.off('event:mainContainer:showSelectRegion');
    			Backbone.off('event:mainContainer:appointPosition');
    			Backbone.off('event:changeSidebarContainer');
    			this.remove();
    
    		}
    	});
    	return MainContainer;
    });
    
    define('views/headItemColContainer',function() {
    	var $ = require('lib/jquery'),
    		Backbone = require('lib/backbone'),
    		getTemplate = require('basic/tools/template'),
    		headItemCols = require('collections/headItemCol'),
    		cache = require('basic/tools/cache'),
    		util = require('basic/util/clone'),
    		HeadItemColContainer;
    
    	
    	HeadItemColContainer = Backbone.View.extend({
    		
    		className: 'col-head-item',
    		
    		initialize: function() {
    			// this.frozenOffsetLeft = option.frozenLeft;
    			this.listenTo(this.model, 'change:activeState', this.toggleActive);
    			this.listenTo(this.model, 'change:isView', this.destroy);
    			this.listenTo(this.model, 'change:hidden', this.destroy);
    			this.listenTo(this.model, 'change:left', this.changeLeft);
    			this.listenTo(this.model, 'change:width', this.changeWidth);
    			this.listenTo(this.model, 'change:displayName', this.changeDisplayName);
    			this.listenTo(this.model, 'change:isLeftAjacentHide', this.changeLeftAjacentHide);
    			this.listenTo(this.model, 'change:isRightAjacentHide', this.changeRightAjacentHide);
    			this.listenTo(this.model, 'destroy', this.remove);
    			this.currentRule = util.clone(cache.CurrentRule);
    			this.offsetLeft = cache.TempProp.isFrozen ? (this.currentRule.displayPosition.offsetLeft || 0) : 0;
    		},
    		
    		render: function() {
    
    			
    			this.template = getTemplate('COLHEADTEMPLATE');
    			this.changeLeft();
    			// this.changeWidth();
    			this.changeRightAjacentHide();
    			this.$el.html(this.template(this.model.toJSON())).data('alias', this.model.get('alias'));
    			this.toggleActive();
    			return this;
    		},
    		
    		toggleActive: function() {
    			this.$el.toggleClass('active', this.model.toJSON().activeState);
    		},
    		
    		changeLeft: function() {
    			var modelJSON = this.model.toJSON(),
    				left = modelJSON.left,
    				userViewLeft = 0,
    				userViewModel;
    			if (this.currentRule.reduceUserView) {
    				userViewModel = headItemCols.getModelByAlias(cache.UserView.colAlias);
    				userViewLeft = userViewModel.toJSON().left;
    			}
    			if (modelJSON.isLeftAjacentHide) {
    				left++;
    			}
    			this.$el.css({
    				left: left - this.offsetLeft - userViewLeft
    			});
    		},
    		
    		changeWidth: function() {
    			var modelJSON = this.model.toJSON(),
    				width = modelJSON.width;
    
    			if (modelJSON.isLeftAjacentHide) {
    				width--;
    			}
    
    			if (modelJSON.isRightAjacentHide) {
    				width--;
    			}
    
    			this.$el.css({
    				width: width
    			});
    		},
    		changeRightAjacentHide: function() {
    			var modelJSON = this.model.toJSON();
    			if (modelJSON.isRightAjacentHide) {
    				this.changeWidth();
    				this.$el.css({
    					'border-right': '3px double #d4d4d4'
    				});
    			} else {
    				this.changeWidth();
    				this.$el.removeAttr('border-right');
    			}
    		},
    		changeLeftAjacentHide: function() {
    			this.changeWidth();
    			this.changeLeft();
    		},
    		changeDisplayName: function() {
    			this.$el.children('.item').html(this.model.get('displayName'));
    		},
    		changeView: function() {
    			if (this.model.toJSON().isView === false) {
    				this.destroy();
    			}
    		},
    		
    		destroy: function() {
    			if (!this.model.get('isView') || this.model.get('hidden')) {
    				this.remove();
    			}
    		}
    	});
    	return HeadItemColContainer;
    });
    define('views/colsSpaceLineContainer',function() {
    	
    	var Backbone = require('lib/backbone');
    	
    	var ColsSpaceLineContainer = Backbone.View.extend({
    		
    		className: 'col-space-container',
    		
    		initialize: function(allAttributes) {
    			Backbone.on('call:colsSpaceLineContainer', this.callColsSpaceLineContainer, this);
    			Backbone.on('event:colsSpaceLineContainer:destroy', this.destroy, this);
    			this.boxAttributes = allAttributes.boxAttributes;
    		},
    		
    		render: function() {
    			this.attributesRender(this.boxAttributes);
    			return this;
    		},
    		
    		callColsSpaceLineContainer: function(receiveFunc) {
    			receiveFunc(this);
    		},
    		
    		attributesRender: function(newAttributes) {
    			this.$el.css({
    				'left': newAttributes.left
    			});
    		},
    		
    		destroy: function() {
    			this.remove();
    		}
    	});
    	return ColsSpaceLineContainer;
    });
    define('views/colsHeadContainer',function() {
    	
    	var $ = require('lib/jquery'),
    		_ = require('lib/underscore'),
    		Backbone = require('lib/backbone'),
    		config = require('spreadsheet/config'),
    		binary = require('basic/util/binary'),
    		cache = require('basic/tools/cache'),
    		send = require('basic/tools/send'),
    		getDisplayName = require('basic/tools/getdisplayname'),
    		SelectRegionModel = require('models/selectRegion'),
    		headItemRows = require('collections/headItemRow'),
    		headItemCols = require('collections/headItemCol'),
    		cells = require('collections/cells'),
    		selectRegions = require('collections/selectRegion'),
    		siderLineRows = require('collections/siderLineRow'),
    		siderLineCols = require('collections/siderLineCol'),
    		HeadItemColContainer = require('views/headItemColContainer'),
    		ColsSpaceLineContainer = require('views/colsSpaceLineContainer'),
    		gridRowList = headItemRows.models,
    		gridColList = headItemCols.models,
    		ColsHeadContainer;
    	
    	//ps:index修改为alias,列宽调整功能
    	ColsHeadContainer = Backbone.View.extend({
    		
    		className: 'col-head-panel',
    		
    		locatedState: null,
    		
    		moveState: null,
    		
    		initialize: function() {
    			if (!cache.TempProp.isFrozen) {
    				this.delegateEvents({
    					
    					'mousedown .col-head-item': 'locatedHandle',
    					
    					'mousemove .col-head-item': 'moveHandle'
    				});
    			}
    			Backbone.on('event:colsHeadContainer:relaseSpaceEffect', this.relaseSpaceEffect, this);
    			Backbone.on('event:colWidthAdjust', this.colWidthAdjust, this);
    			Backbone.on('event:restoreHideCols', this.restoreHideCols, this);
    			Backbone.on('event:colsHeadContainer:setMouseState', this.setMouseState, this);
    			
    			this.colNumber = 0;
    			this.listenTo(headItemCols, 'add', this.addColsHeadContainer);
    
    			this.moveState = this.commonMoveState;
    			this.locatedState = this.selectLocatedState;
    		},
    		
    		render: function() {
    			var i = 0,
    				modelsHeadLineColList,
    				modelsHeadLineColRegionList,
    				len,
    				activeModelList,
    				modelList = headItemCols;
    			modelsHeadLineColList = modelsHeadLineColRegionList = modelList.models;
    			if (cache.TempProp.isFrozen) {
    				this.currentRule = cache.CurrentRule;
    				if (this.currentRule.displayPosition.endIndex !== undefined) {
    					modelsHeadLineColRegionList = modelsHeadLineColList.slice(this.currentRule.displayPosition.startIndex, this.currentRule.displayPosition.endColIndex);
    				} else {
    					modelsHeadLineColRegionList = modelsHeadLineColList.slice(this.currentRule.displayPosition.startIndex);
    				}
    			}
    
    			len = modelsHeadLineColRegionList.length;
    			for (; i < len; i++) {
    				if (!modelsHeadLineColRegionList[i].get('hidden')) {
    					this.addColsHeadContainer(modelsHeadLineColRegionList[i]);
    				}
    				this.colNumber++;
    			}
    			//ensure y or n has exist active model,
    			//if exist , the first model will be not active this.
    			activeModelList = modelList.where({
    				'activeState': true
    			});
    			if (activeModelList.length === 0) {
    				modelsHeadLineColList[0].set('activeState', true);
    			}
    			return this;
    		},
    		moveHandle: function(event) {
    			this.moveState && this.moveState(event);
    		},
    		locatedHandle: function(event) {
    			this.locatedState(event);
    		},
    		setMouseState: function(type, state) {
    			if (state !== null) {
    				this[type] = this[state];
    			} else {
    				this[type] = null;
    			}
    		},
    
    		selectLocatedState: function(e) {
    			//拖拽视图
    			if (this._isAdjustable(e) && !e.shiftKey && !cache.protectState) {
    				this.spaceEffect(e);
    				return;
    			}
    			//选中视图
    			var select = selectRegions.getModelByType('selected'),
    				containerId = cache.containerId,
    				mousePosi;
    
    			mousePosi = this._getRelativePosi(event.clientX);
    			this.adjustLocatedModel(mousePosi, select, e.shiftKey);
    			Backbone.trigger('event:cellsContainer:setMouseState', 'moveState', 'selectMoveState');
    			Backbone.trigger('event:colsHeadContainer:setMouseState', 'moveState', 'selectMoveState');
    		},
    
    		dataSourceLocatedState: function(event) {
    			var select = selectRegions.getModelByType('datasource'),
    				mousePosi;
    			if (typeof select === 'undefined') {
    				select = new SelectRegionModel();
    				select.set('selectType', 'datasource');
    				selectRegions.add(select);
    			}
    			mousePosi = this._getRelativePosi(event.clientX);
    			this.adjustLocatedModel(mousePosi, select, event.shiftKey);
    			Backbone.trigger('event:cellsContainer:setMouseState', 'moveState', 'dataSourceMoveState');
    			Backbone.trigger('event:colsHeadContainer:setMouseState', 'moveState', 'dataSourceMoveState');
    		},
    
    		ruleSourceLocatedState: function(event) {
    			var select = selectRegions.getModelByType('rulesource'),
    				mousePosi;
    			if (typeof select === 'undefined') {
    				select = new SelectRegionModel();
    				select.set('selectType', 'rulesource');
    				selectRegions.add(select);
    			}
    			mousePosi = this._getRelativePosi(event.clientX);
    			this.adjustLocatedModel(mousePosi, select, event.shiftKey);
    			Backbone.trigger('event:cellsContainer:setMouseState', 'moveState', 'ruleSourceMoveState');
    			Backbone.trigger('event:colsHeadContainer:setMouseState', 'moveState', 'ruleSourceMoveState');
    		},
    		selectMoveState: function(e) {
    			var select = selectRegions.getModelByType('selected'),
    				mousePosi,
    				tempPosi,
    				colIndex;
    			mousePosi = this._getRelativePosi(e.clientX);
    			colIndex = binary.modelBinary(mousePosi, gridColList, 'left', 'width');
    			tempPosi = select.set('tempPosi.mouseColIndex', colIndex);
    		},
    		dataSourceMoveState: function(event) {
    			var select = selectRegions.getModelByType('datasource'),
    				mousePosi,
    				tempPosi,
    				colIndex;
    			mousePosi = this._getRelativePosi(event.clientX);
    			colIndex = binary.modelBinary(mousePosi, gridColList, 'left', 'width');
    			tempPosi = select.set('tempPosi.mouseColIndex', colIndex);
    		},
    		ruleSourceMoveState: function(event) {
    			var select = selectRegions.getModelByType('rulesource'),
    				mousePosi,
    				colIndex;
    			mousePosi = this._getRelativePosi(event.clientX);
    			colIndex = binary.modelBinary(mousePosi, gridColList, 'left', 'width');
    			select.set('tempPosi.mouseColIndex', colIndex);
    		},
    		commonMoveState: function(e) {
    			e.currentTarget.style.cursor = this._isAdjustable(e) === true && !cache.protectState ? 'col-resize' : '';
    		},
    		adjustLocatedModel: function(posi, select, continuous) {
    			var modelCell,
    				startColIndex,
    				endColIndex,
    				wholePosi,
    				temp;
    			//this model index of headline
    			endColIndex = binary.modelBinary(posi, gridColList, 'left', 'width');
    			wholePosi = select.get('wholePosi');
    			if (continuous) {
    				startColIndex = headItemCols.getIndexByAlias(wholePosi.startX);
    			} else {
    				startColIndex = endColIndex;
    			}
    			select.set('tempPosi', {
    				initColIndex: startColIndex,
    				initRowIndex: 'MAX',
    				mouseColIndex: endColIndex,
    				mouseRowIndex: 0
    			});
    		},
    		
    		_isAdjustable: function(e) {
    			var overEl = this.itemEl || e.currentTarget;
    			return e.pageX - $(overEl).offset().left > overEl.clientWidth - config.System.effectDistanceCol ? true : false;
    		},
    		_getRelativePosi: function(posi) {
    			var containerId = cache.containerId;
    			return posi - $('#' + containerId).offset().left - config.System.outerLeft + cache.viewRegion.scrollLeft;
    		},
    		
    		spaceEffect: function(e) {
    			
    			this.itemEl = e.currentTarget;
    			
    			this.$itemEl = $(this.itemEl);
    			
    			this.cacheItemElOffsetWidth = this.itemEl.offsetWidth;
    			
    			this.$lockData = $('.col-head-item:gt(' + this.$itemEl.index() + ')', this.el);
    			
    			this.$tempSpaceContainer = $('<div/>').addClass('temp-space-container').html(this.$lockData);
    			this.$el.append(this.$tempSpaceContainer);
    			Backbone.trigger('event:screenContainer:mouseMoveHeadContainer', {
    					spaceMouse: this.itemEl.clientWidth - e.offsetX,
    					offsetleftByRight: this.itemEl.clientWidth + this.$itemEl.offset().left,
    					self: this
    				},
    				this.moveEvent);
    			this.colsSpaceLineContainer = new ColsSpaceLineContainer({
    				boxAttributes: {
    					left: this.itemEl.offsetLeft + this.itemEl.clientWidth
    				}
    			});
    			$('.line-container').append(this.colsSpaceLineContainer.render().el);
    		},
    		
    		relaseSpaceEffect: function(e) {
    			var i = 0,
    				itemElIndex,
    				width,
    				diffDistance;
    			if (!this.$lockData) {
    				return;
    			}
    			itemElIndex = headItemCols.getIndexByAlias(this.$itemEl.data('alias'));
    			diffDistance = this.itemEl.offsetWidth - this.cacheItemElOffsetWidth;
    			width = diffDistance + headItemCols.models[itemElIndex].get('width');
    			this.colWidthAdjust(itemElIndex, width);
    			//first element
    			this.$el.append(this.$lockData);
    			this.$tempSpaceContainer.remove();
    			this.itemEl = this.$itemEl = this.$lockData = null;
    		},
    		colWidthAdjust: function(itemElIndex, width) {
    			var diffDistance = width - headItemCols.models[itemElIndex].get('width');
    			this.adjustHeadLine(itemElIndex, diffDistance);
    			this.adjustCells(itemElIndex, diffDistance);
    			this.adjustSelectRegion(itemElIndex, diffDistance);
    			this.requstAdjust(itemElIndex, width);
    			Backbone.trigger('event:cellsContainer:adaptWidth');
    			Backbone.trigger('event:colsAllHeadContainer:adaptWidth');
    		},
    		restoreHideCols: function() {
    			var headItemColList = headItemCols.models,
    				len = headItemColList.length,
    				i = 0;
    			for (; i < len; i++) {
    				if (headItemColList[i].get('hidden')) {
    					this.addColsHeadContainer(headItemColList[i]);
    				}
    			}
    		},
    		
    		requstAdjust: function(colIndex, offset) {
    			var colSort = headItemCols.models[colIndex].get('sort');
    			send.PackAjax({
    				url: config.url.col.adjust,
    				data: JSON.stringify({
    					sheetId: '1',
    					col: colSort,
    					offset: offset
    				})
    			});
    		},
    		
    		moveEvent: function(e) {
    			var transData = e.data,
    				mouseSpace = e.pageX + transData.spaceMouse,
    				itemElWidth = parseInt(mouseSpace - transData.self.$itemEl.offset().left, 0);
    			if (itemElWidth < config.System.effectDistanceCol) {
    				return;
    			}
    			transData.self.$itemEl.css('width', itemElWidth);
    			transData.self.$tempSpaceContainer.css('left', parseInt(mouseSpace - transData.offsetleftByRight, 0));
    			transData.self.colsSpaceLineContainer.attributesRender({
    				left: parseInt(mouseSpace - transData.self.$el.offset().left, 0)
    			});
    		},
    		
    		addColsHeadContainer: function(modelHeadItemCol) {
    			this.headItemColContainer = new HeadItemColContainer({
    				model: modelHeadItemCol
    			});
    			this.$el.append(this.headItemColContainer.render().el);
    		},
    		
    		createHeadItemCol: function() {
    			headItemCols.add(this.newAttrCol());
    		},
    		
    		newAttrCol: function() {
    			var currentObject;
    			currentObject = {
    				alias: (this.colNumber + 1).toString(),
    				left: this.colNumber * config.User.cellWidth,
    				width: config.User.cellWidth - 1,
    				displayName: getDisplayName.getColDisplayName(this.colNumber)
    			};
    			return currentObject;
    		},
    		
    		callView: function(name) {
    			var self = this;
    			return function(callback) {
    				self[name] = callback;
    			};
    		},
    		
    		adjustHeadLine: function(index, pixel) {
    			var i,
    				len,
    				headLineList,
    				gridLineList,
    				tempWidth,
    				tempLeft;
    			headLineList = headItemCols.models;
    			tempWidth = headLineList[index].get('width');
    			headLineList[index].set('width', tempWidth + pixel);
    			len = headLineList.length;
    			for (i = index + 1; i < len; i++) {
    				tempLeft = headLineList[i].get('left');
    				headLineList[i].set('left', tempLeft + pixel);
    			}
    		},
    		
    		adjustCells: function(index, pixel) {
    			var passAdjustColCells, //经过调整列cells
    				adjustCells, //其余需要调整cells
    				loadColIndex,
    				loadRegion,
    				i,
    				j,
    				grilLineLen,
    				len;
    			passAdjustColCells = cells.getCellsByColIndex(index, index);
    			len = passAdjustColCells.length;
    			for (i = 0; i < len; i++) {
    				passAdjustColCells[i].set('physicsBox.width', passAdjustColCells[i].get('physicsBox').width + pixel);
    			}
    			grilLineLen = headItemCols.length;
    			adjustCells = cells.getCellsInStartColRegion(index + 1, grilLineLen - 1);
    			len = adjustCells.length;
    			for (j = 0; j < len; j++) {
    				adjustCells[j].set('physicsBox.left', adjustCells[j].get('physicsBox').left + pixel);
    			}
    		},
    		
    		adjustSelectRegion: function(index, pixel) {
    			var startColAlias,
    				endColAlias,
    				startColIndex,
    				endColIndex,
    				selectRegionModel,
    				siderLineColModel,
    				cacheWidth,
    				cacheLeft;
    			selectRegionModel = selectRegions.models[0];
    			//ps:修改
    			startColAlias = selectRegionModel.get('wholePosi').startX;
    			endColAlias = selectRegionModel.get('wholePosi').endX;
    			startColIndex = headItemCols.getIndexByAlias(startColAlias);
    			endColIndex = headItemCols.getIndexByAlias(endColAlias);
    
    			if (endColIndex < index) {
    				return;
    			}
    			siderLineColModel = siderLineCols.models[0];
    			if (startColIndex <= index) {
    				cacheWidth = selectRegionModel.get("physicsBox").width;
    				selectRegionModel.set("physicsBox.width", cacheWidth + pixel);
    				siderLineColModel.set("width", cacheWidth + pixel);
    			} else {
    				cacheLeft = selectRegionModel.get("physicsBox").left;
    				selectRegionModel.set("physicsBox.left", cacheLeft + pixel);
    				siderLineColModel.set("left", cacheLeft + pixel);
    			}
    		},
    		
    		destroy: function() {
    			Backbone.off('call:colsHeadContainer');
    			Backbone.off('event:colsHeadContainer:relaseSpaceEffect');
    			Backbone.off('event:colWidthAdjust');
    			Backbone.off('event:restoreHideCols');
    			Backbone.off('event:colsHeadContainer:setMouseState');
    			this.undelegateEvents();
    			this.headItemColContainer.destroy();
    			this.remove();
    		}
    	});
    	return ColsHeadContainer;
    });
    define('views/siderLineColContainer',function() {
    	
    	var Backbone = require('lib/backbone'),
    		cache = require('basic/tools/cache'),
    		util = require('basic/util/clone'),
    		headItemCols = require('collections/headItemCol');
    
    
    	
    	var SiderLineColContainer = Backbone.View.extend({
    		
    		className: 'col-head-line',
    		
    		initialize: function() {
    			var modelList;
    			this.listenTo(this.model, 'change', this.render);
    			this.currentRule = util.clone(cache.CurrentRule);
    			modelList = headItemCols;
    			this.userViewLeft = cache.TempProp.isFrozen ? modelList.getModelByAlias(cache.UserView.colAlias).get('left') : 0;
    			this.offsetLeft = cache.TempProp.isFrozen ? (this.currentRule.displayPosition.offsetLeft || 0) : 0;
    		},
    		
    		render: function() {
    			var modelJSON = this.model.toJSON();
    			this.$el.css({
    				left: modelJSON.left - this.offsetLeft - this.userViewLeft,
    				width: modelJSON.width - 2
    			});
    			return this;
    		},
    		
    		destroy: function() {
    			this.remove();
    		}
    	});
    	return SiderLineColContainer;
    });
    define('views/colsAllHeadContainer',function() {
    	
    
    	var Backbone = require('lib/backbone'),
    		siderLineCols = require('collections/siderLineCol'),
    		headItemCols = require('collections/headItemCol'),
    		config = require('spreadsheet/config'),
    		ColsHeadContainer = require('views/colsHeadContainer'),
    		SiderLineColContainer = require('views/siderLineColContainer'),
    		ColsAllHeadContainer;
    
    	
    	ColsAllHeadContainer = Backbone.View.extend({
    		
    		className: 'col-head-bg col-head-height',
    		
    		initialize: function(options) {
    			Backbone.on('call:colsAllHeadContainer', this.callColsAllHeadContainer, this);
    			Backbone.on('event:colsAllHeadContainer:adaptWidth', this.adaptWidth, this);
    			this.listenTo(siderLineCols, 'add', this.addSiderLineCol);
    			this.boxAttributes = options.boxAttributes;
    		},
    		
    		render: function() {
    			var modelSiderLineColList = siderLineCols.models,
    				len = modelSiderLineColList.length,
    				i;
    			this.colsHeadContainer = new ColsHeadContainer();
    			this.attributesRender(this.boxAttributes);
    			this.$el.append(this.colsHeadContainer.render().el);
    			if (len === 0) {
    				this.createSiderLineCol();
    			} else {
    				for (i = len - 1; i >= 0; i--) {
    					this.addSiderLineCol(modelSiderLineColList[i]);
    				}
    			}
    			return this;
    		},
    		
    		callColsAllHeadContainer: function(receiveFunc) {
    			receiveFunc(this);
    		},
    		
    		attributesRender: function(newAttributes) {
    			if (newAttributes.width !== -1) {
    				this.$el.css({
    					'width': newAttributes.width
    				});
    			}
    		},
    		adaptWidth: function() {
    			var len = headItemCols.length,
    				width = headItemCols.models[len - 1].get('width'),
    				left = headItemCols.models[len - 1].get('left');
    			this.$el.css({
    				'width': left + width
    			});
    		},
    		
    		addSiderLineCol: function(modelSiderLineCol) {
    			this.siderLineColContainer = new SiderLineColContainer({
    				model: modelSiderLineCol
    			});
    			this.$el.append(this.siderLineColContainer.render().el);
    		},
    		
    		createSiderLineCol: function() {
    			siderLineCols.add({
    				left: 0,
    				width: config.User.cellWidth - 1
    			});
    		},
    		destroy: function() {
    			Backbone.off('call:colsAllHeadContainer');
    			Backbone.off('event:colsAllHeadContainer:adaptWidth');
    			this.colsHeadContainer.destroy();
    			this.remove();
    		}
    	});
    	return ColsAllHeadContainer;
    
    });
    define('views/colsPanelContainer',function() {
    	
    	var $ = require('lib/jquery'),
    		_ = require('lib/underscore'),
    		Backbone = require('lib/backbone'),
    		cache = require('basic/tools/cache'),
    		config = require('spreadsheet/config'),
    		util = require('basic/util/clone'),
    		headItemCols = require('collections/headItemCol'),
    		ColsAllHeadContainer = require('views/colsAllHeadContainer'),
    		ColsPanelContainer;
    
    	
    	ColsPanelContainer = Backbone.View.extend({
    		
    		className: 'col-head-container',
    		
    		initialize: function(options) {
    			var modelsHeadLineColList,
    				modelsHeadLineColRegionList,
    				modelHeadLinelastCol,
    				len;
    			Backbone.on('call:colsPanelContainer', this.colsPanelContainer, this);
    			Backbone.on('event:colsPanelContainer:destroy', this.destroy, this);
    			Backbone.trigger('event:colsPanelContainer:adjustWidth', this.adjustWidth, this);
    
    			
    			this.boxModel = {};
    			this.cacheDiffDistance = 0;
    			this.currentRule = cache.CurrentRule;
    			this.boxAttributes = this.currentRule.boxAttributes;
    			modelsHeadLineColRegionList = modelsHeadLineColList = headItemCols.models;
    			if (cache.TempProp.isFrozen) {
    				if (this.currentRule.displayPosition.endIndex) {
    					modelsHeadLineColRegionList = modelsHeadLineColList.slice(this.currentRule.displayPosition.startIndex, this.currentRule.displayPosition.endIndex);
    				} else {
    					modelsHeadLineColRegionList = modelsHeadLineColList.slice(this.currentRule.displayPosition.startIndex);
    				}
    			}
    			len = modelsHeadLineColRegionList.length;
    			if (len === 0) {
    				this.boxModel.width = 0;
    				return;
    			}
    			if (this.currentRule.displayPosition.endRowIndex === undefined) {
    				Backbone.on('event:changeSidebarContainer', this.shrink, this);
    			}
    			//the page is reload excel, len will be appoint num ,will be not necessarily start A,1 
    			modelHeadLinelastCol = modelsHeadLineColRegionList[len - 1];
    			this.boxModel.width = this.currentRule.autoScroll ? modelHeadLinelastCol.get('left') + modelHeadLinelastCol.get('width') - modelsHeadLineColRegionList[0].get('left') : -1;
    		},
    		
    		render: function() {
    			this.colsAllHeadContainer = new ColsAllHeadContainer({
    				boxAttributes: {
    					width: this.boxModel.width
    				}
    			});
    			this.attributesRender(this.boxAttributes);
    			this.$el.html(this.colsAllHeadContainer.render().el);
    			return this;
    		},
    		
    		colsPanelContainer: function(receiveFunc) {
    			receiveFunc(this);
    		},
    		
    		attributesRender: function(newAttributes) {
    			if (newAttributes.width === -1) {
    				this.$el.css({
    					'width': 0
    				});
    			} else {
    				this.$el.css({
    					'width': newAttributes.width
    				});
    			}
    			if (newAttributes.style) {
    				this.$el.addClass(newAttributes.style);
    			}
    		},
    		shrink:function(){
    			if(cache.sidebarState){
    				this.$el.width(this.boxAttributes.width - config.sidebarWidth);
    			}else{
    				this.$el.width(this.boxAttributes.width);
    			}
    		},
    		
    		scrollToPosition: function(position) {
    			this.$el.scrollLeft(position);
    		},
    		
    		destroy: function() {
    			if (this.unsubscribe) {
    				this.unsubscribe('mainContainer','transversePublish');
    			}
    			Backbone.off('call:colsPanelContainer');
    			Backbone.off('event:colsPanelContainer:destroy');
    			this.colsAllHeadContainer.destroy();
    			this.remove();
    		}
    	});
    	return ColsPanelContainer;
    });
    define('views/rowsSpaceLineContainer',function() {
    	
    	var Backbone = require('lib/backbone');
    
    	
    	var RowsSpaceLineContainer = Backbone.View.extend({
    		
    		className: 'row-space-container',
    		
    		initialize: function(allAttributes) {
    			Backbone.on('call:rowsSpaceLineContainer', this.callRowsSpaceLineContainer, this);
    			Backbone.on('event:rowsSpaceLineContainer:destroy', this.destroy, this);
    			this.boxAttributes = allAttributes.boxAttributes;
    		},
    		
    		render: function() {
    			this.attributesRender(this.boxAttributes);
    			return this;
    		},
    		
    		callRowsSpaceLineContainer: function(receiveFunc) {
    			receiveFunc(this);
    		},
    		
    		attributesRender: function(newAttributes) {
    			this.$el.css({
    				'top': newAttributes.top
    			});
    		},
    		
    		destroy: function() {
    			this.remove();
    		}
    	});
    	return RowsSpaceLineContainer;
    });
    define('views/headItemRowContainer',function() {
    	
    	var $ = require('lib/jquery'),
    		_ = require('lib/underscore'),
    		Backbone = require('lib/backbone'),
    		getTemplate = require('basic/tools/template'),
    		headItemRows = require('collections/headItemRow'),
    		cache = require('basic/tools/cache'),
    		util = require('basic/util/clone'),
    		config = require('spreadsheet/config');
    	
    	var HeadItemRowContainer = Backbone.View.extend({
    		
    		className: 'row-head-item',
    		
    		initialize: function(option) {
    			this.listenTo(this.model, 'change:activeState', this.toggleActive);
    			this.listenTo(this.model, 'change:top', this.changeTop);
    			this.listenTo(this.model, 'change:height', this.changeHeight);
    			this.listenTo(this.model, 'change:displayName', this.changeDisplayName);
    			this.listenTo(this.model, 'destroy', this.remove);
    			this.offsetTop = cache.TempProp.isFrozen ? (option.frozenTop || 0) : 0;
    			this.reduceUserView = option.reduceUserView;
    			this.endIndex = option.endIndex;
    
    			if (cache.TempProp.isFrozen !== true || this.endIndex === undefined) {
    				this.listenTo(this.model, 'change:isView', this.destroy);
    			}
    		},
    		
    		render: function() {
    			this.template = getTemplate('ROWHEADTEMPLATE');
    			this.changeTop();
    			this.changeHeight();
    			this.$el.html(this.template(this.model.toJSON())).data('alias', this.model.get('alias'));
    			this.toggleActive();
    			return this;
    		},
    		
    		toggleActive: function() {
    			this.$el.toggleClass("active", this.model.toJSON().activeState);
    		},
    		
    		changeTop: function() {
    			var userViewTop = 0,
    				userViewModel;
    			if (cache.TempProp.isFrozen) {
    				userViewModel = headItemRows.getModelByAlias(cache.UserView.rowAlias);
    				userViewTop = userViewModel.toJSON().top;
    			}
    			this.$el.css({
    				top: this.model.toJSON().top - this.offsetTop - userViewTop
    			});
    		},
    		
    		changeHeight: function() {
    			this.$el.css({
    				height: this.model.toJSON().height
    			});
    		},
    		changeDisplayName: function() {
    			this.$el.children('.item').html(this.model.get('displayName'));
    		},
    		destroy: function() {
    			this.remove();
    		}
    	});
    	return HeadItemRowContainer;
    });
    define('views/rowsHeadContainer',function() {
    	
    	var $ = require('lib/jquery'),
    		_ = require('lib/underscore'),
    		Backbone = require('lib/backbone'),
    		config = require('spreadsheet/config'),
    		cache = require('basic/tools/cache'),
    		binary = require('basic/util/binary'),
    		send = require('basic/tools/send'),
    		getDisplayName = require('basic/tools/getdisplayname'),
    		headItemRows = require('collections/headItemRow'),
    		headItemCols = require('collections/headItemCol'),
    		cells = require('collections/cells'),
    		selectRegions = require('collections/selectRegion'),
    		siderLineRows = require('collections/siderLineRow'),
    		siderLineCols = require('collections/siderLineCol'),
    		RowsSpaceLineContainer = require('views/rowsSpaceLineContainer'),
    		HeadItemRowContainer = require('views/headItemRowContainer'),
    		SelectRegionModel = require('models/selectRegion'),
    		observerPattern = require('basic/util/observer.pattern'),
    		loadRecorder = require('basic/tools/loadrecorder'),
    		gridRowList = headItemRows.models,
    		gridColList = headItemCols.models,
    		RowsHeadContainer;
    
    
    	
    	RowsHeadContainer = Backbone.View.extend({
    		
    		className: 'row-head-panel',
    		
    		initialize: function(options) {
    			if (!cache.TempProp.isFrozen) {
    				this.delegateEvents({
    					'mousedown .row-head-item': 'locatedHandle',
    					'mousemove .row-head-item': 'moveHandle'
    				});
    			}
    			Backbone.on('event:rowsHeadContainer:relaseSpaceEffect', this.relaseSpaceEffect, this);
    			Backbone.on('event:rowHeightAdjust', this.rowHeightAdjust, this);
    			Backbone.on('event:rowsHeadContainer:setMouseState', this.setMouseState, this);
    			Backbone.on('event:rowsHeadContainer:destroy', this.destroy, this);
    			this.rowNumber = 0;
    
    			this.currentRule = cache.CurrentRule;
    
    			if (this.currentRule.displayPosition.endIndex === undefined) {
    				this.listenTo(headItemRows, 'add', this.addRowsHeadContainer);
    				//订阅滚动行视图还原
    				observerPattern.buildSubscriber(this);
    				this.subscribe('mainContainer', 'restoreRowView', 'restoreRowView');
    			}
    			this.moveState = this.commonMoveState;
    			this.locatedState = this.selectLocatedState;
    		},
    		
    		render: function() {
    			var i = 0,
    				modelsHeadLineRowList,
    				modelsHeadLineRowRegionList,
    				len,
    				activeModelList,
    				modelList = headItemRows;
    			modelsHeadLineRowList = modelsHeadLineRowRegionList = modelList.models;
    			if (cache.TempProp.isFrozen) {
    				if (this.currentRule.displayPosition.endIndex !== undefined) {
    					modelsHeadLineRowRegionList = modelsHeadLineRowList.slice(this.currentRule.displayPosition.startIndex, this.currentRule.displayPosition.endIndex);
    				} else {
    					modelsHeadLineRowRegionList = modelsHeadLineRowList.slice(this.currentRule.displayPosition.startIndex);
    				}
    			}
    			len = modelsHeadLineRowRegionList.length;
    			for (; i < len; i++) {
    				this.addRowsHeadContainer(modelsHeadLineRowRegionList[i]);
    				this.rowNumber++;
    			}
    			//ensure y or n has exist active model,
    			//if exist , the first model will be not active this.
    			activeModelList = modelList.where({
    				'activeState': true
    			});
    			if (activeModelList.length === 0) {
    				modelsHeadLineRowList[0].set('activeState', true);
    			}
    			return this;
    		},
    		moveHandle: function(event) {
    			this.moveState && this.moveState(event);
    		},
    		locatedHandle: function(event) {
    			this.locatedState(event);
    		},
    		setMouseState: function(type, state) {
    			if (state !== null) {
    				this[type] = this[state];
    			} else {
    				this[type] = null;
    			}
    		},
    		selectLocatedState: function(e) {
    			//拖拽视图
    			if (this._isAdjustable(e) && !e.shiftKey && !cache.protectState) {
    				this.spaceEffect(e);
    				return;
    			}
    			//选中视图
    			var select = selectRegions.getModelByType('selected'),
    				containerId = cache.containerId,
    				mousePosi;
    
    			mousePosi = this._getRelativePosi(event.clientY);
    			this.adjustLocatedModel(mousePosi, select, e.shiftKey);
    			Backbone.trigger('event:cellsContainer:setMouseState', 'moveState', 'selectMoveState');
    			Backbone.trigger('event:rowsHeadContainer:setMouseState', 'moveState', 'selectMoveState');
    		},
    		dataSourceLocatedState: function(event) {
    			var select = selectRegions.getModelByType('datasource'),
    				mousePosi;
    			if (typeof select === 'undefined') {
    				select = new SelectRegionModel();
    				select.set('selectType', 'datasource');
    				selectRegions.add(select);
    			}
    			mousePosi = this._getRelativePosi(event.clientY);
    			this.adjustLocatedModel(mousePosi, select, event.shiftKey);
    			Backbone.trigger('event:cellsContainer:setMouseState', 'moveState', 'dataSourceMoveState');
    			Backbone.trigger('event:rowsHeadContainer:setMouseState', 'moveState', 'dataSourceMoveState');
    		},
    		ruleSourceLocatedState: function() {
    			var select = selectRegions.getModelByType('rulesource'),
    				mousePosi;
    			if (typeof select === 'undefined') {
    				select = new SelectRegionModel();
    				select.set('selectType', 'rulesource');
    				selectRegions.add(select);
    			}
    			mousePosi = this._getRelativePosi(event.clientY);
    			this.adjustLocatedModel(mousePosi, select, event.shiftKey);
    			Backbone.trigger('event:cellsContainer:setMouseState', 'moveState', 'ruleSourceMoveState');
    			Backbone.trigger('event:rowsHeadContainer:setMouseState', 'moveState', 'ruleSourceMoveState');
    		},
    		selectMoveState: function(e) {
    			var select = selectRegions.getModelByType('selected'),
    				mousePosi,
    				tempPosi,
    				rowIndex;
    			mousePosi = this._getRelativePosi(e.clientY);
    			rowIndex = binary.modelBinary(mousePosi, gridRowList, 'top', 'height');
    			tempPosi = select.set('tempPosi.mouseRowIndex', rowIndex);
    		},
    		dataSourceMoveState: function(event) {
    			var select = selectRegions.getModelByType('datasource'),
    				mousePosi,
    				tempPosi,
    				rowIndex;
    			mousePosi = this._getRelativePosi(event.clientY);
    			rowIndex = binary.modelBinary(mousePosi, gridRowList, 'top', 'height');
    			tempPosi = select.set('tempPosi.mouseRowIndex', rowIndex);
    		},
    		ruleSourceMoveState: function(event) {
    			var select = selectRegions.getModelByType('rulesource'),
    				mousePosi,
    				tempPosi,
    				rowIndex;
    			mousePosi = this._getRelativePosi(event.clientY);
    			rowIndex = binary.modelBinary(mousePosi, gridRowList, 'top', 'height');
    			tempPosi = select.set('tempPosi.mouseRowIndex', rowIndex);
    		},
    		commonMoveState: function(e) {
    			e.currentTarget.style.cursor = this._isAdjustable(e) === true && !cache.protectState ? 'row-resize' : '';
    		},
    		adjustLocatedModel: function(posi, select, continuous) {
    			var modelCell,
    				startRowIndex,
    				endRowIndex,
    				wholePosi,
    				temp;
    			//this model index of headline
    			endRowIndex = binary.modelBinary(posi, gridRowList, 'top', 'height');
    			wholePosi = select.get('wholePosi');
    			if (continuous) {
    				startRowIndex = headItemRows.getIndexByAlias(wholePosi.startY);
    			} else {
    				startRowIndex = endRowIndex;
    			}
    
    			select.set('tempPosi', {
    				initColIndex: 'MAX',
    				initRowIndex: startRowIndex,
    				mouseColIndex: 0,
    				mouseRowIndex: endRowIndex
    			});
    		},
    		
    		_isAdjustable: function(e) {
    			var overEl = this.itemEl || e.currentTarget;
    			return e.pageY - $(overEl).offset().top > overEl.clientHeight - config.System.effectDistanceRow ? true : false;
    		},
    		_getRelativePosi: function(posi) {
    			var containerId = cache.containerId;
    			return posi - $('#' + containerId).offset().top - config.System.outerTop + cache.viewRegion.scrollTop;
    		},
    		
    		spaceEffect: function(e) {
    			this.itemEl = e.currentTarget;
    			this.cacheItemElOffsetHeight = this.itemEl.offsetHeight;
    			this.$itemEl = $(this.itemEl);
    			this.$lockData = $('.row-head-item:gt(' + this.$itemEl.index() + ')', this.el);
    			this.$tempSpaceContainer = $('<div/>').addClass('temp-space-container').html(this.$lockData);
    			this.$el.append(this.$tempSpaceContainer);
    			Backbone.trigger('event:screenContainer:mouseMoveHeadContainer', {
    				spaceMouse: this.itemEl.clientHeight - e.offsetY,
    				// from currentTarget rightBorder caculation distance to document
    				offsetTopByBottom: this.itemEl.clientHeight + this.$itemEl.offset().top,
    				self: this
    			}, this.moveEvent);
    
    			this.rowsSpaceLineContainer = new RowsSpaceLineContainer({
    				boxAttributes: {
    					top: this.itemEl.offsetTop + this.itemEl.clientHeight
    				}
    			});
    			$('.line-container').append(this.rowsSpaceLineContainer.render().el);
    		},
    		
    		moveEvent: function(e) {
    			var transData = e.data,
    				mouseSpace = e.pageY + transData.spaceMouse,
    				itemElHeight = parseInt(mouseSpace - transData.self.$itemEl.offset().top, 0);
    			if (itemElHeight < config.System.effectDistanceRow) {
    				return;
    			}
    			transData.self.$itemEl.css('height', itemElHeight);
    			transData.self.$tempSpaceContainer.css('top', parseInt(mouseSpace - transData.offsetTopByBottom, 0));
    			transData.self.rowsSpaceLineContainer.attributesRender({
    				top: parseInt(mouseSpace - transData.self.$el.offset().top, 0)
    			});
    		},
    		
    		relaseSpaceEffect: function(e) {
    			var i = 0,
    				len,
    				height,
    				modelList,
    				itemElIndex,
    				diffDistance,
    				currentEl;
    			if (!this.$lockData) {
    				return;
    			}
    			modelList = headItemRows.models;
    			len = modelList.length;
    			itemElIndex = headItemRows.getIndexByAlias(this.$itemEl.data('alias'));
    			diffDistance = this.itemEl.offsetHeight - this.cacheItemElOffsetHeight;
    			height = diffDistance + headItemRows.models[itemElIndex].get('height');
    			this.$el.append(this.$lockData);
    			this.$tempSpaceContainer.remove();
    			this.itemEl = this.$itemEl = this.$lockData = null;
    			this.rowHeightAdjust(itemElIndex, height);
    		},
    		rowHeightAdjust: function(itemElIndex, height) {
    			var diffDistance = height - headItemRows.models[itemElIndex].get('height'),
    				posi = headItemRows.models[itemElIndex].get('top');
    			this.adjustHeadLine(itemElIndex, diffDistance);
    			this.adjustCells(itemElIndex, diffDistance);
    			this.adjustSelectRegion(itemElIndex, diffDistance);
    			this.requstAdjust(itemElIndex, height);
    			Backbone.trigger('event:rowsAllHeadContainer:adaptHeight');
    			Backbone.trigger('event:cellsContainer:adaptHeight');
    			Backbone.trigger('event:mainContainer:adaptRowHeightChange', posi, diffDistance);
    		},
    		
    		requstAdjust: function(rowIndex, offset) {
    			var rowSort = headItemRows.models[rowIndex].get('sort');
    			send.PackAjax({
    				url: config.url.row.adjust,
    				data: JSON.stringify({
    					sheetId: '1',
    					row: rowSort,
    					offset: offset
    				})
    			});
    		},
    		
    		restoreRowView: function(model, direction) {
    			var endIndex = this.currentRule.displayPosition.endIndex,
    				startIndex = this.currentRule.displayPosition.startIndex,
    				headItemRowList = headItemRows.models,
    				top = model.get('top');
    			//判断行是否不再当前区域内
    			if (cache.TempProp.isFrozen) {
    				if (top < headItemRowList[startIndex].get('top')) {
    					return;
    				}
    				if (typeof endIndex === 'number') {
    					if (endIndex === 0) {
    						return;
    					}
    					if (top > headItemRowList[endIndex - 1].get('top')) {
    						return;
    					}
    				}
    			}
    			this.addRowsHeadContainer(model, direction);
    		},
    		
    		addRowsHeadContainer: function(modelHeadItemRow, direction) {
    			this.headItemRowContainer = new HeadItemRowContainer({
    				model: modelHeadItemRow,
    				frozenTop: this.currentRule.displayPosition.offsetTop,
    				reduceUserView: this.currentRule.reduceUserView,
    				endIndex: this.currentRule.displayPosition.endIndex
    			});
    			if (direction !== 'up') {
    				this.$el.append(this.headItemRowContainer.render().el);
    			} else {
    				this.$el.prepend(this.headItemRowContainer.render().el);
    			}
    		},
    		
    		createHeadItemRow: function() {
    			headItemRows.add(this.newAttrRow());
    		},
    		
    		newAttrRow: function() {
    			var currentObject;
    			currentObject = {
    				alias: (this.rowNumber + 1).toString(),
    				top: this.rowNumber * 20,
    				height: 19,
    				displayName: getDisplayName.getRowDisplayName(this.rowNumber)
    			};
    			return currentObject;
    		},
    		
    		adjustHeadLine: function(index, pixel) {
    			var i,
    				len,
    				headLineList,
    				tempHeight,
    				tempTop;
    			headLineList = headItemRows.models;
    			tempHeight = headLineList[index].get('height');
    			headLineList[index].set('height', tempHeight + pixel);
    			len = headLineList.length;
    			for (i = index + 1; i < len; i++) {
    				tempTop = headLineList[i].get('top');
    				headLineList[i].set('top', tempTop + pixel);
    			}
    		},
    		
    		adjustCells: function(index, pixel) {
    			var passAdjustRowCells, //经过调整列cells
    				adjustCells, //其余需要调整cells
    				loadRowIndex,
    				loadRegion,
    				i, j, gridLineLen,
    				len,
    				cellList = cells;
    			passAdjustRowCells = cellList.getCellByRow(index, index);
    			len = passAdjustRowCells.length;
    			for (i = 0; i < len; i++) {
    				passAdjustRowCells[i].set('physicsBox.height', passAdjustRowCells[i].get('physicsBox').height + pixel);
    			}
    			gridLineLen = headItemRows.length;
    			adjustCells = cellList.getCellsInStartRowRegion(index + 1, gridLineLen - 1);
    			len = adjustCells.length;
    			for (j = 0; j < len; j++) {
    				adjustCells[j].set('physicsBox.top', adjustCells[j].get('physicsBox').top + pixel);
    			}
    		},
    		
    		adjustSelectRegion: function(index, pixel) {
    			var startRowIndex,
    				endRowIndex,
    				startRowAlias,
    				endRowAlias,
    				selectRegionModel,
    				siderLineRowModel,
    				cacheHeight,
    				cacheTop;
    			selectRegionModel = selectRegions.models[0];
    			startRowAlias = selectRegionModel.get('wholePosi').startY;
    			endRowAlias = selectRegionModel.get('wholePosi').endY;
    			startRowIndex = headItemRows.getIndexByAlias(startRowAlias);
    			endRowIndex = headItemRows.getIndexByAlias(endRowAlias);
    			if (endRowIndex < index) {
    				return;
    			}
    
    			siderLineRowModel = siderLineRows.models[0];
    			if (startRowIndex <= index) {
    				cacheHeight = selectRegionModel.get("physicsBox").height;
    				selectRegionModel.set("physicsBox.height", cacheHeight + pixel);
    				siderLineRowModel.set("height", cacheHeight + pixel);
    			} else {
    				cacheTop = selectRegionModel.get("physicsBox").top;
    				selectRegionModel.set("physicsBox.top", cacheTop + pixel);
    				siderLineRowModel.set("top", cacheTop + pixel);
    			}
    
    		},
    		
    		destroy: function() {
    			Backbone.off('event:rowsHeadContainer:destroy');
    			Backbone.off('call:rowsHeadContainer');
    			Backbone.off('event:rowsHeadContainer:relaseSpaceEffect');
    			Backbone.off('event:rowsHeadContainer:setMouseState');
    			Backbone.off('event:rowHeightAdjust');
    			this.undelegateEvents();
    			this.remove();
    		}
    	});
    	return RowsHeadContainer;
    });
    define('views/siderLineRowContainer',function() {
    	
    	var Backbone = require('lib/backbone'),
    		cache = require('basic/tools/cache'),
    		util = require('basic/util/clone'),
    		headItemRows = require('collections/headItemRow');
    	
    	var SiderLineRowContainer = Backbone.View.extend({
    		
    		className: 'row-head-line',
    		
    		initialize: function() {
    			var modelList;
    			this.listenTo(this.model, 'change', this.render);
    			this.currentRule = util.clone(cache.CurrentRule);
    			modelList = headItemRows;
    			this.userViewTop = cache.TempProp.isFrozen ? modelList.getModelByAlias(cache.UserView.rowAlias).get('top') : 0;
    			this.offsetTop = cache.TempProp.isFrozen ? (this.currentRule.displayPosition.offsetTop || 0) : 0;
    		},
    		
    		render: function() {
    			var modelJSON = this.model.toJSON();
    			this.$el.css({
    				top: modelJSON.top - this.offsetTop - this.userViewTop,
    				height: modelJSON.height - 2
    			});
    			return this;
    		},
    		
    		destroy: function() {
    			this.remove();
    		}
    	});
    	return SiderLineRowContainer;
    });
    define('views/rowsAllHeadContainer',function() {
    	
    	var $ = require('lib/jquery'),
    		_ = require('lib/underscore'),
    		clone = require('basic/util/clone'),
    		cache = require('basic/tools/cache'),
    		Backbone = require('lib/backbone'),
    		headItemRows = require('collections/headItemRow'),
    		siderLineRows = require('collections/siderLineRow'),
    		RowsHeadContainer = require('views/rowsHeadContainer'),
    		SiderLineRowContainer = require('views/siderLineRowContainer'),
    		headItemRowList = headItemRows.models;
    
    	
    
    	var RowsAllHeadContainer = Backbone.View.extend({
    		
    		className: 'row-head-bg row-head-width',
    		
    		initialize: function(options) {
    			Backbone.on('call:rowsAllHeadContainer', this.callRowsAllHeadContainer, this);
    			Backbone.on('event:rowsAllHeadContainer:adaptHeight', this.adaptHeight, this);
    			this.currentRule = clone.clone(cache.CurrentRule);
    
    			//记录冻结情况下导致视图移动大小
    			if (cache.TempProp.isFrozen === true) {
    				this.userViewTop = headItemRows.getModelByAlias(cache.UserView.rowAlias).get('top');
    				this.offsetTop = this.currentRule.displayPosition.offsetTop;
    			} else {
    				this.userViewTop = 0;
    				this.offsetTop = 0;
    			}
    			this.listenTo(siderLineRows, 'add', this.addSiderLineRow);
    			this.boxAttributes = options.boxAttributes;
    		},
    		
    		render: function() {
    			var modelSiderLineRowList = siderLineRows.models,
    				len = modelSiderLineRowList.length,
    				rowsHeadContainer, i;
    
    			rowsHeadContainer = new RowsHeadContainer();
    
    			this.attributesRender(this.boxAttributes);
    			this.$el.append(rowsHeadContainer.render().el);
    			if (len === 0) {
    				this.createSiderLineRow();
    			} else {
    				for (i = len - 1; i >= 0; i--) {
    					this.addSiderLineRow(modelSiderLineRowList[i]);
    				}
    			}
    			return this;
    		},
    		adaptHeight: function() {
    			var end = this.currentRule.displayPosition.endIndex,
    				start = this.currentRule.displayPosition.startIndex,
    				bottom = 0,
    				top = 0,
    				len, i,
    				start;
    
    
    			if (end === undefined) {
    				end = headItemRowList.length - 1;
    			}
    			start = start || 0;
    			
    			for (i = end -1 ; i >= start; i--) {
    				if (!headItemRowList[i].get('hidden')) {
    					top = headItemRowList[i].get('top') + headItemRowList[i].get('height');
    					bottom = headItemRowList[start].get('top');
    					this.$el.css({
    						'height': top - bottom - this.userViewTop
    					}); 
    					break;
    				}
    			}
    
    		},
    		
    		callRowsAllHeadContainer: function(receiveFunc) {
    			receiveFunc(this);
    		},
    		
    		attributesRender: function(newAttributes) {
    			if (newAttributes.height !== -1) {
    				this.$el.css({
    					'height': newAttributes.height
    				});
    			}
    		},
    		
    		addSiderLineRow: function(modelSiderLineRow) {
    			this.siderLineRowContainer = new SiderLineRowContainer({
    				model: modelSiderLineRow
    			});
    			this.$el.append(this.siderLineRowContainer.render().el);
    		},
    		
    		createSiderLineRow: function() {
    			siderLineRows.add({
    				top: 0,
    				height: config.User.cellHeight - 1
    			});
    		},
    		
    		destroy: function() {
    			Backbone.trigger('event:rowsHeadContainer:destroy');
    			Backbone.off('call:rowsAllHeadContainer');
    			this.siderLineRowContainer.destroy();
    			this.remove();
    		}
    	});
    	return RowsAllHeadContainer;
    });
    define('views/rowsPanelContainer',function() {
    	
    	var $ = require('lib/jquery'),
    		_ = require('lib/underscore'),
    		Backbone = require('lib/backbone'),
    		cache = require('basic/tools/cache'),
    		config = require('spreadsheet/config'),
    		util = require('basic/util/clone'),
    		headItemRows = require('collections/headItemRow'),
    		RowsAllHeadContainer = require('views/rowsAllHeadContainer'),
    		RowsPanelContainer;
    
    	
    	RowsPanelContainer = Backbone.View.extend({
    		
    		className: 'row-head-container',
    		
    		initialize: function(options) {
    			var modelsHeadLineRowList,
    				modelsHeadLineRowRegionList,
    				modellastHeadLineRow,
    				len;
    
    			//ps:监听selectRegion
    			Backbone.on('call:rowsPanelContainer', this.rowsPanelContainer, this);
    			Backbone.on('event:rowsPanelContainer:destroy', this.destroy, this);
    			this.boxModel = {};
    			this.currentRule = util.clone(cache.CurrentRule);
    			this.boxAttributes = this.currentRule.boxAttributes;
    			modelsHeadLineRowRegionList = modelsHeadLineRowList = headItemRows.models;
    
    			if (cache.TempProp.isFrozen) {
    				if (this.currentRule.displayPosition.endIndex) {
    					modelsHeadLineRowRegionList = modelsHeadLineRowList.slice(this.currentRule.displayPosition.startIndex, this.currentRule.displayPosition.endIndex);
    				} else {
    					modelsHeadLineRowRegionList = modelsHeadLineRowList.slice(this.currentRule.displayPosition.startIndex);
    				}
    			}
    			len = modelsHeadLineRowRegionList.length;
    			if (len === 0) {
    				this.boxModel.height =0;
    				return;
    			}
    			modellastHeadLineRow = modelsHeadLineRowList[len - 1];
    			this.boxModel.height = this.currentRule.autoScroll ? modellastHeadLineRow.get('top') + modellastHeadLineRow.get('height') - modelsHeadLineRowList[0].get('top') : -1;
    		},
    		
    		render: function() {
    			this.rowsAllHeadContainer = new RowsAllHeadContainer({
    				boxAttributes: {
    					height: this.boxModel.height
    				},
    				startY: this.startY,
    				endY: this.endY
    			});
    			this.attributesRender(this.boxAttributes);
    			this.$el.html(this.rowsAllHeadContainer.render().el);
    			return this;
    		},
    		
    		rowsPanelContainer: function(receiveFunc) {
    			receiveFunc(this);
    		},
    		
    		attributesRender: function(newAttributes) {
    			if (newAttributes.height === -1) {
    				this.$el.css({
    					'height': 0
    				});
    			} else {
    				this.$el.css({
    					'height': newAttributes.height
    				});
    			}
    			if (newAttributes.style) {
    				this.$el.addClass(newAttributes.style);
    			}
    		},
    		
    		scrollToPosition: function(position) {
    			this.$el.scrollTop(position);
    		},
    		
    		destroy: function() {
    			if (this.unsubscribe) {
    				this.unsubscribe('mainContainer','verticalPublish');
    			}
    			Backbone.off('call:rowsPanelContainer');
    			Backbone.off('event:rowsPanelContainer:destroy');
    			this.rowsAllHeadContainer.destroy();
    			this.remove();
    		},
    		
    		adjustHeadItemContainer: function(height) {
    			this.rowsAllHeadContainer.$el.css({
    				'height': height
    			});
    		},
    		
    		addHeadItemView: function(HeadItemModel) {
    			this.rowsAllHeadContainer.rowsHeadContainer.addRowsHeadContainer(HeadItemModel);
    		}
    	});
    	return RowsPanelContainer;
    });
    
    define('entrance/cell/setcelltext',function() {
    	var send = require('basic/tools/send'),
    		cells = require('collections/cells'),
    		cache = require('basic/tools/cache'),
    		config = require('spreadsheet/config'),
    		history = require('basic/tools/history'),
    		headItemCols = require('collections/headItemCol'),
    		headItemRows = require('collections/headItemRow'),
    		selectRegions = require('collections/selectRegion'),
    		getOperRegion = require('basic/tools/getoperregion');
    
    
    	return {
    		set: function(text) {
    			var clip,
    				region,
    				operRegion,
    				sendRegion,
    				headItemRowList = headItemRows.models,
    				headItemColList = headItemCols.models,
    				changeModelList = [],
    				oldValue;
    
    			clip = selectRegions.getModelByType('clip');
    			if (clip !== undefined) {
    				cache.clipState = 'null';
    				clip.destroy();
    			}
    			region = getOperRegion();
    			operRegion = region.operRegion;
    			sendRegion = region.sendRegion;
    
    
    			if (operRegion.endRowIndex === 'MAX' || operRegion.endColIndex === 'MAX') {
    				return;
    			}
    			cells.oprCellsByRegion(operRegion, function(cell, colSort, rowSort) {
    				if ((oldValue = cell.get('content').texts) !== text) {
    					changeModelList.push({
    						colSort: colSort,
    						rowSort: rowSort,
    						value: oldValue
    					});
    					cell.set('content.texts', text);
    				}
    			});
    			history.addUpdateAction('content.texts', text, {
    				startColSort: headItemColList[operRegion.startColIndex].get('sort'),
    				startRowSort: headItemRowList[operRegion.startRowIndex].get('sort'),
    				endColSort: headItemColList[operRegion.endColIndex].get('sort'),
    				endRowSort: headItemRowList[operRegion.endRowIndex].get('sort')
    			}, changeModelList);
    
    			return sendRegion;
    		},
    		clear: function() {
    			var sendRegion = this.set('');
    			if (!sendRegion) {
    				return;
    			}
    			send.PackAjax({
    				url: config.url.cell.clear,
    				data: JSON.stringify({
    					coordinate: [sendRegion],
    				})
    			});
    			
    		}
    	};
    });
    
    define('entrance/sheet/shortcut',function() {
    	var $ = require('lib/jquery'),
    		cache = require('basic/tools/cache'),
    		selects = require('collections/selectRegion'),
    		gridRows = require('collections/headItemRow'),
    		gridCols = require('collections/headItemCol'),
    		cells = require('collections/cells'),
    		textHandle = require('entrance/cell/setcelltext'),
    		gridRowList = gridRows.models,
    		gridColList = gridCols.models,
    		handler;
    
    	handler = {
    		altEnter: function(elem) {
    			this._insertAtCursor('\n', elem);
    		},
    		backspace: function() {
    			textHandle.clear('');
    		},
    		arrow: function(direction) {
    			var selectRecord = cache.shortcut.select,
    				select,
    				cellModel,
    				initSelectColIndex,
    				initSelectRowIndex,
    				selectColAlias,
    				selectRowAlias,
    				colIndex,
    				rowIndex,
    				occupyCol,
    				occupyRow,
    				maxColIndex = gridCols.length - 1,
    				maxRowIndex = gridRows.length - 1;
    
    			select = selects.getModelByType('selected');
    			//对于方向键，应该以选择初始点为基准做操作，因暂时不支持初始点，所以暂以左上角为基准
    			selectColAlias = select.get('wholePosi').startX;
    			selectRowAlias = select.get('wholePosi').startY;
    			initSelectRowIndex = gridRows.getIndexByAlias(selectRowAlias);
    			initSelectColIndex = gridCols.getIndexByAlias(selectColAlias);
    
    			cellModel = cells.getCellByVertical(initSelectColIndex, initSelectRowIndex)[0];
    
    			switch (direction) {
    				case 'LEFT':
    					colIndex = initSelectColIndex < 1 ? 0 : initSelectColIndex - 1;
    					rowIndex = gridRows.getIndexByAlias(selectRecord.rowAlias);
    					if (rowIndex === -1) {
    						rowIndex = initSelectRowIndex;
    					}
    					selectRecord.colAlias = gridColList[colIndex].get('alias');
    					break;
    				case 'RIGHT':
    					if (!cellModel) {
    						colIndex = initSelectColIndex < maxColIndex ? initSelectColIndex + 1 : maxColIndex;
    					} else {
    						occupyCol = cellModel.get('occupy').x;
    						colIndex = initSelectColIndex + occupyCol.length - occupyCol.indexOf(selectColAlias);
    						colIndex = colIndex < maxColIndex ? colIndex : maxColIndex;
    					}
    					rowIndex = gridRows.getIndexByAlias(selectRecord.rowAlias);
    					if (rowIndex === -1) {
    						rowIndex = initSelectRowIndex;
    					}
    					selectRecord.colAlias = gridColList[colIndex].get('alias');
    					break;
    				case 'UP':
    					rowIndex = initSelectRowIndex < 1 ? 0 : initSelectRowIndex - 1;
    					colIndex = gridCols.getIndexByAlias(selectRecord.colAlias);
    					if (colIndex === -1) {
    						colIndex = initSelectColIndex;
    					}
    					selectRecord.rowAlias = gridRowList[rowIndex].get('alias');
    					break;
    				case 'DOWN':
    					if (!cellModel) {
    						rowIndex = initSelectRowIndex < maxRowIndex ? initSelectRowIndex + 1 : maxRowIndex;
    					} else {
    						occupyRow = cellModel.get('occupy').y;
    						rowIndex = initSelectRowIndex + occupyRow.length - occupyRow.indexOf(selectRowAlias);
    						rowIndex = rowIndex < maxRowIndex ? rowIndex : maxRowIndex;
    					}
    					colIndex = gridCols.getIndexByAlias(selectRecord.colAlias);
    					if (colIndex === -1) {
    						colIndex = initSelectColIndex;
    					}
    					selectRecord.rowAlias = gridRowList[rowIndex].get('alias');
    					break;
    				default:
    					return;
    			}
    			select.set('tempPosi', {
    				initColIndex: colIndex,
    				initRowIndex: rowIndex,
    				mouseColIndex: colIndex,
    				mouseRowIndex: rowIndex
    			});
    		},
    		_insertAtCursor: function(insertChar, elem) {
    			var cursor,
    				$elem = $(elem);
    			if (document.selection) {
    				$elem.focus();
    				cursor = document.selection.createRange();
    				cursor.text = insertChar;
    				$elem.focus();
    			} else if (typeof elem.selectionStart === 'number' && typeof elem.selectionEnd === 'number') {
    				var startPos = elem.selectionStart;
    				var endPos = elem.selectionEnd;
    				var scrollTop = elem.scrollTop;
    				elem.value = elem.value.substring(0, startPos) + insertChar + elem.value.substring(endPos, elem.value.length);
    				$elem.focus();
    				elem.selectionStart = startPos + insertChar.length;
    				elem.selectionEnd = startPos + insertChar.length;
    				elem.scrollTop = scrollTop;
    			} else {
    				elem.value += insertChar;
    				$elem.focus();
    			}
    		},
    	};
    	return handler;
    });
    
    define('entrance/tool/clipselectoperate',function() {
    	var Backbone = require('lib/backbone'),
    		headItemCols = require('collections/headItemCol'),
    		headItemRows = require('collections/headItemRow'),
    		selectRegions = require('collections/selectRegion'),
    		protect = require('entrance/tool/protect'),
    		cells = require('collections/cells'),
    		cache = require('basic/tools/cache');
    
    	function clipSelectOperate(type, e) {
    		var tempCellModel,
    			selectRegion,
    			startColIndex,
    			startRowIndex,
    			endColIndex,
    			endRowIndex,
    			clipModel,
    			colAlias,
    			rowAlias,
    			text = '',
    			i,
    			j;
    
    		clipModel = selectRegions.getModelByType('clip');
    		if (clipModel !== undefined) {
    			clipModel.destroy();
    		}
    
    		selectRegion = selectRegions.getModelByType('selected');
    		//整行整列，禁止复制
    		if (selectRegion.get('wholePosi').endX === 'MAX' ||
    			selectRegion.get('wholePosi').endY === 'MAX') {
    			return;
    		}
    
    		clipModel = selectRegion.clone();
    		clipModel.set('selectType', 'clip');
    		selectRegions.add(clipModel);
    
    		startColIndex = headItemCols.getIndexByAlias(clipModel.get('wholePosi').startX);
    		startRowIndex = headItemRows.getIndexByAlias(clipModel.get('wholePosi').startY);
    		endColIndex = headItemCols.getIndexByAlias(clipModel.get('wholePosi').endX);
    		endRowIndex = headItemRows.getIndexByAlias(clipModel.get('wholePosi').endY);
    
    		//剪切操作包含保护区域，禁止操作
    		if (type === 'cut' && protect.interceptor({
    				startColIndex: startColIndex,
    				startRowIndex: startRowIndex,
    				endColIndex: endColIndex,
    				endRowIndex: endRowIndex
    			})) {
    			Backbone.trigger('event:showMsgBar:show','保护状态，不能进行该操作');
    			clipModel.destroy();
    			return;
    		}
    
    		if (type === 'copy') {
    			cache.clipState = 'copy';
    		} else if (type === 'cut') {
    			cache.clipState = 'cut';
    		} else {
    			return;
    		}
    
    		for (i = startRowIndex; i < endRowIndex + 1; i++) {
    			for (j = startColIndex; j < endColIndex + 1; j++) {
    				colAlias = headItemCols.models[j].get('alias');
    				rowAlias = headItemRows.models[i].get('alias');
    				tempCellModel = cells.getCellByAlias(colAlias, rowAlias);
    				if (tempCellModel !== null) {
    					text += cellToText(tempCellModel);
    				}
    				if (j !== endColIndex) {
    					text += '\t';
    				} else {
    					text += '\r\n';
    				}
    			}
    		}
    		if (e !== undefined) {
    			e.preventDefault();
    			if (window.clipboardData) {
    				window.clipboardData.setData('Text', text);
    			} else {
    				e.originalEvent.clipboardData.setData('Text', text);
    			}
    			cache.clipboardData = text;
    		}
    
    		function cellToText(cell) {
    			var text,
    				head = '"',
    				tail = '"';
    			text = cell.get('content').texts;
    
    			if (text.indexOf('\n') === -1) {
    				return text;
    			}
    			while (true) {
    				if (text.indexOf('"') === 0) {
    					text = text.substring(1);
    					head += '""';
    				} else {
    					break;
    				}
    			}
    
    			while (true) {
    				if (text.lastIndexOf('"') === text.length - 1 && text.length > 1) {
    					text = text.substring(0, text.length - 1);
    					tail += '""';
    				} else {
    					break;
    				}
    			}
    			text = head + text + tail;
    			return text;
    		}
    	}
    	return clipSelectOperate;
    });
    define('entrance/tool/clippasteoperate',function() {
    	
    	var Backbone = require('lib/backbone'),
    		cache = require('basic/tools/cache'),
    		config = require('spreadsheet/config'),
    		cells = require('collections/cells'),
    		Cell = require('models/cell'),
    		send = require('basic/tools/send'),
    		history = require('basic/tools/history'),
    		cols = require('collections/headItemCol'),
    		rows = require('collections/headItemRow'),
    		selectRegions = require('collections/selectRegion'),
    		setTextType = require('entrance/tool/settexttype'),
    		strandMap = require('basic/tools/strandmap'),
    		rowList = rows.models,
    		colList = cols.models,
    		cellList = cells.models;
    
    	function clipPasteOperate(pasteText) {
    		var clipboardData = cache.clipboardData;
    		//如果剪切板内容与选中区域的数据不相等，则使用剪切板内容
    		if (cache.clipState !== null && clipboardData === pasteText) {
    			excelDataPaste(cache.clipState);
    		} else {
    			clipBoardDataPaste(pasteText);
    		}
    	}
    	
    	function excelDataPaste(type) {
    		var currentModelIndexs = [],
    			wholePosi,
    			clipRegion,
    			selectRegion,
    			startColIndex,
    			startRowIndex,
    			endColIndex,
    			endRowIndex,
    			selectColIndex,
    			selectRowIndex,
    			URL;
    
    		clipRegion = selectRegions.getModelByType('clip');
    		selectRegion = selectRegions.getModelByType('selected');
    
    		wholePosi = clipRegion.get('wholePosi');
    		startColIndex = cols.getIndexByAlias(wholePosi.startX);
    		startRowIndex = rows.getIndexByAlias(wholePosi.startY);
    		endColIndex = cols.getIndexByAlias(wholePosi.endX);
    		endRowIndex = rows.getIndexByAlias(wholePosi.endY);
    
    		wholePosi = selectRegion.get('wholePosi');
    		selectColIndex = cols.getIndexByAlias(wholePosi.startX);
    		selectRowIndex = rows.getIndexByAlias(wholePosi.startY);
    
    		if (type === 'cut') {
    			URL = config.url.sheet.cut;
    		} else {
    			URL = config.url.sheet.copy;
    		}
    
    		send.PackAjax({
    			url: URL,
    			async: false,
    			data: JSON.stringify({
    				excelId: window.SPREADSHEET_AUTHENTIC_KEY,
    				sheetId: '1',
    				orignal: {
    					startCol: colList[startColIndex].get('sort'),
    					endCol: colList[endColIndex].get('sort'),
    					startRow: rowList[startRowIndex].get('sort'),
    					endRow: rowList[endRowIndex].get('sort'),
    				},
    				target: {
    					oprCol: colList[selectColIndex].get('sort'),
    					oprRow: rowList[selectRowIndex].get('sort')
    				}
    			}),
    			success: function(data) {
    				if (data && data.isLegal) {
    					fillData();
    				} else {
    					Backbone.trigger('event:showMsgBar:show', '该区域不能进行此操作');
    				}
    			}
    		});
    
    		function fillData() {
    			var i, j,
    				temp = {},
    				tempRuleIndex,
    				colAlias,
    				rowAlias,
    				cloneCellList = [],
    				cloneRuleList = [],
    				originalRuleData = [],
    				originalModelIndexs = [],
    				currentRuleData = [],
    				cloneObj,
    				cloneRule,
    				rowLen = rows.length,
    				colLen = cols.length,
    				oprEndColIndex = selectColIndex + (endColIndex - startColIndex),
    				oprEndRowIndex = selectRowIndex + (endRowIndex - startRowIndex),
    				cellStrand = cache.CellsPosition.strandX,
    				cellIndex,
    				cellModel,
    				actions = [];
    
    			oprEndColIndex = oprEndColIndex > cols.length - 1 ? cols.length - 1 : oprEndColIndex;
    			oprEndRowIndex = oprEndRowIndex > rows.length - 1 ? rows.length - 1 : oprEndRowIndex;
    			
    			for (i = startRowIndex; i <= endRowIndex; i++) {
    				for (j = startColIndex; j <= endColIndex; j++) {
    					colAlias = colList[j].get('alias');
    					rowAlias = rowList[i].get('alias');
    
    					if (cellStrand[colAlias] && (cellIndex = cellStrand[colAlias][rowAlias]) !== undefined) {
    						if (!temp[cellIndex]) {
    							cellModel = cellList[cellIndex];
    							cloneCellList.push({
    								relativeCol: j - startColIndex,
    								relativeRow: i - startRowIndex,
    								model: cellModel.clone()
    							});
    							if (type === 'cut') {
    								cellModel.set('isDestroy', true);
    								originalModelIndexs.push(cellIndex);
    							}
    							temp[cellIndex] = 1;
    						}
    						if (type === 'cut') {
    							deletePosi(colAlias, rowAlias);
    						}
    					}
    					if ((tempRuleIndex = strandMap.getPointRecord(colAlias, rowAlias, 'validate')) !== undefined) {
    						cloneRuleList.push({
    							relativeCol: j - startColIndex,
    							relativeRow: i - startRowIndex,
    							ruleIndex: tempRuleIndex
    						});
    						if (type === 'cut') {
    							originalRuleData.push({
    								colAlias: colList[j].get('alias'),
    								rowAlias: rowList[i].get('alias'),
    								index: tempRuleIndex
    							});
    							strandMap.deletePointRecord(colAlias, rowAlias, 'validate');
    						}
    					}
    				}
    			}
    			temp = {};
    			
    			for (i = selectRowIndex; i <= oprEndRowIndex; i++) {
    				for (j = selectColIndex; j <= oprEndColIndex; j++) {
    					if (i >= rowLen || j >= colLen) {
    						continue;
    					}
    					colAlias = colList[j].get('alias');
    					rowAlias = rowList[i].get('alias');
    					if (cellStrand[colAlias] && (cellIndex = cellStrand[colAlias][rowAlias]) !== undefined &&
    						!temp[cellIndex]) {
    						temp[cellIndex] = 1;
    						cellModel = cellList[cellIndex];
    						cellModel.set('isDestroy', true);
    						if (originalModelIndexs.indexOf(cellIndex) !== -1) {
    							originalModelIndexs.push(cellIndex);
    						}
    						deletePosi(colAlias, rowAlias);
    					}
    					if ((tempRuleIndex = strandMap.getPointRecord(colAlias, rowAlias, 'validate')) !== undefined) {
    						originalRuleData.push({
    							colAlias: colAlias,
    							rowAlias: rowAlias,
    							index: tempRuleIndex
    						});
    						strandMap.deletePointRecord(colAlias, rowAlias, 'validate');
    					}
    				}
    			}
    			
    			for (i = 0; i < cloneCellList.length; i++) {
    				cloneObj = cloneCellList[i];
    				cellModel = adaptCell(cloneObj.model, cloneObj.relativeCol, cloneObj.relativeRow);
    				if (cellModel) {
    					currentModelIndexs.push(cells.length);
    					cells.push(cellModel);
    				}
    			}
    
    			for (i = 0; i < cloneRuleList.length; i++) {
    				cloneRule = cloneRuleList[i];
    				colAlias = colList[selectColIndex + cloneRule.relativeCol].get('alias');
    				rowAlias = rowList[selectRowIndex + cloneRule.relativeRow].get('alias');
    				currentRuleData.push({
    					colAlias: colAlias,
    					rowAlias: rowAlias,
    					index: cloneRule.ruleIndex
    				});
    				strandMap.addPointRecord(colAlias, rowAlias, 'validate', cloneRule.ruleIndex);
    			}
    			actions.push(history.getCellCoverAction(currentModelIndexs, originalModelIndexs));
    			actions.push(history.getValidateCoverAction(currentRuleData, originalRuleData));
    
    			history.addAction(actions);
    			
    			selectRegion.set('tempPosi', {
    				initColIndex: selectColIndex,
    				initRowIndex: selectRowIndex,
    				mouseColIndex: oprEndColIndex < colLen ? oprEndColIndex : colLen - 1,
    				mouseRowIndex: oprEndRowIndex < rowLen ? oprEndRowIndex : rowLen - 1
    			});
    
    			//判断两个区域不相交
    			if ((selectRowIndex > endRowIndex ||
    					selectColIndex > endColIndex ||
    					oprEndRowIndex < startRowIndex ||
    					oprEndColIndex < startColIndex) && type === 'copy') {
    				return;
    			}
    
    			cache.clipState = 'null';
    			cache.clipboardData = null;
    			clipRegion.destroy();
    		}
    	}
    
    	function adaptCell(cell, relativeColIndex, relativeRowIndex) {
    		var selectColIndex,
    			selectRowIndex,
    			selectRegion,
    			arrayColAlias = [],
    			arrayRowAlias = [],
    			colIndex,
    			rowIndex,
    			left, top,
    			width = 0,
    			height = 0,
    			rowLen, colLen, i;
    
    
    		selectRegion = selectRegions.getModelByType('selected');
    		selectColIndex = cols.getIndexByAlias(selectRegion.get('wholePosi').startX);
    		selectRowIndex = rows.getIndexByAlias(selectRegion.get('wholePosi').startY);
    
    		if (selectColIndex + relativeColIndex >= cols.length ||
    			selectRowIndex + relativeRowIndex >= rows.length) {
    			return false;
    		}
    		rowLen = cell.get('occupy').x.length || 1;
    		colLen = cell.get('occupy').x.length || 1;
    		//增加超过加载区域处理
    		for (i = 0; i < rowLen; i++) {
    			rowIndex = selectRowIndex + relativeRowIndex + i;
    			arrayRowAlias.push(rowList[rowIndex].get('alias'));
    			height += rowList[rowIndex].get('height') + 1;
    			if (i === 0) {
    				top = rowList[rowIndex].get('top');
    			}
    		}
    		for (i = 0; i < colLen; i++) {
    			colIndex = selectColIndex + relativeColIndex + i;
    			arrayColAlias.push(colList[colIndex].get('alias'));
    			width += colList[colIndex].get('width') + 1;
    			if (i === 0) {
    				left = colList[colIndex].get('left');
    			}
    		}
    		cell.set('isDestroy', false);
    		cell.set('occupy', {
    			x: arrayColAlias,
    			y: arrayRowAlias
    		});
    		cell.set('physicsBox', {
    			top: top,
    			left: left,
    			width: width - 1,
    			height: height - 1
    		});
    		cacheCellPosition();
    
    		return cell;
    
    		function cacheCellPosition() {
    			var index = cells.length,
    				rowLen,
    				colLen,
    				i, j;
    			for (i = 0, rowLen = arrayRowAlias.length; i < rowLen; i++) {
    				for (j = 0, colLen = arrayColAlias.length; j < colLen; j++) {
    					cache.cachePosition(arrayRowAlias[i], arrayColAlias[j], index);
    				}
    			}
    		}
    	}
    
    	function deletePosi(aliasCol, aliasRow) {
    		var cellPosition = cache.CellsPosition,
    			strandX = cellPosition.strandX,
    			strandY = cellPosition.strandY;
    		if (strandX[aliasCol] && strandX[aliasCol][aliasRow] !== undefined) {
    			delete strandX[aliasCol][aliasRow];
    			if (!Object.getOwnPropertyNames(strandX[aliasCol]).length) {
    				delete strandX[aliasCol];
    			}
    		}
    		if (strandY[aliasRow] && strandY[aliasRow][aliasCol] !== undefined) {
    			delete strandY[aliasRow][aliasCol];
    			if (!Object.getOwnPropertyNames(strandY[aliasRow]).length) {
    				delete strandY[aliasRow];
    			}
    		}
    	}
    	
    	function clipBoardDataPaste(pasteText) {
    		var encodeText,
    			rowData = [],
    			cellData = [],
    			sendData = [],
    			rowCellData = [],
    			selectRowIndex,
    			selectColIndex,
    			selectRegion,
    			clipRegion,
    			colSort,
    			rowSort,
    			rowLen,
    			colLen,
    			i,
    			j;
    
    		//清除选中复制区域视图
    		clipRegion = selectRegions.getModelByType('clip');
    		if (clipRegion !== null && clipRegion !== undefined) {
    			clipRegion.destroy();
    		}
    		cache.clipState = 'null';
    
    		encodeText = encodeURI(pasteText);
    		rowData = encodeText.split('%0D%0A');
    
    		rowLen = rowData.length - 1;
    		if (rowData[rowLen] !== '') {
    			rowLen++;
    		}
    
    		colLen = rowData[0].split('%09').length;
    
    		selectRegion = selectRegions.getModelByType('selected');
    		selectRowIndex = rows.getIndexByAlias(selectRegion.get('wholePosi').startY);
    		selectColIndex = cols.getIndexByAlias(selectRegion.get('wholePosi').startX);
    
    		rowSort = rowList[selectRowIndex].get('sort');
    		colSort = colList[selectColIndex].get('sort');
    
    		for (i = 0; i < rowLen; i++) {
    			rowCellData = rowData[i].split('%09');
    			for (j = 0; j < rowCellData.length; j++) {
    				if (rowCellData[j] !== '') {
    					sendData.push({
    						'col': colSort + j,
    						'row': rowSort + i,
    						'content': decodeURI(analysisText(rowCellData[j]))
    					});
    					cellData.push({
    						relativeColIndex: j,
    						relativeRowIndex: i,
    						text: decodeURI(analysisText(rowCellData[j]))
    					});
    				}
    			}
    		}
    
    		send.PackAjax({
    			url: config.url.sheet.paste,
    			async: false,
    			data: JSON.stringify({
    				sheetId: '1',
    				oprCol: colList[selectColIndex].get('sort'),
    				oprRow: rowList[selectRowIndex].get('sort'),
    				colLen: colLen,
    				rowLen: rowLen,
    				pasteData: sendData
    			}),
    			success: function(data) {
    				if (data && data.isLegal) {
    					fillData();
    				} else {
    					Backbone.trigger('event:showMsgBar:show', '该区域不能进行此操作');
    				}
    			}
    		});
    
    		function fillData() {
    			var cellStrand = cache.CellsPosition.strandX,
    				originalModelIndexs = [],
    				currentModelIndexs = [],
    				originalRuleData = [],
    				rowAlias,
    				colAlias,
    				cellModel,
    				actions = [],
    				tempRuleIndex;
    
    			for (i = selectRowIndex; i < selectRowIndex + rowLen; i++) {
    				for (j = selectColIndex; j < selectColIndex + colLen; j++) {
    					if (i >= rows.length || j >= cols.length) {
    						continue;
    					}
    					rowAlias = rowList[i].get('alias');
    					colAlias = colList[j].get('alias');
    					cellModel = cells.getCellByVertical(j, i)[0];
    					if (cellModel && cellModel.get('isDestroy') === false) {
    						originalModelIndexs.push(cellStrand[colAlias][rowAlias]);
    						cellModel.set('isDestroy', true);
    					}
    					cache.deletePosi(rowAlias, colAlias);
    					if ((tempRuleIndex = strandMap.getPointRecord(colAlias, rowAlias, 'validate')) !== undefined) {
    						originalRuleData.push({
    							colAlias: colAlias,
    							rowAlias: rowAlias,
    							index: tempRuleIndex
    						});
    						strandMap.deletePointRecord(colAlias, rowAlias, 'validate');
    					}
    				}
    			}
    			for (i = 0; i < cellData.length; i++) {
    				cellModel = new Cell();
    				cellModel.set('content.texts', cellData[i].text);
    				cellModel = adaptCell(cellModel, cellData[i].relativeColIndex, cellData[i].relativeRowIndex);
    				if (cellModel) {
    					setTextType.typeRecognize(cellModel);
    					setTextType.generateDisplayText(cellModel);
    					cells.add(cellModel);
    					currentModelIndexs.push(cells.length - 1);
    				}
    			}
    			actions.push(history.getCellCoverAction(currentModelIndexs, originalModelIndexs));
    			actions.push(history.getValidateCoverAction([], originalRuleData));
    			history.addAction(actions);
    		}
    
    		function analysisText(text) {
    			var head = '',
    				tail = '';
    			if (text.indexOf('%0A') === -1) {
    				return text;
    			}
    			text = text.substring(3, text.length - 3);
    			while (true) {
    				if (text.indexOf('%22%22') === 0) {
    					text = text.substring(6);
    					head += '%22';
    				} else {
    					break;
    				}
    			}
    			while (true) {
    				if (text.lastIndexOf('%22%22') === text.length - 6 && text.length > 6) {
    					text = text.substring(0, text.length - 6);
    					tail += '%22';
    				} else {
    					break;
    				}
    			}
    			text = head + text + tail;
    			return text;
    		}
    	}
    	return clipPasteOperate;
    });
    define('basic/tools/selectvalidate',function() {
    	
    	var observerPattern = require('basic/util/observer.pattern'),
    		selectValidate;
    
    	selectValidate = {
    		_ruleIndex: null,
    		set: function(ruleIndex) {
    			if (this._ruleIndex !== ruleIndex) {
    				this._ruleIndex = ruleIndex;
    				this.publish('validate', 'changeRulePublish');
    			}
    		},
    		get: function() {
    			return this._ruleIndex;
    		},
    		addSubscriber: function(obj) {
    			observerPattern.buildSubscriber(obj);
    			obj.subscribe('validate', 'changeRulePublish', 'changeRule');
    		}
    	};
    	observerPattern.buildPublisher(selectValidate);
    	return selectValidate;
    });
    
    define('entrance/sheet/redoundo',function() {
    	var Backbone = require('lib/backbone'),
    		history = require('basic/tools/history'),
    		cache = require('basic/tools/cache'),
    		send = require('basic/tools/send'),
    		config = require('spreadsheet/config'),
    		cols = require('collections/headItemCol'),
    		rows = require('collections/headItemRow'),
    		cells = require('collections/cells'),
    		strandMap = require('basic/tools/strandmap'),
    		selectValidate = require('basic/tools/selectvalidate'),
    		selects = require('collections/selectRegion'),
    		rowList = rows.models,
    		colList = cols.models,
    		cellList = cells.models,
    		redoUndo;
    
    	redoUndo = {
    		redo: function() {
    			var action = history.next(),
    				prefix = '_redo',
    				handler,
    				i, len;
    
    			if (!action) {
    				return;
    			}
    			if (typeof action === 'object' &&
    				Object.prototype.toString.call(action) !== '[object Array]') {
    				action = [action];
    			}
    			for (i = 0, len = action.length; i < len; i++) {
    				handler = prefix + action[i].type[0].toUpperCase() + action[i].type.substring(1);
    				if (this[handler]) {
    					this[handler](action[i]);
    				}
    			}
    			this.sendData(config.url.sheet.redo);
    		},
    		undo: function() {
    			var action = history.previous(),
    				prefix = '_undo',
    				handler,
    				i, len;
    
    
    			if (!action) {
    				return;
    			}
    			if (typeof action === 'object' &&
    				Object.prototype.toString.call(action) !== '[object Array]') {
    				action = [action];
    			}
    			for (i = 0, len = action.length; i < len; i++) {
    				handler = prefix + action[i].type[0].toUpperCase() + action[i].type.substring(1);
    				if (this[handler]) {
    					this[handler](action[i]);
    				}
    			}
    			this.sendData(config.url.sheet.undo);
    		},
    		_redoUpdateCellProp: function(action) {
    			var propName = action.propName,
    				propValue = action.propValue,
    				region = action.region,
    				startColIndex,
    				startRowIndex,
    				endColIndex,
    				endRowIndex;
    
    			startColIndex = cols.getIndexBySort(region.startColSort);
    			startRowIndex = rows.getIndexBySort(region.startRowSort);
    			endColIndex = cols.getIndexBySort(region.endColSort);
    			endRowIndex = rows.getIndexBySort(region.endRowSort);
    
    			cells.oprCellsByRegion({
    				startColIndex: startColIndex,
    				startRowIndex: startRowIndex,
    				endColIndex: endColIndex,
    				endRowIndex: endRowIndex
    			}, function(cell) {
    				cell.set(propName, propValue);
    			});
    		},
    		_redoCoverCellModel: function(action) {
    			var originalModelIndexs = action.originalModelIndexs,
    				currentModelIndexs = action.currentModelIndexs,
    				occupyCol, occupyRow,
    				occupyColLen, occupyRowLen,
    				index, len, i, j ,k;
    
    			for (i = 0, len = originalModelIndexs.length; i < len; i++) {
    				index = originalModelIndexs[i];
    				cellList[index].set('isDestroy', true);
    				occupyCol = cellList[index].get('occupy').x;
    				occupyRow = cellList[index].get('occupy').y;
    				for (j = 0, occupyColLen = occupyCol.length; j < occupyColLen; j++) {
    					for (k = 0, occupyRowLen = occupyRow.length; k < occupyRowLen; k++) {
    						cache.deletePosi(occupyRow[k], occupyCol[j]);
    					}
    				}
    			}
    			for (i = 0, len = currentModelIndexs.length; i < len; i++) {
    				index = currentModelIndexs[i];
    				cellList[index].set('isDestroy', false);
    				Backbone.trigger('event:contentCellsContainer:restoreCell', cellList[index]);
    				occupyCol = cellList[index].get('occupy').x;
    				occupyRow = cellList[index].get('occupy').y;
    				for (j = 0, occupyColLen = occupyCol.length; j < occupyColLen; j++) {
    					for (k = 0, occupyRowLen = occupyRow.length; k < occupyRowLen; k++) {
    						cache.cachePosition(occupyRow[k], occupyCol[j], index);
    					}
    				}
    			}
    		},
    		_redoUpdateValidateRule: function(action) {
    			var region = action.region,
    				ruleIndex = action.currentRuleIndex,
    				startRowIndex = rows.getIndexBySort(region.startRowSort),
    				startColIndex = cols.getIndexBySort(region.startColSort),
    				endRowIndex = rows.getIndexBySort(region.endRowSort),
    				endColIndex = cols.getIndexBySort(region.endColSort),
    				select,
    				i, j;
    
    			for (i = startColIndex; i < endColIndex + 1; i++) {
    				for (j = startRowIndex; j < endRowIndex + 1; j++) {
    					strandMap.addPointRecord(colList[i].get('alias'), rowList[j].get('alias'), 'validate', ruleIndex);
    				}
    			}
    			select = selects.getModelByType('selected');
    			selectValidate.set(strandMap.calcPointRecord(select.get('wholePosi').startX, select.get('wholePosi').startY, 'validate'));
    		},
    		_redoCoverValidateRule: function(action) {
    			var currentData = action.currentData,
    				originalData = action.originalData,
    				i, len;
    			for (i = 0, len = originalData.length; i < len; i++) {
    				strandMap.deletePointRecord(originalData[i].colAlias, originalData[i].rowAlias, 'validate');
    			}
    			for (i = 0, len = currentData.length; i < len; i++) {
    				strandMap.addPointRecord(currentData[i].colAlias, currentData.colAlias[i], 'validate', currentData[i].index);
    			}
    		},
    		_undoUpdateCellProp: function(action) {
    			var originalData = action.originalData,
    				propName = action.propName,
    				tempModel,
    				colIndex,
    				rowIndex,
    				len, i;
    
    			for (i = 0, len = originalData.length; i < len; i++) {
    				colIndex = cols.getIndexBySort(originalData[i].colSort);
    				rowIndex = rows.getIndexBySort(originalData[i].rowSort);
    				tempModel = cells.getCellByVertical(colIndex, rowIndex)[0];
    				if (typeof tempModel !== 'undefined') {
    					tempModel.set(propName, originalData[i].value);
    				}
    			}
    		},
    		_undoCoverCellModel: function(action) {
    			var originalModelIndexs = action.originalModelIndexs,
    				currentModelIndexs = action.currentModelIndexs,
    				occupyCol, occupyRow,
    				occupyColLen, occupyRowLen,
    				len, i, j, k,
    				index;
    
    			for (i = 0, len = currentModelIndexs.length; i < len; i++) {
    				index = currentModelIndexs[i];
    				cellList[index].set('isDestroy', true);
    				occupyCol = cellList[index].get('occupy').x;
    				occupyRow = cellList[index].get('occupy').y;
    				for (j = 0, occupyColLen = occupyCol.length; j < occupyColLen; j++) {
    					for (k = 0, occupyRowLen = occupyRow.length; k < occupyRowLen; k++) {
    						cache.deletePosi(occupyRow[k], occupyCol[j]);
    					}
    				}
    			}
    			for (i = 0, len = originalModelIndexs.length; i < len; i++) {
    				index = originalModelIndexs[i];
    				cellList[index].set('isDestroy', false);
    				Backbone.trigger('event:contentCellsContainer:restoreCell', cellList[index]);
    				occupyCol = cellList[index].get('occupy').x;
    				occupyRow = cellList[index].get('occupy').y;
    				for (j = 0, occupyColLen = occupyCol.length; j < occupyColLen; j++) {
    					for (k = 0, occupyRowLen = occupyRow.length; k < occupyRowLen; k++) {
    						cache.cachePosition(occupyRow[k], occupyCol[j], index);
    					}
    				}
    			}
    		},
    		_undoUpdateValidateRule: function(action) {
    			var originalData = action.originalData,
    				select,
    				colIndex,
    				rowIndex,
    				ruleIndex,
    				i, len;
    			for (i = 0, len = originalData.length; i < len; i++) {
    				rowIndex = rows.getIndexBySort(originalData[i].rowSort);
    				colIndex = cols.getIndexBySort(originalData[i].colSort);
    				ruleIndex = originalData[i].originalIndex;
    				if (ruleIndex !== undefined) {
    					strandMap.addPointRecord(colList[colIndex].get('alias'), rowList[rowIndex].get('alias'), 'validate', ruleIndex);
    				} else {
    					strandMap.deletePointRecord(colList[colIndex].get('alias'), rowList[rowIndex].get('alias'), 'validate');
    				}
    			}
    			select = selects.getModelByType('selected');
    			selectValidate.set(strandMap.calcPointRecord(select.get('wholePosi').startX, select.get('wholePosi').startY, 'validate'));
    		},
    		_undoCoverValidateRule: function(action) {
    			var currentData = action.currentData,
    				originalData = action.originalData,
    				i, len;
    
    			for (i = 0, len = currentData.length; i < len; i++) {
    				strandMap.deletePointRecord(currentData[i].colAlias, currentData[i].colAlias, 'validate');
    			}
    			for (i = 0, len = originalData.length; i < len; i++) {
    				strandMap.addPointRecord(originalData[i].colAlias, originalData.rowAlias[i], 'validate', originalData[i].index);
    			}
    
    		},
    		sendData: function(url) {
    			send.PackAjax({
    				url: url
    			});
    		}
    	};
    	return redoUndo;
    });
    
    define('views/inputContainer',function() {
    	var Backbone = require('lib/backbone'),
    		cache = require('basic/tools/cache'),
    		getTextBox = require('basic/tools/gettextbox'),
    		history = require('basic/tools/history'),
    		config = require('spreadsheet/config'),
    		send = require('basic/tools/send'),
    		Cell = require('models/cell'),
    		headItemRows = require('collections/headItemRow'),
    		headItemCols = require('collections/headItemCol'),
    		selectRegions = require('collections/selectRegion'),
    		cells = require('collections/cells'),
    		shortcut = require('entrance/sheet/shortcut'),
    		clipSelectOperate = require('entrance/tool/clipselectoperate'),
    		clipPasteOperate = require('entrance/tool/clippasteoperate'),
    		setCellContent = require('entrance/tool/setcellcontent'),
    		done = require('entrance/sheet/redoundo'),
    		protect = require('entrance/tool/protect'),
    		headItemRowList = headItemRows.models,
    		headItemColList = headItemCols.models,
    		InputContainer;
    
    	
    	InputContainer = Backbone.View.extend({
    		
    		tagName: 'textarea',
    		
    		className: 'edit-frame',
    		
    		events: {
    			'keydown': 'keydownHandle',
    			'blur': 'hide',
    			'copy': 'copyData',
    			'paste': 'pasteData',
    			'cut': 'cutData'
    		},
    		
    		initialize: function() {
    			Backbone.on('event:InputContainer:show', this.show, this);
    		},
    		
    		show: function(dblclick) {
    			var mainContainer,
    				modelJSON,
    				rowAlias,
    				colAlias,
    				colIndex,
    				rowIndex,
    				select,
    				clip,
    				left,
    				top,
    				cell;
    
    			select = selectRegions.getModelByType('selected');
    			colAlias = select.get('wholePosi').startX;
    			colIndex = headItemCols.getIndexByAlias(colAlias);
    			rowAlias = select.get('wholePosi').startY;
    			rowIndex = headItemRows.getIndexByAlias(rowAlias);
    
    			if (protect.interceptor({
    					startColIndex: colIndex,
    					startRowIndex: rowIndex
    				})) {
    				return;
    			}
    			clip = selectRegions.getModelByType('clip');
    			if (clip !== undefined) {
    				cache.clipState = 'null';
    				clip.destroy();
    			}
    
    
    			Backbone.trigger('call:mainContainer', function(container) {
    				mainContainer = container;
    			});
    
    			this.rowIndex = rowIndex;
    			this.colIndex = colIndex;
    			this.mainContainer = mainContainer;
    			cell = cells.getRegionCells(colIndex, rowIndex)[0];
    			if (!cell) {
    				cell = cells.createCellModel(colIndex, rowIndex);
    			}
    			this.model = cell;
    			left = this.getAbsoluteLeft();
    			top = this.getAbsoluteTop();
    			this.adjustZIndex();
    			this.showState = true;
    
    			modelJSON = cell.toJSON();
    			if (!dblclick) {
    				this.model.set('content.texts', '');
    			} else {
    				this.$el.val(modelJSON.content.texts);
    			}
    
    			if (modelJSON.content.bd === true) {
    				this.$el.css({
    					'fontWeight': 'bold'
    				});
    			} else {
    				this.$el.css({
    					'fontWeight': 'normal'
    				});
    			}
    			if (modelJSON.content.italic === true) {
    				this.$el.css({
    					'fontStyle': 'italic'
    				});
    			} else {
    				this.$el.css({
    					'fontStyle': 'normal'
    				});
    			}
    			if (modelJSON.content.underline) {
    				this.$el.css({
    					'textDecoration': 'underline'
    				});
    			} else {
    				this.$el.css({
    					'textDecoration': 'none'
    				});
    			}
    			this.$el.css({
    				'color': modelJSON.content.color,
    				'fontSize': modelJSON.content.size + 'pt',
    				'fontFamily': modelJSON.content.family,
    				'left': left,
    				'top': top,
    			});
    			//适应文本宽度高度
    			this.adjustWidth(true);
    			this.adjustHeight();
    		},
    		
    		pasteData: function(event) {
    			if (this.showState === false && config.shortcuts.clip) {
    				event.preventDefault();
    				var pasteText;
    				if (window.clipboardData && window.clipboardData.getData) { // IE
    					pasteText = window.clipboardData.getData('Text');
    				} else {
    					pasteText = event.originalEvent.clipboardData.getData('Text'); //e.clipboardData.getData('text/plain');
    				}
    				clipPasteOperate(pasteText);
    			}
    		},
    		copyData: function(event) {
    			if (this.showState === false && config.shortcuts.clip) {
    				clipSelectOperate('copy', event);
    			}
    		},
    		cutData: function(event) {
    			if (this.showState === false && config.shortcuts.clip) {
    				clipSelectOperate('cut', event);
    			}
    		},
    		
    		hide: function() {
    			var model = this.model,
    				originalText,
    				rowDisplayName,
    				colDisplayName,
    				select,
    				text;
    			if (this.showState === true) {
    				rowDisplayName = headItemRowList[this.rowIndex].get('displayName');
    				colDisplayName = headItemColList[this.colIndex].get('displayName');
    
    				originalText = model.get('content').texts;
    				text = this.$el.val();
    				if (!setCellContent('sheetId', text, colDisplayName.toUpperCase() + rowDisplayName)) {
    					Backbone.trigger('event:showMsgBar:show', '输入值非法，用户已限定了输入的数值');
    					select = selectRegions.getModelByType('selected');
    
    					select.set('tempPosi', {
    						initColIndex: this.colIndex,
    						initRowIndex: this.rowIndex,
    						mouseColIndex: this.colIndex,
    						mouseRowIndex: this.rowIndex
    					});
    					
    					this.$el.val(originalText);
    					this.$el.focus();
    					return;
    				}
    				this.$el.css({
    					'left': -1000,
    					'top': -1000,
    					'width': 0,
    					'height': 0,
    					'z-index': -100
    				});
    			}
    			this.$el.val('');
    			this.showState = false;
    		},
    		
    		transverseScroll: function() {
    			var left;
    			if (this.showState === true) {
    				left = this.getAbsoluteLeft();
    				this.$el.css({
    					'left': left
    				});
    			}
    		},
    		
    		verticalScroll: function() {
    			var top;
    			if (this.showState === true) {
    				top = this.getAbsoluteTop();
    				this.$el.css({
    					'top': top
    				});
    			}
    		},
    		
    		autoScrollLeft: function() {
    			var scrollBarWidth,
    				right,
    				limitRight,
    				scrollLeft,
    				differ;
    			scrollBarWidth = this.mainContainer.$el[0].offsetWidth - this.mainContainer.$el[0].clientWidth;
    			right = this.$el.position().left + this.$el.width();
    			limitRight = this.$el.parent()[0].clientWidth - scrollBarWidth;
    			differ = limitRight - right;
    			if (differ < 0) {
    				scrollLeft = this.mainContainer.$el.scrollLeft();
    				this.mainContainer.$el.scrollLeft(scrollLeft - differ);
    			}
    		},
    		
    		autoScrollTop: function() {
    			var scrollBarHeight,
    				bottom,
    				limitBottom,
    				scrollTop,
    				differ;
    			scrollBarHeight = this.mainContainer.$el[0].offsetHeight - this.mainContainer.$el[0].clientHeight;
    			bottom = this.$el.position().top + this.$el.height();
    			limitBottom = this.$el.parent()[0].clientHeight - scrollBarHeight;
    			differ = limitBottom - bottom;
    			if (differ < 0) {
    				scrollTop = this.mainContainer.$el.scrollTop() - differ;
    				this.mainContainer.$el.scrollTop(scrollTop);
    			}
    		},
    		
    		getAbsoluteLeft: function() {
    			var outLeft,
    				scrollLeft,
    				userViewLeft,
    				userViewIndex,
    				frozenColIndex,
    				headItemLeft,
    				mainContainer,
    				colIndex,
    				result;
    
    			colIndex = this.colIndex;
    			mainContainer = this.mainContainer;
    
    			outLeft = config.System.outerLeft;
    			scrollLeft = mainContainer.$el.scrollLeft();
    			headItemLeft = headItemCols.models[colIndex].get('left');
    
    			if (cache.TempProp.colFrozen) { //冻结情况
    				frozenColIndex = headItemCols.getIndexByAlias(cache.TempProp.colAlias);
    				if (frozenColIndex > colIndex) {
    					scrollLeft = 0;
    				}
    				userViewIndex = headItemCols.getIndexByAlias(cache.UserView.colAlias);
    				userViewLeft = headItemCols.models[userViewIndex].get('left');
    				result = headItemLeft - userViewLeft + outLeft - scrollLeft + 1;
    				return result;
    			} else { //非冻结情况
    				result = headItemLeft + outLeft - scrollLeft + 1;
    				return result;
    			}
    		},
    		getAbsoluteTop: function() {
    			var outTop,
    				scrollTop,
    				userViewTop,
    				userViewIndex,
    				frozenRowIndex,
    				mainContainer,
    				rowIndex,
    				headItemTop,
    				result;
    
    			rowIndex = this.rowIndex;
    			mainContainer = this.mainContainer;
    
    			outTop = config.System.outerTop;
    			scrollTop = mainContainer.$el.scrollTop();
    			headItemTop = headItemRows.models[rowIndex].get('top');
    
    			if (cache.TempProp.colFrozen) { //冻结情况
    				frozenRowIndex = headItemRows.getIndexByAlias(cache.TempProp.rowAlias);
    				if (frozenRowIndex > rowIndex) {
    					scrollTop = 0;
    				}
    				userViewIndex = headItemRows.getIndexByAlias(cache.UserView.rowAlias);
    				userViewTop = headItemRows.models[userViewIndex].get('top');
    				result = headItemTop - userViewTop + outTop - scrollTop + 1;
    				return result;
    			} else { //非冻结情况
    				result = headItemTop + outTop - scrollTop + 1;
    				return result;
    			}
    		},
    		adjustZIndex: function() {
    			var colIndex,
    				rowIndex,
    				frozenColIndex,
    				frozenRowIndex;
    
    			colIndex = this.colIndex;
    			rowIndex = this.rowIndex;
    
    			if (cache.TempProp.colFrozen && cache.TempProp.rowFrozen) { //冻结情况
    				frozenColIndex = headItemCols.getIndexByAlias(cache.TempProp.colAlias);
    				frozenRowIndex = headItemRows.getIndexByAlias(cache.TempProp.rowAlias);
    				if (frozenColIndex > colIndex && frozenRowIndex > rowIndex) {
    					this.$el.css({
    						'z-index': '15'
    					});
    				} else if (frozenColIndex > colIndex || frozenRowIndex > rowIndex) {
    					this.$el.css({
    						'z-index': '12'
    					});
    				} else {
    					this.$el.css({
    						'z-index': '9'
    					});
    				}
    			} else if (cache.TempProp.colFrozen) {
    				frozenColIndex = headItemCols.getIndexByAlias(cache.TempProp.colAlias);
    				if (frozenColIndex > colIndex) {
    					this.$el.css({
    						'z-index': '12'
    					});
    				} else {
    					this.$el.css({
    						'z-index': '9'
    					});
    				}
    			} else if (cache.TempProp.rowFrozen) {
    				frozenRowIndex = headItemRows.getIndexByAlias(cache.TempProp.rowAlias);
    				if (frozenRowIndex > rowIndex) {
    					this.$el.css({
    						'z-index': '12'
    					});
    				} else {
    					this.$el.css({
    						'z-index': '9'
    					});
    				}
    			} else { //非冻结情况
    				this.$el.css({
    					'z-index': '9'
    				});
    			}
    		},
    		
    		render: function() {
    			this.hide();
    			return this;
    		},
    		
    		adapt: function() {
    			if (this.showState === true) {
    				this.adjustWidth();
    				this.adjustHeight();
    			}
    		},
    		
    		adjustHeight: function() {
    			var height,
    				scrollBarHeight,
    				maxHeight,
    				minHeight,
    				fontSize,
    				width,
    				inputText,
    				texts,
    				text = '',
    				len, i;
    
    			scrollBarHeight = this.mainContainer.$el[0].offsetHeight - this.mainContainer.$el[0].clientHeight;
    			maxHeight = this.$el.parent().height() - this.$el.position().top - scrollBarHeight;
    			minHeight = this.model.get('physicsBox').height;
    
    			inputText = this.$el.val();
    
    			fontSize = this.model.get('content').size;
    			width = this.$el.width();
    
    			height = getTextBox.getInputHeight(inputText, fontSize, width);
    			height = height > minHeight ? height : minHeight;
    
    			if (height < maxHeight) {
    				this.$el.height(height);
    				return height;
    			} else {
    				this.$el.height(maxHeight);
    				return height;
    			}
    		},
    		
    		adjustWidth: function(init) {
    			var text = '',
    				texts,
    				width,
    				inputText,
    				scrollBarWidth,
    				currentWidth,
    				fontSize,
    				maxWidth,
    				minWidth,
    				len, i;
    
    
    			//不能超出当前显示区域
    			scrollBarWidth = this.mainContainer.$el[0].offsetWidth - this.mainContainer.$el[0].clientWidth;
    			maxWidth = this.$el.parent().width() - this.$el.position().left - scrollBarWidth;
    			minWidth = this.model.get('physicsBox').width - 1;
    
    			//自动换行，宽度等于输入框初始化列宽
    			if (this.model.get('wordWrap') === true) {
    				this.$el.width(minWidth);
    				return;
    			}
    			inputText = this.$el.val();
    			fontSize = this.model.get('content').size;
    			currentWidth = this.$el.width();
    
    			width = getTextBox.getInputWidth(inputText, fontSize) + 20;
    
    			width = width > minWidth ? width : minWidth;
    			if (!init) {
    				width = width > currentWidth ? width : currentWidth;
    			}
    			if (width < maxWidth) {
    				this.$el.width(width);
    				return width;
    			} else {
    				this.$el.width(maxWidth);
    				return maxWidth;
    			}
    
    		},
    		sendWordWrap: function(col, row) {
    			send.PackAjax({
    				url: config.url.cell.wordwrap,
    				data: JSON.stringify({
    					coordinate: {
    						startCol: col,
    						startRow: row,
    						endCol: col,
    						endRow: row
    					},
    					wordWrap: true
    				})
    			});
    		},
    		
    		sendChangeText: function(col, row, text) {
    			var text,
    				colAlias,
    				rowAlias,
    				colSort,
    				rowSort;
    			send.PackAjax({
    				url: config.url.cell.content,
    				data: JSON.stringify({
    					coordinate: {
    						startRow: row,
    						startCol: col,
    						endRow: row,
    						endCol: col
    					},
    					content: encodeURIComponent(text)
    				})
    			});
    		},
    		keydownHandle: function(event) {
    			var self = this,
    				available = config.shortcuts,
    				key = event.key,
    				reg = /^[a-zA-Z0-9]$/,
    				keyboard,
    				handle,
    				direction;
    
    			//处理中文输入法
    			if (event.keyCode === 229) {
    				if (this.showState === false) {
    					this.$el.val('');
    					this.show();
    				}
    				this.adapt();
    			}
    			//处理回车键
    			if (key === 'Enter') {
    				if (available.alt_enter && this.showState && event.altKey) {
    					shortcut.altEnter(this.el);
    					this.adjustHeight();
    					event.preventDefault();
    				} else if (available.enter && !event.altKey) {
    					if (this.showState === true) {
    						this.hide();
    					} else {
    						shortcut.arrow('DOWN');
    					}
    				}
    				return;
    			}
    
    			//处理删除按纽
    			if (available.delete && key === 'Delete' && !this.showState) {
    				shortcut.backspace();
    				return;
    			}
    
    			//处理方向键
    			if (available.arrow && key.indexOf('Arrow') === 0 && !this.showState) {
    				shortcut.arrow(key.substring('5').toUpperCase());
    				return;
    			}
    
    			//处理撤销按键
    			if (!this.showState && event.ctrlKey) {
    				if (available.redo && key.toUpperCase() === 'Y') {
    					done.redo();
    					return;
    				} else if (available.undo && key.toUpperCase() === 'Z') {
    					done.undo();
    					return;
    				}
    			}
    			if (!this.showState && reg.test(key) && !event.ctrlKey && !event.altKey) {
    				this.$el.val('');
    				this.show();
    			}
    			if (this.showState) {
    				this.adjustWidth();
    			}
    		},
    		
    		destroy: function() {
    			Backbone.off('event:InputContainer:show');
    			this.remove();
    		}
    	});
    	return InputContainer;
    });
    
    define('views/commentcontainer',function() {
    	var Backbone = require('lib/backbone'),
    		headItemCols = require('collections/headItemCol'),
    		headItemRows = require('collections/headItemRow'),
    		selectRegions = require('collections/selectRegion'),
    		config = require('spreadsheet/config'),
    		cells = require('collections/cells'),
    		cache = require('basic/tools/cache'),
    		commentHandler = require('entrance/tool/comment'),
    		commentContainer;
    
    	commentContainer = Backbone.View.extend({
    
    		tagName: 'textarea',
    
    		className: 'comment',
    
    		isTransverseScroll: false,
    
    		isVerticalScroll: false,
    
    		events: {
    			'blur': 'close'
    		},
    
    		initialize: function(options) {
    			this.parentNode = options.parentNode;
    		},
    
    		render: function() {
    			this.$el.css({
    				left: -1000,
    				top: -1000,
    				width: config.User.commentWidth + 'px',
    				height: config.User.commentHeight + 'px'
    			});
    			return this;
    		},
    		add: function(options) {
    			this.edit(options);
    			this.$el.val('');
    		},
    		edit: function(options) {
    			this.show(options);
    			this.$el.removeAttr('disabled');
    			this.$el.focus();
    		},
    
    		show: function(options) {
    			var colIndex = options.colIndex,
    				rowIndex = options.rowIndex,
    				comment = options.comment,
    				frozenColIndex,
    				frozenRowIndex,
    				selectModel,
    				cellList;
    
    			// 添加/编辑备注情况
    			if (typeof colIndex === 'undefined') {
    				selectModel = selectRegions.getModelByType('selected');
    				colIndex = headItemCols.getIndexByAlias(selectModel.get('wholePosi').endX);
    				rowIndex = headItemRows.getIndexByAlias(selectModel.get('wholePosi').startY);
    				cellList = cells.getCellByVertical(colIndex, rowIndex);
    				if (cellList.length === 1) {
    					comment = cellList[0].get('customProp').comment;
    				}
    			}
    			this.colIndex = colIndex;
    			this.rowIndex = rowIndex;
    
    			frozenColIndex = cache.TempProp.colFrozen && headItemCols.getIndexByAlias(cache.TempProp.colAlias);
    			frozenRowIndex = cache.TempProp.rowFrozen && headItemRows.getIndexByAlias(cache.TempProp.rowAlias);
    
    			if (frozenColIndex && frozenColIndex > colIndex) {
    				this.isTransverseScroll = false;
    			} else {
    				this.isTransverseScroll = true;
    			}
    			if (frozenRowIndex && frozenRowIndex > rowIndex) {
    				this.isVerticalScroll = false;
    			} else {
    				this.isVerticalScroll = true;
    			}
    
    			this.setBoxModel();
    
    			this.adjustZIndex(colIndex, rowIndex);
    			this.$el.attr('disabled', 'disabled');
    			this.$el.css('display', 'block');
    			this.$el.val(comment);
    		},
    		setBoxModel: function() {
    			var limitHeight,
    				limitWidth,
    				height,
    				width,
    				left,
    				top;
    
    			//获取相对位置
    			left = this.getAbsoluteLeft();
    			top = this.getAbsoluteTop();
    			height = config.System.comment.height; //默认高度
    			width = config.System.comment.width; //默认宽度
    			limitHeight = this.parentNode.el.clientHeight - config.System.outerBottom - 
    			cache.scrollbarWidth -(this.$el.outerHeight() - this.$el.height());
    
    			limitWidth = this.parentNode.el.clientWidth - cache.scrollbarWidth;
    			
    			
    
    			//批注框超出显示区域，直接放入不可见区域
    			if ( top >= limitHeight || left >= limitWidth ) {
    				this.$el.css({
    					left: -200,
    					top: -200,
    				});
    				return;
    			}
     
    			if (top + height > limitHeight) {
    				height = limitHeight - top;
    			}
    
    			if (left + width > limitWidth) {
    				//横向特殊处理，避免显示的备注条过细
    				if (limitWidth - left > 60) {
    					width = limitWidth - left;
    				} else {
    					left = limitWidth - width - 5;
    				}
    			}
    			this.$el.css({
    				left: left + 5,
    				top: top,
    				height: height,
    				width: width
    			});
    		},
    		hide: function() {
    			this.$el.css('display', 'none');
    			this.$el.attr('disabled', 'disabled');
    			this.isTransverseScroll = false;
    			this.isVerticalScroll = false;
    		},
    		
    		transverseScroll: function() {
    			if (!this.isTransverseScroll) {
    				return;
    			}
    			this.setBoxModel();
    		},
    		
    		verticalScroll: function() {
    			if (!this.isVerticalScroll) {
    				return;
    			}
    			this.setBoxModel();
    		},
    		
    		getAbsoluteLeft: function() {
    			var colIndex = this.colIndex,
    				left = config.System.outerLeft,
    				colModel;
    
    			//整行操作
    			if (colIndex === 'MAX') {
    				return left;
    			}
    
    			colModel = headItemCols.models[colIndex];
    			left += colModel.get('left') + colModel.get('width');
    
    			if (cache.TempProp.colFrozen) {
    				left -= headItemCols.getModelByAlias(cache.UserView.colAlias).get('left');
    			}
    
    			if (this.isTransverseScroll) {
    				left -= cache.viewRegion.scrollLeft;
    			}
    			return left;
    		},
    		getAbsoluteTop: function() {
    			var rowIndex = this.rowIndex,
    				top = config.System.outerTop,
    				rowModel;
    
    			//整行操作
    			if (rowIndex === 'MAX') {
    				return top;
    			}
    			rowModel = headItemRows.models[rowIndex];
    			top += rowModel.get('top');
    
    			if (cache.TempProp.rowFrozen) {
    				top -= headItemRows.getModelByAlias(cache.UserView.rowAlias).get('top');
    			}
    
    			if (this.isVerticalScroll) {
    				top -= cache.viewRegion.scrollTop;
    			}
    			return top;
    		},
    		adjustZIndex: function() {
    			
    			var isTransverseScroll = this.isTransverseScroll,
    				isVerticalScroll = this.isVerticalScroll;
    
    			if (cache.TempProp.colFrozen && cache.TempProp.rowFrozen) { //冻结情况
    				if (!isTransverseScroll && !isVerticalScroll) {
    					this.$el.css({
    						'z-index': '15'
    					});
    				} else if (!isTransverseScroll || !isVerticalScroll) {
    					this.$el.css({
    						'z-index': '12'
    					});
    				} else {
    					this.$el.css({
    						'z-index': '9'
    					});
    				}
    			} else if (cache.TempProp.colFrozen) {
    				if (!isTransverseScroll) {
    					this.$el.css({
    						'z-index': '12'
    					});
    				} else {
    					this.$el.css({
    						'z-index': '9'
    					});
    				}
    			} else if (cache.TempProp.rowFrozen) {
    				if (!isVerticalScroll) {
    					this.$el.css({
    						'z-index': '12'
    					});
    				} else {
    					this.$el.css({
    						'z-index': '9'
    					});
    				}
    			} else {
    				this.$el.css({
    					'z-index': '9'
    				});
    			}
    		},
    		close: function() {
    			var comment;
    			comment = this.$el.val();
    			comment = comment || '';
    			commentHandler.modifyComment('1', comment);
    			this.hide();
    		}
    	});
    	return commentContainer;
    });
    define('views/lockcontainer',function() {
        
        var Backbone = require('lib/backbone'),
            getTemplate = require('basic/tools/template'),
            getDisplayName = require('basic/tools/getdisplayname'),
            selectRegions = require('collections/selectRegion'),
            protect = require('entrance/tool/protect'),
            selects = require('collections/selectRegion'),
            cols = require('collections/headItemCol'),
            rows = require('collections/headItemRow'),
            cells = require('collections/cells'),
            cache = require('basic/tools/cache'),
            colList = cols.models,
            rowList = rows.models,
            cellList = cells.models,
            lockContainer;
    
        lockContainer = Backbone.View.extend({
            events: {
                'click .lock-toggle': 'toggle',
                'click .confirm': 'confirm',
                'click .cancel': 'close',
            },
            initialize: function() {
                var select = selectRegions.getModelByType('selected');
                this.listenTo(select, 'change:wholePosi', this.listenToSelect);
                this.lockState = null;
            },
            render: function() {
                var template = getTemplate('LOCKCONTAINER'),
                    startCol,
                    startRow,
                    endCol,
                    endRow,
                    region,
                    content,
                    checked = true,
                    cellList,
                    i, len;
    
                region = this.parseSelect();
                startCol = getDisplayName.getColDisplayName(region.startColIndex);
                startRow = getDisplayName.getRowDisplayName(region.startRowIndex);
                endCol = getDisplayName.getColDisplayName(region.endColIndex);
                endRow = getDisplayName.getRowDisplayName(region.endRowIndex);
    
                cellList = cells.getCellByVertical(region);
    
                for (i = 0, len = cellList.length; i < len; i++) {
                    if (!cellList[i].get('lock')) {
                        checked = false;
                    }
                }
                content = this.parseText({
                    col: [startCol, endCol],
                    row: [startRow, endRow]
                });
                this.$el.html(template());
                this.listenToSelect(selectRegions.getModelByType('selected'));
                return this;
            },
            listenToSelect: function(model) {
                var wholePosi = model.get('wholePosi'),
                    startCol,
                    endCol,
                    startRow,
                    endRow;
    
                startCol = cols.getIndexByAlias(wholePosi.startX);
                startRow = rows.getIndexByAlias(wholePosi.startY);
                endCol = cols.getIndexByAlias(wholePosi.endX);
                endRow = rows.getIndexByAlias(wholePosi.endY);
    
                this.onLock(startCol, startRow, endCol, endRow);
                this.onContent(startCol, startRow, endCol, endRow);
            },
            onLock: function(startCol, startRow, endCol, endRow) {
                //locked:包含锁定  unlocked:包未锁定
                var i, j, len, len2,
                    locked = false,
                    unlocked = false,
                    rowAlias, colAlias,
                    pos = cache.CellsPosition.strandX,
                    temp, tempRecord = {},
                    tempRowLock = {},
                    rowLocked,
                    colLocked;
    
                if (endCol === 'MAX') {
                    for (i = startRow, len = endRow + 1; i < len; i++) {
                        locked = (temp = !(rowList[i].get('operProp').locked === false)) || locked;
                        unlocked = !temp || unlocked;
                        if (locked && unlocked) {
                            break;
                        }
                    }
                } else if (endRow === 'MAX') {
                    for (i = startCol, len = endCol + 1; i < len; i++) {
                        locked = (temp = !(colList[i].get('operProp').locked === false)) || locked;
                        unlocked = !temp || unlocked;
                        if (locked && unlocked) {
                            break;
                        }
                    }
                } else {
                    outerLooP: for (i = startCol, len = endCol + 1; i < len; i++) {
                        colLocked = colList[i].get('operProp').locked;
                        colLocked = typeof colLocked === 'undefined' ? true : colLocked;
                        for (j = startRow, len2 = endRow + 1; j < len2; j++) {
                            rowAlias = rowList[j].get('alias');
                            colAlias = colList[i].get('alias');
    
                            if (typeof tempRowLock[j] === 'undefined') {
                                rowLocked = typeof(rowLocked = rowList[j].get('operProp').locked) === 'undefined' ? true : rowLocked;
                                tempRowLock[j] = rowLocked;
                            } else {
                                rowLocked = tempRowLock[j];
                            }
    
                            if (pos[colAlias] && typeof(temp = pos[colAlias][rowAlias]) !== 'undefined') {
                                if (!tempRecord[temp]) {
                                    tempRecord[temp] === true;
                                    temp = cellList[temp].get('locked');
                                    unlocked = !temp || unlocked;
                                    locked = temp || locked;
                                }
                            } else if (!rowLocked || !colLocked) {
                                unlocked = true;
                            } else {
                                locked = true;
                            }
                            if (locked && unlocked) {
                                break outerLooP;
                            }
                        }
    
                    }
                }
                if (locked && unlocked) {
                    this.lockState = 'half-locked';
                    this.$el.find('.checkbox').removeClass('checked');
                    this.$el.find('.checkbox').addClass('half-checked');
                } else if (locked) {
                    this.lockState = 'locked';
                    this.$el.find('.checkbox').removeClass('half-checked');
                    this.$el.find('.checkbox').addClass('checked');
                } else {
                    this.lockState = 'unlocked';
                    this.$el.find('.checkbox').removeClass('checked');
                    this.$el.find('.checkbox').removeClass('half-checked');
                }
            },
            onContent: function(startCol, startRow, endCol, endRow) {
                this.$el.find('input[type=text]').val(this.parseText(
                    colList[startCol].get('displayName'),
                    rowList[startRow].get('displayName'),
                    endCol === 'MAX' ? 'MAX' : colList[endCol].get('displayName'),
                    endRow === 'MAX' ? 'MAX' : rowList[endRow].get('displayName')
                ));
            },
            parseText: function(startColName, startRowName, endColName, endRowName) {
                var text = '';
                //整行操作
                if (endColName === 'MAX') {
                    if (startRowName !== endRowName) {
                        text = startRowName + ':' + endRowName;
                    } else {
                        text = startRowName;
                    }
                } else if (endRowName === 'MAX') { //整列操作
                    if (startColName !== endColName) {
                        text = startColName + ':' + endColName;
                    } else {
                        text = startColName;
                    }
                } else {
                    if ((startRowName === endRowName) && (startColName === endColName)) {
                        text = startColName + startRowName;
                    } else {
                        text = startColName + startRowName + ':' + endColName + endRowName;
                    }
                }
                return text;
            },
            parseSelect: function() {
                var select = selects.getModelByType('selected'),
                    wholePosi = select.get('wholePosi'),
                    startColIndex,
                    endColIndex,
                    startRowIndex,
                    endRowIndex;
    
                startColIndex = cols.getIndexByAlias(wholePosi.startX);
                startRowIndex = rows.getIndexByAlias(wholePosi.startY);
                endColIndex = cols.getIndexByAlias(wholePosi.endX);
                endRowIndex = rows.getIndexByAlias(wholePosi.endY);
    
                return {
                    startColIndex: startColIndex,
                    endColIndex: endColIndex,
                    startRowIndex: startRowIndex,
                    endRowIndex: endRowIndex
                }
            },
            toggle: function() {
                if (this.lockState === 'locked' || this.lockState === 'half-locked') {
                    this.lockState = 'unlocked';
                    this.$el.find('.checkbox').removeClass('checked');
                    this.$el.find('.checkbox').removeClass('half-checked');
                } else {
                    this.lockState = 'locked';
                    this.$el.find('.checkbox').removeClass('half-checked');
                    this.$el.find('.checkbox').addClass('checked');
                }
            },
            confirm: function(event) {
                event.preventDefault();
                if (this.lockState === 'half-locked') {
                    return;
                }
                if (this.lockState === 'locked') {
                    protect.lock();
                } else {
                    protect.unlock();
                }
                this.destroy();
            },
            close: function(event) {
                event.preventDefault();
                this.destroy();
            },
            destroy: function() {
                this.remove();
                Backbone.trigger('event:sidebarContainer:remove');
            }
        });
    
        return lockContainer;
    });
    define('views/validatecontainer',function() {
    	
    	var Backbone = require('lib/backbone'),
    		original = require('basic/tools/original'),
    		history = require('basic/tools/history'),
    		getTemplate = require('basic/tools/template'),
    		selects = require('collections/selectRegion'),
    		strandMap = require('basic/tools/strandmap'),
    		selectValidate = require('basic/tools/selectvalidate'),
    		cache = require('basic/tools/cache'),
    		config = require('spreadsheet/config'),
    		cols = require('collections/headItemCol'),
    		rows = require('collections/headItemRow'),
    		send = require('basic/tools/send'),
    		text2sort = require('basic/tools/text2sort'),
    		colList = cols.models,
    		rowList = rows.models,
    		ValidateContainer;
    
    	ValidateContainer = Backbone.View.extend({
    		events: {
    			'change select': 'changeType',
    			'click .confirm': 'confirm',
    			'click .select-out': 'toggleSelectState',
    			'click .cancel': 'close'
    		},
    		initialize: function() {
    			var select = selects.getModelByType('selected');
    			this.listenTo(select, 'change:wholePosi', this.listenToSelect);
    		},
    		render: function() {
    			var template = getTemplate('VALIDATETEMPLATE');
    			this.$el.html(template());
    
    			this.select = this.$el.find('select');
    			this.range = this.$el.find('.range');
    			this.source = this.$el.find('.source');
    			this.min = this.$el.find('.min');
    			this.max = this.$el.find('.max');
    			this.sourceData = this.$el.find('.source-data');
    			this.sourceBtn = this.$el.find('.select-out');
    			this.error = this.$el.find('.error');
    
    			this.listenToSelect(selects.getModelByType('selected'));
    			return this;
    		},
    		changeType: function(e) {
    			var type = e.target.value;
    			switch (type) {
    				case 'default':
    					this._toggleDefault();
    					break;
    				case 'intType':
    					this._toggleIntType();
    					break;
    				case 'decimalType':
    					this._toggleDecimalType();
    					break;
    				case 'sequenceType':
    					this._toggleSequenceType();
    					break;
    				case 'textType':
    					this._toggleTextType();
    					break;
    				default:
    					this._toggleDefault();
    					break;
    			}
    		},
    		toggleSelectState: function() {
    
    			this.selectSourceState = !this.selectSourceState;
    
    			if (this.selectSourceState) {
    				this.sourceBtn.addClass('on');
    				this.startSelectSource();
    			} else {
    				this.sourceBtn.removeClass('on');
    				this.endSelectSource();
    			}
    		},
    		startSelectSource: function() {
    			var select;
    			selects.each(function(select) {
    				if (select.get('selectType') !== 'selected') {
    					select.destroy();
    				}
    			});
    
    			select = selects.add({
    				'selectType': 'rulesource',
    				'physicsBox': {
    					'width': 0,
    					'height': 0,
    					'top': -100,
    					'left': -100,
    				}
    			});
    			this.listenTo(select, 'change:wholePosi', this.bindSourceSelect);
    			cache.mouseOperateState = config.mouseOperateState.ruleSource;
    			Backbone.trigger('event:cellsContainer:setMouseState', 'locatedState', 'ruleSourceLocatedState');
    			Backbone.trigger('event:colsHeadContainer:setMouseState', 'locatedState', 'ruleSourceLocatedState');
    			Backbone.trigger('event:rowsHeadContainer:setMouseState', 'locatedState', 'ruleSourceLocatedState');
    		},
    		endSelectSource: function() {
    			var select = selects.getModelByType('rulesource');
    
    			if (select) {
    				this.stopListening(select);
    				select.destroy();
    			}
    			cache.mouseOperateState = config.mouseOperateState.select;
    
    			Backbone.trigger('event:cellsContainer:setMouseState', 'locatedState', 'selectLocatedState');
    			Backbone.trigger('event:colsHeadContainer:setMouseState', 'locatedState', 'selectLocatedState');
    			Backbone.trigger('event:rowsHeadContainer:setMouseState', 'locatedState', 'selectLocatedState');
    		},
    		bindSourceSelect: function(model) {
    			var wholePosi = model.get('wholePosi'),
    				startCol,
    				endCol,
    				startRow,
    				endRow;
    
    			startCol = cols.getIndexByAlias(wholePosi.startX);
    			startRow = rows.getIndexByAlias(wholePosi.startY);
    			endCol = cols.getIndexByAlias(wholePosi.endX);
    			endRow = rows.getIndexByAlias(wholePosi.endY);
    
    			this.sourceData.val(this.parseText(
    				colList[startCol].get('displayName'),
    				rowList[startRow].get('displayName'),
    				endCol === 'MAX' ? 'MAX' : colList[endCol].get('displayName'),
    				endRow === 'MAX' ? 'MAX' : rowList[endRow].get('displayName')
    			));
    		},
    		parseText: function(startColName, startRowName, endColName, endRowName) {
    			var text = '=';
    			if (endColName === 'MAX') {
    				text += '$' + startRowName + ':' + '$' + endRowName;
    			} else if (endRowName === 'MAX') { //整列操作
    				text += '$' + startColName + ':' + '$' + endColName;
    			} else {
    				if ((startRowName === endRowName) && (startColName === endColName)) {
    					text += '$' + startColName + '$' + startRowName;
    				} else {
    					text += '$' + startColName + '$' + startRowName + ':' + '$' + endColName + '$' + endRowName;
    				}
    			}
    			return text;
    		},
    		inputValidator: function(type, formula1, formula2) {
    			var validators,
    				msg, len, i;
    
    			validators = {
    				intType: [intTypeValidator, intLenValidator, orderValidator],
    				decimalType: [decimalTypeValidator, intLenValidator, decimalLenValidator, orderValidator],
    				textType: [intTypeValidator, orderValidator],
    				sequenceType: [sequenceValidator]
    			}
    
    			if ((validators = validators[type]) !== undefined) {
    				for (i = 0, len = validators.length; i < len; i++) {
    					if ((msg = validators[i](formula1, formula2)) !== undefined) {
    						Backbone.trigger('event:showMsgBar:show', msg);
    						return false;
    					}
    				}
    			}
    			return true;
    
    			function intTypeValidator(formula1, formula2) {
    				var reg = /^([-]){0,1}[0-9]*$/;
    				if (!reg.test(formula1) || !reg.test(formula2)) {
    					return '输入内容格式错误';
    				}
    			}
    
    			function decimalTypeValidator(formula1, formula2) {
    				var reg = /^([-]){0,1}[0-9]+(.[0-9]*)?$/;
    				if (!reg.test(formula1) || !reg.test(formula2)) {
    					return '输入内容格式错误';
    				}
    			}
    
    			function intLenValidator(formula1, formula2) {
    				formula1 = formula1.split('.')[0];
    				formula2 = formula2.split('.')[0];
    				if (formula1.length > 9 || formula2.length > 9) {
    					return '整数位数不能超过9位';
    				}
    			}
    
    			function decimalLenValidator(formula1, formula2) {
    				formula1 = formula1.split('.')[1];
    				formula2 = formula2.split('.')[1];
    				if ((formula1 !== undefined && formula1.length > 6) ||
    					(formula2 !== undefined && formula2.length > 6)) {
    					return '小数位数不能超过6位';
    				}
    			}
    
    			function sequenceValidator(formula1) {
    				var region;
    				if (formula1.indexOf('=') !== 0) {
    					return;
    				}
    				region = text2sort(formula1);
    				if (!region) {
    					return '输入来源格式错误';
    				}
    				if (region.startRowSort > 9999 || (region.endRowSort !== 'MAX' && region.endRowSort > 9999) ||
    					region.startColSort > 25 || (region.endColSort !== 'MAX' && region.endColSort > 25)) {
    					return '来源范围超出最大支持';
    				}
    				if (region.startRowSort !== region.endRowSort && region.startColSort !== region.endColSort) {
    					return '来源只能选择单行单列';
    				}
    			}
    
    			function orderValidator(formula1, formula2) {
    				if (parseFloat(formula1) > parseFloat(formula2)) {
    					return '最大值不能小于最小值';
    				}
    
    			}
    		},
    		confirm: function() {
    			var type = this.select.val(),
    				max = this.max.val(),
    				min = this.min.val(),
    				ruleSource = this.sourceData.val(),
    				validationType,
    				formula1,
    				formula2,
    				rule = {};
    
    			switch (type) {
    				case 'default':
    					validationType = config.validationType.defaultType;
    					break;
    				case 'intType':
    					validationType = config.validationType.intType;
    					formula1 = min;
    					formula2 = max;
    					break;
    				case 'decimalType':
    					validationType = config.validationType.decimalType;
    					formula1 = min;
    					formula2 = max;
    					break;
    				case 'sequenceType':
    					validationType = config.validationType.sequenceType;
    					formula1 = ruleSource;
    					break;
    				case 'textType':
    					validationType = config.validationType.textType;
    					formula1 = min;
    					formula2 = max;
    					break;
    				default:
    					validationType = config.validationType.defaultType;
    					break;
    			}
    			if (!this.inputValidator(type, formula1, formula2)) {
    				return;
    			}
    			rule.validationType = validationType;
    			if (formula1 !== undefined) {
    				rule.formula1 = formula1;
    			}
    			if (formula2 !== undefined) {
    				rule.formula2 = formula2;
    			}
    			this.insertRule(rule);
    			this.close();
    		},
    		insertRule: function(rule) {
    			var select = selects.getModelByType('selected'),
    				wholePosi = select.get('wholePosi'),
    				startColIndex = cols.getIndexByAlias(wholePosi.startX),
    				startRowIndex = rows.getIndexByAlias(wholePosi.startY),
    				endColIndex = cols.getIndexByAlias(wholePosi.endX),
    				endRowIndex = rows.getIndexByAlias(wholePosi.endY),
    				rules = cache.validate,
    				originalIndex,
    				originalIndexRecord = [],
    				ruleIndex,
    				originalFormula1,
    				formula1,
    				colAlias,
    				rowAlias,
    				record,
    				i, j, key;
    
    			if (rule.validationType === config.validationType.sequenceType) {
    				originalFormula1 = rule.formula1;
    				rule.formula1 = this.getRegionAlias(originalFormula1);
    			}
    			for (key in rules) {
    				if (isEqual(rules[key], rule)) {
    					ruleIndex = parseInt(key);
    					break;
    				}
    			}
    			if (typeof ruleIndex === 'undefined') {
    				ruleIndex = cache.validateCounter;
    				cache.validateCounter++;
    				cache.validate[ruleIndex] = rule;
    			}
    			selectValidate.set(ruleIndex);
    
    
    			if (endColIndex === 'MAX') {
    				for (i = startRowIndex; i < endRowIndex + 1; i++) {
    					strandMap.addRowRecord(rowList[i].get('alias'), 'validate', ruleIndex);
    				}
    			} else if (endRowIndex === 'MAX') {
    				for (i = startColIndex; i < endColIndex + 1; i++) {
    					strandMap.addColRecord(colList[i].get('alias'), 'validate', ruleIndex);
    				}
    			} else {
    				for (i = startColIndex; i < endColIndex + 1; i++) {
    					for (j = startRowIndex; j < endRowIndex + 1; j++) {
    						colAlias = colList[i].get('alias');
    						rowAlias = rowList[j].get('alias');
    						originalIndex = strandMap.getPointRecord(colAlias, rowAlias, 'validate');
    						if (ruleIndex !== originalIndex) {
    							originalIndexRecord.push({
    								colSort: colList[i].get('sort'),
    								rowSort: rowList[j].get('sort'),
    								originalIndex: originalIndex
    							});
    							strandMap.addPointRecord(colAlias, rowAlias, 'validate', ruleIndex);
    						}
    					}
    				}
    				record = history.getValidateUpdateAction({
    					startColSort: colList[startColIndex].get('sort'),
    					startRowSort: rowList[startRowIndex].get('sort'),
    					endColSort: colList[endColIndex].get('sort'),
    					endRowSort: rowList[endRowIndex].get('sort')
    				}, ruleIndex, originalIndexRecord);
    				history.addAction(record);
    			}
    
    
    			if (rule.validationType === config.validationType.sequenceType &&
    				typeof rule.formula1 === 'object' &&
    				rule.formula1.endRowAlias !== 'MAX' &&
    				rule.formula1.endColAlias !== 'MAX') {
    				formula1 = rule.formula1;
    				strandMap.addPointRecord(formula1.startColAlias, formula1.startRowAlias, 'sourceToRuleIndex', ruleIndex);
    				strandMap.addPointRecord(formula1.endColAlias, formula1.endRowAlias, 'sourceToRuleIndex', ruleIndex);
    			}
    			this._sendData(rule, startColIndex, startRowIndex, endColIndex, endRowIndex, originalFormula1);
    
    			function isEqual(obj1, obj2) {
    				var key, value1, value2;
    				if (typeof obj1 !== 'object' || obj1 === null) {
    					return obj1 === obj2;
    				} else {
    					for (key in obj1) {
    						value1 = obj1[key];
    						if (!obj2) {
    							return false;
    						}
    						value2 = obj2[key];
    						if (typeof value1 !== 'object') {
    							if (value1 !== value2) {
    								return false;
    							}
    						} else {
    							if (!isEqual(value1, value2)) {
    								return false;
    							}
    						}
    					}
    				}
    				return true;
    			}
    		},
    		getRegionAlias: function(formula1) {
    
    			if (formula1.indexOf('=') !== 0) {
    				return formula1;
    			}
    
    			var region = text2sort(formula1),
    				endColIndex = cols.getIndexBySort(region.endColSort),
    				endRowIndex = rows.getIndexBySort(region.endRowSort);
    			return {
    				startColAlias: colList[cols.getIndexBySort(region.startColSort)].get('alias'),
    				startRowAlias: rowList[rows.getIndexBySort(region.startRowSort)].get('alias'),
    				endColAlias: endColIndex === 'MAX' ? 'MAX' : colList[endColIndex].get('alias'),
    				endRowAlias: endRowIndex === 'MAX' ? 'MAX' : rowList[endRowIndex].get('alias')
    			};
    		},
    		_sendData: function(rule, startColIndex, startRowIndex, endColIndex, endRowIndex, originalFormula1) {
    			var startCol = colList[startColIndex].get('sort'),
    				startRow = rowList[startRowIndex].get('sort'),
    				endCol = endColIndex === 'MAX' ? -1 : colList[endColIndex].get('sort'),
    				endRow = endRowIndex === 'MAX' ? -1 : rowList[endRowIndex].get('sort');
    
    			send.PackAjax({
    				url: config.url.sheet.validate,
    				data: JSON.stringify({
    					coordinate: [{
    						startCol: startCol,
    						startRow: startRow,
    						endRow: endRow,
    						endcol: endCol
    					}],
    					rule: {
    						formula1: originalFormula1 === undefined ? rule.formula1 : originalFormula1,
    						formula2: rule.formula2,
    						validationType: rule.validationType
    					}
    				})
    			});
    		},
    		listenToSelect: function(model) {
    			var wholePosi = model.get('wholePosi'),
    				existUnset = false,
    				startCol,
    				endCol,
    				startRow,
    				endRow,
    				cacheRuleIndex,
    				currentRuleIndex,
    				currentRule,
    				rules = [],
    				colAlias,
    				rowAlias,
    				i, j;
    
    			startCol = cols.getIndexByAlias(wholePosi.startX);
    			startRow = rows.getIndexByAlias(wholePosi.startY);
    			endCol = cols.getIndexByAlias(wholePosi.endX);
    			endRow = rows.getIndexByAlias(wholePosi.endY);
    
    			if (endCol === 'MAX') {
    				for (i = startRow; i < endRow + 1 && rules.length < 3; i++) {
    					rowAlias = rowList[i].get('alias');
    					currentRuleIndex = strandMap.getRowRecord(rowAlias, 'validate');
    					if (currentRuleIndex === undefined || cache.validate[currentRuleIndex].validationType === 0) {
    						existUnset = true;
    					} else if (cacheRuleIndex !== currentRuleIndex) {
    						currentRule = cache.validate[currentRuleIndex];
    						if (!currentRule) {
    							currentRule = this.getSequenceRule(-1, rowList[startRow].get('sort'));
    						}
    						rules.push(currentRule);
    						cacheRuleIndex = currentRuleIndex;
    					}
    				}
    			} else if (endRow === 'MAX') {
    				for (i = startCol; i < endCol + 1 && rules.length < 3; i++) {
    					colAlias = colList[i].get('alias');
    					currentRuleIndex = strandMap.getColRecord(colAlias, 'validate');
    					if (currentRuleIndex === undefined || cache.validate[currentRuleIndex].validationType === 0) {
    						existUnset = true;
    					} else if (cacheRuleIndex !== currentRuleIndex) {
    						currentRule = cache.validate[currentRuleIndex];
    						if (!currentRule) {
    							currentRule = this.getSequenceRule(colList[startCol].get('sort'), -1);
    						}
    						rules.push(currentRule);
    						cacheRuleIndex = currentRuleIndex;
    					}
    				}
    			} else {
    				outerLoop: for (i = startCol; i < endCol + 1; i++) {
    					for (j = startRow; j < endRow + 1; j++) {
    						colAlias = colList[i].get('alias');
    						rowAlias = rowList[j].get('alias');
    						currentRuleIndex = strandMap.calcPointRecord(colAlias, rowAlias, 'validate');
    						if (currentRuleIndex === undefined || ((currentRule = cache.validate[currentRuleIndex]) && currentRule.validationType === 0)) {
    							existUnset = true;
    						} else if (cacheRuleIndex !== currentRuleIndex) {
    							currentRule = cache.validate[currentRuleIndex];
    							if (!currentRule) {
    								currentRule = this.getSequenceRule(colList[startCol].get('sort'), rowList[startRow].get('sort'));
    							}
    							rules.push(currentRule);
    							cacheRuleIndex = currentRuleIndex;
    						}
    						if (rules.length > 1) {
    							break outerLoop;
    						}
    					}
    				}
    			}
    			this.onRule(rules, existUnset);
    		},
    		onRule: function(rules, existUnset) {
    			if (rules.length > 1) {
    				this._toggleDefault();
    				this._showError(true, '选中区域内包含多种校验规则');
    			} else if (rules.length === 1) {
    				switch (rules[0].validationType) {
    					case config.validationType.defaultType:
    						this._toggleDefault();
    						break;
    					case config.validationType.intType:
    						this._toggleIntType(rules[0].formula1, rules[0].formula2);
    						break;
    					case config.validationType.decimalType:
    						this._toggleDecimalType(rules[0].formula1, rules[0].formula2);
    						break;
    					case config.validationType.sequenceType:
    						this._toggleSequenceType(this.getShowText(rules[0].formula1));
    						break;
    					case config.validationType.textType:
    						this._toggleTextType(rules[0].formula1, rules[0].formula2);
    						break;
    					default:
    						this._toggleDefault();
    						break;
    				}
    				if (existUnset) {
    					this._showError(true, '选中区域内包含未设置校验规则单元格');
    				} else {
    					this._showError(false);
    				}
    			} else {
    				this._toggleDefault();
    				this._showError(false);
    			}
    		},
    		getShowText: function(region) {
    			var startRowIndex,
    				startColIndex,
    				endRowIndex,
    				endColIndex;
    
    			if (typeof region === 'string') {
    				return region
    			}
    
    			startColIndex = cols.getIndexByAlias(region.startColAlias);
    			endColIndex = cols.getIndexByAlias(region.endColAlias);
    			startRowIndex = rows.getIndexByAlias(region.startRowAlias);
    			endRowIndex = rows.getIndexByAlias(region.endRowAlias);
    
    			return this.parseText(
    				colList[startColIndex].get('displayName'),
    				rowList[startRowIndex].get('displayName'),
    				endColIndex === 'MAX' ? 'MAX' : colList[endColIndex].get('displayName'),
    				endRowIndex === 'MAX' ? 'MAX' : rowList[endRowIndex].get('displayName')
    			)
    		},
    		getSequenceRule: function(colSort, rowSort) {
    			var result;
    			send.PackAjax({
    				url: config.url.sheet.validateFull,
    				isPublic: false,
    				data: JSON.stringify({
    					oprCol: colSort,
    					oprRow: rowSort
    				}),
    				success: function(data) {
    					var rule = data.rule;
    					rule.index = data.index;
    					rule.validationType = config.validationType.sequenceType;
    					original.analysisValidateRule({
    						rule: rule
    					});
    					result = rule;
    				}
    			});
    			return result;
    		},
    		_showError: function(flag, msg) {
    			if (flag) {
    				this.error.text(msg).addClass('active');
    			} else {
    				this.error.text(msg).removeClass('active');
    			}
    		},
    		_toggleDefault: function() {
    			this.select.val('default');
    			this.range.removeClass('active');
    			this.source.removeClass('active');
    		},
    		_toggleIntType: function(min, max) {
    			this.select.val('intType');
    			this.range.addClass('active');
    			this.source.removeClass('active');
    			this.min.val(min === undefined ? '' : min);
    			this.max.val(max === undefined ? '' : max);
    		},
    		_toggleDecimalType: function(min, max) {
    			this.select.val('decimalType');
    			this.range.addClass('active');
    			this.source.removeClass('active');
    			this.min.val(min === undefined ? '' : min);
    			this.max.val(max === undefined ? '' : max);
    		},
    		_toggleSequenceType: function(source) {
    			this.select.val('sequenceType');
    			this.source.addClass('active');
    			this.range.removeClass('active');
    			this.sourceData.val(source === undefined ? '' : source);
    		},
    		_toggleTextType: function(min, max) {
    			this.select.val('textType');
    			this.range.addClass('active');
    			this.source.removeClass('active');
    			this.min.val(min === undefined ? '' : min);
    			this.max.val(max === undefined ? '' : max);
    		},
    		close: function() {
    			this.endSelectSource();
    			this.destroy();
    		},
    		destroy: function() {
    			this.remove();
    			Backbone.trigger('event:sidebarContainer:remove');
    		}
    	});
    	return ValidateContainer;
    });
    define('views/protectcontainer',function() {
        
        var Backbone = require('lib/backbone'),
            getTemplate = require('basic/tools/template'),
            getDisplayName = require('basic/tools/getdisplayname'),
            listener = require('basic/util/listener'),
            protect = require('entrance/tool/protect'),
            selects = require('collections/selectRegion'),
            cols = require('collections/headItemCol'),
            rows = require('collections/headItemRow'),
            cells = require('collections/cells'),
            cache = require('basic/tools/cache'),
            protectContainer;
    
        protectContainer = Backbone.View.extend({
            events: {
                'click .confirm': 'confirm',
                'click .cancel': 'close',
            },
            render: function() {
                var template = getTemplate('PROTECTCONTAINER');
                this.$el.html(template());
                return this;
            },
            confirm: function(event) {
                event.preventDefault();
                var value = this.$el.find('input[type=password]').val();
                if (cache.protectState) {
                    if (!protect.cancel(value)) {
                        Backbone.trigger('event:showMsgBar:show', '输入密码错误!');
                        return;
                    }
                } else {
                    protect.execute(value);
                }
                this.close();
            },
            close: function(event) {
                event && event.preventDefault();
                this.remove();
                Backbone.trigger('event:sidebarContainer:remove');
            }
        });
    
        return protectContainer;
    });
    define('views/sidebarcontainer',function() {
    	
    	var SiderbarContainer,
    		Backbone = require('lib/backbone'),
    		getTemplate = require('basic/tools/template'),
    		cache = require('basic/tools/cache'),
    		config = require('spreadsheet/config'),
    		LockContainer = require('views/lockcontainer'),
    		ValidateContainer = require('views/validatecontainer'),
    		ProtectContainer = require('views/protectcontainer');
    
    	SiderbarContainer = Backbone.View.extend({
    		className: 'siderbar',
    		events: {
    			'click .close': 'close'
    		},
    		initialize: function(options) {
    			this.type = options.type;
    		},
    		render: function() {
    			var template = getTemplate('SIDERBARTEMPLATE'),
    				title = '',
    				child;
    			switch (this.type) {
    				case 'lock':
    					title = '单元格锁定';
    					child = new LockContainer();
    					break;
    				case 'protect':
    					title = cache.protectState ? '撤销保护工作簿' : '保护工作薄';
    					child = new ProtectContainer();
    					break;
    				case 'validate':
    					title = '数据验证';
    					child = new ValidateContainer();
    					break;
    				default:
    					break;
    			}
    
    			this.$el.html(template({
    				title: title
    			}));
    			if (child) {
    				this.$el.find('.siderbar-body').append(child.render().el);
    			}
    
    			this.$el.css({
    				width: config.sidebarWidth
    			});
    			return this;
    		},
    		close: function(e) {
    			e.preventDefault();
    			Backbone.trigger('event:sidebarContainer:remove');
    		},
    		destroy: function() {
    			this.remove();
    		}
    	});
    
    	return SiderbarContainer;
    });
    define('views/sequencecontainer',function() {
    	
    	var Backbone = require('lib/backbone'),
    		strandMap = require('basic/tools/strandmap'),
    		getTemplate = require('basic/tools/template'),
    		cache = require('basic/tools/cache'),
    		send = require('basic/tools/send'),
    		selectValidate = require('basic/tools/selectvalidate'),
    		setCellContent = require('entrance/tool/setcellcontent'),
    		text2sort = require('basic/tools/text2sort'),
    		selects = require('collections/selectRegion'),
    		original = require('basic/tools/original'),
    		cols = require('collections/headItemCol'),
    		rows = require('collections/headItemRow'),
    		cells = require('collections/cells'),
    		config = require('spreadsheet/config'),
    		colList = cols.models,
    		rowList = rows.models,
    		SequenceContainer;
    
    	SequenceContainer = Backbone.View.extend({
    
    		className: 'sequence',
    
    		events: {
    			'click .sequence-btn': 'toggleSequenceList',
    			'click .sequence-list': 'clickHandle',
    		},
    		initialize: function() {
    			var select = this.select = selects.getModelByType('selected');
    			this.cacheUserViewCol = {};
    			this.cacheUserViewRow = {};
    			this.listenTo(select, 'change:wholePosi', this.local);
    		},
    		render: function() {
    			var template = getTemplate('SEQUENCETEMPLATE');
    			this.childTemplate = getTemplate('SEQUENCEITEMTEMPLATE');
    			this.$el.html(template());
    			this.$list = this.$el.find('.sequence-list');
    			this.$btn = this.$el.find('.sequence-btn');
    			selectValidate.addSubscriber(this);
    			this.local();
    			return this;
    		},
    		local: function() {
    			var select = this.select,
    				colAlias = select.get('wholePosi').startX,
    				rowAlias = select.get('wholePosi').startY,
    				ruleIndex = strandMap.calcPointRecord(colAlias, rowAlias, 'validate'),
    				rule;
    
    			if (ruleIndex === undefined) {
    				this.hide();
    			} else if (!(rule = cache.validate[ruleIndex]) ||
    				rule.validationType === config.validationType.sequenceType) {
    				selectValidate.set(ruleIndex);
    				this.show();
    			} else {
    				this.hide();
    			}
    
    		},
    		changeRule: function() {
    			var ruleIndex = selectValidate.get(),
    				rule;
    
    			if (ruleIndex !== null && ruleIndex !== undefined) {
    				rule = cache.validate[ruleIndex];
    				if (!rule || rule.validationType === config.validationType.sequenceType) {
    					this.show();
    				}
    			} else {
    				this.hide();
    			}
    
    		},
    		show: function() {
    			var select = selects.getModelByType('selected'),
    				colAlias = select.get('wholePosi').startX,
    				rowAlias = select.get('wholePosi').startY,
    				colIndex = cols.getIndexByAlias(colAlias),
    				rowIndex = rows.getIndexByAlias(rowAlias),
    				frozenColIndex,
    				frozenRowIndex,
    				cellModel;
    
    			cellModel = cells.getCellByVertical(colIndex, rowIndex)[0];
    
    			if (cellModel) {
    				this.colIndex = colIndex + cellModel.get('occupy').x.length - 1;
    			} else {
    				this.colIndex = colIndex;
    			}
    			this.rowIndex = rowIndex;
    
    			frozenColIndex = cache.TempProp.colFrozen && cols.getIndexByAlias(cache.TempProp.colAlias);
    			frozenRowIndex = cache.TempProp.rowFrozen && rows.getIndexByAlias(cache.TempProp.rowAlias);
    
    			if (frozenColIndex && frozenColIndex > colIndex) {
    				this.isTransverseScroll = false;
    			} else {
    				this.isTransverseScroll = true;
    			}
    			if (frozenRowIndex && frozenRowIndex > rowIndex) {
    				this.isVerticalScroll = false;
    			} else {
    				this.isVerticalScroll = true;
    			}
    
    			this.adjustZIndex(colIndex, rowIndex);
    			this.adjustWidth(rowIndex);
    			this.adjustBtnPosi(colIndex);
    			this.hideSequenceList();
    
    			this.$el.css('display', 'block');
    			this.$el.css('left', this.getAbsoluteLeft());
    			this.$el.css('top', this.getAbsoluteTop());
    		},
    		hide: function() {
    			this.isTransverseScroll = false;
    			this.isVerticalScroll = false;
    			this.hideSequenceList();
    			this.$el.css('display', 'none');
    		},
    		clickHandle: function(event) {
    			event.preventDefault();
    			var value = event.target.innerText;
    			setCellContent('sheetId', value);
    			this.hide();
    		},
    		transverseScroll: function() {
    			if (!this.isTransverseScroll) {
    				return;
    			}
    			this.$el.css('left', this.getAbsoluteLeft());
    		},
    		verticalScroll: function() {
    			if (!this.isVerticalScroll) {
    				return;
    			}
    			this.$el.css('top', this.getAbsoluteTop());
    		},
    		toggleSequenceList: function() {
    			if (this.listState) {
    				this.hideSequenceList();
    			} else {
    				this.openSequenceList();
    			}
    		},
    		openSequenceList: function() {
    			var ruleIndex = selectValidate.get(),
    				rule = cache.validate[ruleIndex],
    				formula1,
    				self = this,
    				textList = [],
    				cellList,
    				len, i;
    
    			if (rule) {
    				formula1 = rule.formula1;
    				if (typeof formula1 === 'object') {
    					cellList = cells.getCellByVertical(cols.getIndexByAlias(formula1.startColAlias),
    						rows.getIndexByAlias(formula1.startRowAlias),
    						cols.getIndexByAlias(formula1.endColAlias),
    						rows.getIndexByAlias(formula1.endRowAlias)
    					);
    					for (i = 0, len = cellList.length; i < len; i++) {
    						textList.push(cellList[i].get('content').texts);
    					}
    				} else {
    					textList = formula1.split(',');
    				}
    				generateList(textList);
    			} else {
    				getRule();
    			}
    
    			function getRule() {
    				send.PackAjax({
    					url: config.url.sheet.validateFull,
    					isPublic: false,
    					data: JSON.stringify({
    						oprCol: colList[self.colIndex].get('sort'),
    						oprRow: rowList[self.rowIndex].get('sort')
    					}),
    					success: function(data) {
    						var rule = data.rule,
    							list = data.expResult;
    
    						rule.index = data.index;
    						original.analysisValidateRule({
    							rule: rule
    						});
    						generateList(list);
    					}
    				});
    			}
    
    			function generateList(textList) {
    				var i, len,
    					copyTextList = [];
    
    				for (i = 0, len = textList.length; i < len; i++) {
    					if (textList[i]) {
    						copyTextList.push(textList[i]);
    					}
    				}
    				if (copyTextList.length === 0) {
    					return;
    				}
    				self.listState = !self.listState;
    				self.$list.empty();
    				self.$list.addClass('active');
    
    				for (i = 0, len = copyTextList.length; i < len; i++) {
    					self.$list.append(self.childTemplate({
    						content: copyTextList[i]
    					}));
    				}
    
    			}
    		},
    		hideSequenceList: function() {
    			this.listState = false;
    			this.$list.removeClass('active');
    		},
    		
    		getAbsoluteLeft: function() {
    			var colIndex = this.colIndex,
    				left = config.System.outerLeft,
    				userViewColAlias = cache.UserView.colAlias,
    				userViewColIndex;
    
    			left += colList[colIndex].get('left');
    
    			if (cache.TempProp.colFrozen) {
    				if (userViewColIndex = this.cacheUserViewCol[userViewColAlias] === undefined) {
    					userViewColIndex = cols.getIndexByAlias(userViewColAlias);
    					this.cacheUserViewCol[userViewColAlias] = userViewColIndex;
    				}
    				left -= colList[userViewColIndex].get('left');
    			}
    			if (this.isTransverseScroll) {
    				left -= cache.viewRegion.scrollLeft;
    			}
    			return left;
    		},
    		getAbsoluteTop: function(rowIndex) {
    			var rowIndex = this.rowIndex,
    				top = config.System.outerTop,
    				userViewRowAlias = cache.UserView.rowAlias,
    				userViewRowIndex;
    
    			top += rowList[rowIndex].get('top') + rowList[rowIndex].get('height');
    
    			if (cache.TempProp.rowFrozen) {
    				if (userViewRowIndex = this.cacheUserViewRow[userViewRowAlias] === undefined) {
    					userViewRowIndex = rows.getIndexByAlias(userViewRowAlias);
    					this.cacheUserViewCol[userViewColAlias] = userViewRowIndex;
    				}
    				top -= rowList[userViewRowIndex].get('top');
    			}
    
    			if (this.isVerticalScroll) {
    				top -= cache.viewRegion.scrollTop;
    			}
    			return top;
    		},
    		adjustWidth: function() {
    			var colIndex = this.colIndex,
    				width = colList[colIndex].get('width');
    
    			this.$el.width(width);
    		},
    		adjustBtnPosi: function(colIndex) {
    			if (colIndex !== cols.length - 1) {
    				this.$btn.addClass('sequence-btn-right');
    				this.$btn.removeClass('sequence-btn-left');
    			} else {
    				this.$btn.addClass('sequence-btn-left');
    				this.$btn.removeClass('sequence-btn-right');
    			}
    		},
    		adjustZIndex: function() {
    			var isTransverseScroll = this.isTransverseScroll,
    				isVerticalScroll = this.isVerticalScroll;
    
    			if (cache.TempProp.colFrozen && cache.TempProp.rowFrozen) { //冻结情况
    				if (!isTransverseScroll && !isVerticalScroll) {
    					this.$el.css({
    						'z-index': '15'
    					});
    				} else if (!isTransverseScroll || !isVerticalScroll) {
    					this.$el.css({
    						'z-index': '12'
    					});
    				} else {
    					this.$el.css({
    						'z-index': '9'
    					});
    				}
    			} else if (cache.TempProp.colFrozen) {
    				if (!isTransverseScroll) {
    					this.$el.css({
    						'z-index': '12'
    					});
    				} else {
    					this.$el.css({
    						'z-index': '9'
    					});
    				}
    			} else if (cache.TempProp.rowFrozen) {
    				if (!isVerticalScroll) {
    					this.$el.css({
    						'z-index': '12'
    					});
    				} else {
    					this.$el.css({
    						'z-index': '9'
    					});
    				}
    			} else {
    				this.$el.css({
    					'z-index': '9'
    				});
    			}
    		},
    		destory: function() {
    			this.remove();
    		}
    	});
    	return SequenceContainer;
    });
    define('views/bodyContainer',function() {
    	
    	var $ = require('lib/jquery'),
    		Backbone = require('lib/backbone'),
    		config = require('spreadsheet/config'),
    		cache = require('basic/tools/cache'),
    		getTemplate = require('basic/tools/template'),
    		observerPattern = require('basic/util/observer.pattern'),
    		headItemRows = require('collections/headItemRow'),
    		headItemCols = require('collections/headItemCol'),
    		selectRegions = require('collections/selectRegion'),
    		siderLineCols = require('collections/siderLineCol'),
    		siderLineRows = require('collections/siderLineRow'),
    		cells = require('collections/cells'),
    		original = require('basic/tools/original'),
    		SheetsContainer = require('views/sheetsContainer'),
    		MainContainer = require('views/mainContainer'),
    		ColsPanelContainer = require('views/colsPanelContainer'),
    		RowsPanelContainer = require('views/rowsPanelContainer'),
    		InputContainer = require('views/inputContainer'),
    		CommentContainer = require('views/commentcontainer'),
    		SidebarContainer = require('views/sidebarcontainer'),
    		SequenceContainer = require('views/sequencecontainer'), 
    		BodyContainer;
    
    	
    	BodyContainer = Backbone.View.extend({
    		
    		events: {
    			
    			'mousemove': 'mouseInfo',
    			'mouseup': 'getFocus'
    		},
    		
    		initialize: function() {
    			Backbone.on('event:bodyContainer:executiveFrozen', this.executiveFrozen, this);
    			Backbone.on('event:bodyContainer:handleComment', this.handleComment, this);
    			Backbone.on('event:sidebarContainer:show', this.showSiderBar, this);
    			Backbone.on('event:sidebarContainer:remove', this.removeSiderBar, this);
    			Backbone.on('event:showMsgBar:show', this.showMsgBar, this);
    			Backbone.on('event:reload', this.reload, this);
    			this.commentContainer = null;
    		},
    		
    		render: function() {
    			var template = getTemplate('BODYTEMPLATE'),
    				inputContainer = this.inputContainer = new InputContainer(),
    				sequenceContainer = new SequenceContainer();
    
    			observerPattern.buildSubscriber(sequenceContainer);
    			sequenceContainer.subscribe('mainContainer', 'transversePublish', 'transverseScroll');
    			sequenceContainer.subscribe('mainContainer', 'verticalPublish', 'verticalScroll');
    
    			observerPattern.buildSubscriber(inputContainer);
    			inputContainer.subscribe('mainContainer', 'transversePublish', 'transverseScroll');
    			inputContainer.subscribe('mainContainer', 'verticalPublish', 'verticalScroll');
    			
    			this.$el.html(template());
    			this.$el.find('.main-layout').append(sequenceContainer.render().el);
    			this.$el.find('.main-layout').append(inputContainer.render().el);
    
    			this.calculation();
    			this.adaptScreen();
    			this.generateSheet();
    			this.$el.css({
    				'overflow': 'hidden',
    				'position': 'relative'
    			});
    			inputContainer.$el.focus();
    		},
    		showMsgBar: function(msg) {
    			var template = getTemplate('MSGCONTAINER'),
    				self = this;
    
    			this.$el.find('.main-layout').append(template({
    				msg: msg
    			}));
    			setTimeout(function() {
    				self.$el.find('.msg').remove();
    			}, 1500);
    		},
    		
    		showSiderBar: function(type) {
    			this.removeSiderBar();
    			//保护状态，禁止其他类型弹框
    			if (cache.protectState && type !== 'protect') {
    				return;
    			}
    			this.SidebarContainer = new SidebarContainer({
    				type: type
    			});
    			this.$el.find('.main-layout').append(this.SidebarContainer.render().el);
    			cache.sidebarState = true;
    			Backbone.trigger('event:changeSidebarContainer');
    		},
    		
    		removeSiderBar: function() {
    			if (this.SidebarContainer) {
    				this.SidebarContainer.destroy();
    				this.SidebarContainer = null;
    			}
    			cache.sidebarState = false;
    			Backbone.trigger('event:changeSidebarContainer');
    		},
    		handleComment: function(options) {
    			var action = options.action,
    				commentContainer;
    
    			if (!this.commentContainer) {
    				commentContainer = this.commentContainer = new CommentContainer({
    					parentNode: this
    				});
    				observerPattern.buildSubscriber(commentContainer);
    				this.$el.find('.main-layout').append(commentContainer.render().el);
    				commentContainer.subscribe('mainContainer', 'transversePublish', 'transverseScroll');
    				commentContainer.subscribe('mainContainer', 'verticalPublish', 'verticalScroll');
    			}
    			if (action === 'hide') {
    				this.commentContainer.hide();
    			} else if (action === 'edit') {
    				this.commentContainer.edit(options);
    			} else if (action === 'add') {
    				this.commentContainer.add(options);
    			} else {
    				this.commentContainer.show(options);
    			}
    		},
    		generateSheet: function() {
    			var sheetsView = new SheetsContainer();
    			this.sheetsView = sheetsView;
    			this.$el.find('.sheet-cf-list').append(sheetsView.render().el);
    		},
    		
    		getFocus: function(e) {
    			//判断输入框状态，如果输入框未失去焦点，不进行隐藏
    			var el = this.inputContainer.el,
    				focus = $(':focus')[0];
    
    			if (el !== focus) {
    				if (!focus) {
    					el.focus();
    				}
    			}
    		},
    		
    		saveUserView: function() {
    			var data = {
    				excelId: window.SPREADSHEET_AUTHENTIC_KEY,
    				sheetId: $("#sheetId").val(),
    				startX: cache.UserView.rowAlias,
    				startY: cache.UserView.colAlias
    			};
    		},
    		
    		adaptScreen: function() {
    			//待修改（应该把不冻结情况下代码独立）
    			this.executiveFrozen();
    		},
    		
    		clearFrozenRule: function() {
    			cache.FrozenRules = {
    				main: [],
    				row: [],
    				col: []
    			};
    		},
    		
    		executiveFrozen: function() {
    			var customID = '#' + this.el.id,
    				modelRowList = headItemRows,
    				modelColList = headItemCols,
    				self = this,
    				i, j,
    				len,
    				mainContainer;
    
    			this.clearFrozenRule();
    
    			this.ruleRow();
    			this.ruleCol();
    			this.ruleMain();
    
    			// destory old view
    			Backbone.trigger('event:colsPanelContainer:destroy');
    			Backbone.trigger('event:rowsPanelContainer:destroy');
    			Backbone.trigger('event:mainContainer:destroy');
    
    			//build new view
    			if (cache.TempProp.colFrozen && !cache.TempProp.rowFrozen) {
    				//main rules
    				len = cache.FrozenRules.main.length;
    				for (i = len - 1; i >= 0; i--) {
    					cache.CurrentRule = cache.FrozenRules.main[i];
    					//添加白色背景，并设置z值
    					mainContainer = new MainContainer({
    						parentNode: this
    					});
    					$('tr:eq(1) td:eq(' + (i + 1) + ')', customID).prepend(mainContainer.render().el);
    					buildObserverPattern(mainContainer);
    				}
    			} else if (!cache.TempProp.colFrozen && cache.TempProp.rowFrozen) {
    				//main rules
    				len = cache.FrozenRules.main.length;
    				for (i = len - 1; i >= 0; i--) {
    					cache.CurrentRule = cache.FrozenRules.main[i];
    					mainContainer = new MainContainer({
    						parentNode: this
    					});
    					$('tr:eq(1) td:eq(2)', customID).prepend(mainContainer.render().el);
    					buildObserverPattern(mainContainer);
    				}
    			} else if (cache.TempProp.colFrozen && cache.TempProp.rowFrozen) {
    				var currentPosi;
    				for (i = 4; i > 0; i--) {
    					currentPosi = i % 2 ? 1 : 2;
    					cache.CurrentRule = cache.FrozenRules.main[i - 1];
    					mainContainer = new MainContainer({
    						parentNode: this
    					});
    					$('tr:eq(1) td:eq(' + currentPosi + ')', customID).prepend(mainContainer.render().el);
    					buildObserverPattern(mainContainer);
    				}
    			} else if (!cache.TempProp.colFrozen && !cache.TempProp.rowFrozen) {
    				cache.CurrentRule = cache.FrozenRules.main[0];
    				mainContainer = new MainContainer({
    					parentNode: this
    				});
    				$('tr:eq(1) td:eq(2)', customID).append(mainContainer.render().el);
    				buildObserverPattern(mainContainer);
    			}
    			//colspanel rules
    			len = cache.FrozenRules.col.length;
    			for (i = 0; i < len; i++) {
    				cache.CurrentRule = cache.FrozenRules.col[i];
    				var colsPanelContainer = new ColsPanelContainer();
    				$('tr:eq(0) td:eq(' + (3 - len + i) + ')', customID).append(colsPanelContainer.render().el);
    				buildObserverPattern(colsPanelContainer);
    			}
    			//rowpanel rules
    			len = cache.FrozenRules.row.length;
    			for (i = len - 1; i >= 0; i--) {
    				cache.CurrentRule = cache.FrozenRules.row[i];
    				var rowsPanelContainer = new RowsPanelContainer();
    				$('tr:eq(1) td:eq(0)', customID).prepend(rowsPanelContainer.render().el);
    				buildObserverPattern(rowsPanelContainer);
    			}
    			
    			function buildObserverPattern(container) {
    				var currentRule = cache.CurrentRule,
    					currentSubscribe, len, i;
    
    				currentSubscribe = currentRule.isSubscribe || false;
    
    				if (currentRule.isPublisher) {
    					observerPattern.buildPublisher(container);
    				}
    
    				if (currentSubscribe) {
    					len = currentSubscribe.length;
    					observerPattern.buildSubscriber(container);
    
    					for (i = 0; i < len; i++) {
    						container.subscribe(currentSubscribe[i].publisherName,
    							currentSubscribe[i].action,
    							currentSubscribe[i].behavior);
    					}
    
    				}
    
    			}
    			// this.initMainView();
    		},
    		
    		ruleCol: function() {
    			var currentIndex,
    				currentModel,
    				currentModelLeft,
    				modelList,
    				tempRule,
    				userViewModel,
    				userViewIndex,
    				current;
    			modelList = headItemCols;
    
    			currentIndex = modelList.getIndexByAlias(cache.TempProp.colAlias);
    			if (currentIndex === -1) currentIndex = 0;
    			currentModel = modelList.models[currentIndex];
    			currentModelLeft = currentModel.toJSON().left;
    
    			userViewModel = modelList.getModelByAlias(cache.UserView.colAlias);
    			userViewIndex = modelList.getIndexByAlias(cache.UserView.colAlias);
    
    			if (cache.TempProp.isFrozen && cache.TempProp.colFrozen) {
    				tempRule = {
    					displayPosition: {
    						offsetLeft: 0, // must
    						startIndex: userViewIndex,
    						startAlias: cache.UserView.colAlias,
    						endAlias: cache.TempProp.colAlias,
    						endIndex: currentIndex
    					},
    					boxAttributes: {
    						width: currentModelLeft - userViewModel.toJSON().left - 1,
    						style: 'frozen-right-border'
    					},
    					autoScroll: false,
    					reduceUserView: true
    				};
    				cache.FrozenRules.col.push(tempRule);
    			} else {
    				currentModelLeft = 0;
    			}
    			tempRule = {
    				displayPosition: {
    					offsetLeft: currentModelLeft,
    					startAlias: cache.TempProp.colAlias,
    					startIndex: currentIndex
    				},
    				boxAttributes: {
    					width: this.scrollWidth - this.scrollbarWidth - currentModelLeft
    				},
    				autoScroll: true,
    				isSubscribe: [{
    					publisherName: 'mainContainer',
    					behavior: 'scrollToPosition', //it's self behavior
    					action: 'transversePublish' //publisher behavior
    				}]
    			};
    
    			if (cache.TempProp.isFrozen && cache.TempProp.colFrozen) {
    				tempRule.displayPosition.offsetLeft -= userViewModel.get('left');
    				tempRule.boxAttributes.width += userViewModel.toJSON().left;
    				tempRule.reduceUserView = true;
    			}
    			cache.FrozenRules.col.push(tempRule);
    		},
    		
    		ruleRow: function() {
    			var modelList, currentIndex, currentModel, tempRule, currentModelTop, userViewModel, userViewIndex;
    			modelList = headItemRows;
    
    			currentIndex = modelList.getIndexByAlias(cache.TempProp.rowAlias);
    
    			if (currentIndex === -1) {
    				currentModelTop = 0;
    			} else {
    				currentModel = modelList.models[currentIndex];
    				currentModelTop = currentModel.toJSON().top;
    			}
    
    			userViewIndex = modelList.getIndexByAlias(cache.UserView.rowAlias);
    			userViewModel = modelList.models[userViewIndex];
    
    
    			// 如果索引不是0，说明锁定需要分为两块
    			if (cache.TempProp.isFrozen && cache.TempProp.rowFrozen) {
    				tempRule = {
    					displayPosition: {
    						offsetTop: 0, // must
    						startAlias: cache.UserView.rowAlias,
    						endAlias: cache.TempProp.rowAlias,
    						startIndex: userViewIndex,
    						endIndex: currentIndex
    					},
    					boxAttributes: {
    						height: currentModelTop - userViewModel.toJSON().top - 1,
    						style: 'frozen-bottom-border'
    					},
    					autoScroll: false,
    					reduceUserView: true
    				};
    				cache.FrozenRules.row.push(tempRule);
    			} else {
    				currentModelTop = 0;
    			}
    			tempRule = {
    				displayPosition: {
    					offsetTop: currentModelTop,
    					startIndex: currentIndex,
    					startAlias: cache.TempProp.rowAlias
    				},
    				boxAttributes: {
    					height: this.scrollHeight - this.scrollbarWidth - currentModelTop
    				},
    				autoScroll: true,
    				isSubscribe: [{
    					publisherName: 'mainContainer',
    					behavior: 'scrollToPosition', //it's self behavior
    					action: 'verticalPublish' //publisher behavior
    				}]
    			};
    			if (cache.TempProp.isFrozen && cache.TempProp.rowFrozen) {
    				tempRule.displayPosition.offsetTop -= userViewModel.get('top');
    				tempRule.boxAttributes.height += userViewModel.toJSON().top;
    				tempRule.reduceUserView = true;
    			}
    			cache.FrozenRules.row.push(tempRule);
    		},
    		
    		ruleMain: function() {
    			var tempRule,
    				modelRowList = headItemRows,
    				modelColList = headItemCols,
    				currentRowModel,
    				currentColModel,
    				currentRowIndex,
    				currentColIndex,
    				currentRowModelTop,
    				currentColModelLeft,
    				userViewRowModel,
    				userViewColModel,
    				userViewRowIndex,
    				userViewColIndex;
    
    
    			currentRowIndex = modelRowList.getIndexByAlias(cache.TempProp.rowAlias);
    			currentColIndex = modelColList.getIndexByAlias(cache.TempProp.colAlias);
    
    			if (currentRowIndex === -1) {
    				currentRowModelTop = 0;
    			} else {
    				currentRowModel = modelRowList.models[currentRowIndex];
    				currentRowModelTop = currentRowModel.get('top');
    			}
    
    			if (currentColIndex === -1) {
    				currentColModelLeft = 0;
    			} else {
    				currentColModel = modelColList.models[currentColIndex];
    				currentColModelLeft = currentColModel.get('left');
    			}
    
    			//可视点
    			userViewRowModel = modelRowList.getModelByAlias(cache.UserView.rowAlias);
    			userViewRowIndex = modelRowList.getIndexByAlias(cache.UserView.rowAlias);
    			userViewColModel = modelColList.getModelByAlias(cache.UserView.colAlias);
    			userViewColIndex = modelColList.getIndexByAlias(cache.UserView.colAlias);
    
    
    			if (cache.TempProp.isFrozen) {
    				if (cache.TempProp.rowFrozen && cache.TempProp.colFrozen) {
    					tempRule = {
    						boxAttributes: {
    							height: currentRowModelTop - userViewRowModel.toJSON().top - 1,
    							width: currentColModelLeft - userViewColModel.toJSON().left - 1,
    							style: 'container frozen-right-border frozen-bottom-border'
    						},
    						displayPosition: {
    							startColIndex: userViewColIndex,
    							endColIndex: currentColIndex,
    							startRowIndex: userViewRowIndex,
    							endRowIndex: currentRowIndex,
    							startColAlias: cache.UserView.colAlias,
    							startRowAlias: cache.UserView.rowAlias,
    							endColAlias: cache.TempProp.colAlias,
    							endRowAlias: cache.TempProp.rowAlias,
    							offsetTop: 0,
    							offsetLeft: 0
    						}
    					};
    					cache.FrozenRules.main.push(tempRule);
    				}
    				if (cache.TempProp.rowFrozen) {
    					tempRule = {
    						boxAttributes: {
    							height: currentRowModelTop - userViewRowModel.toJSON().top - 1,
    							width: this.scrollWidth - this.scrollbarWidth - currentColModelLeft,
    							style: 'container frozen-bottom-border'
    						},
    						displayPosition: {
    							startRowIndex: userViewRowIndex,
    							endRowIndex: currentRowIndex,
    							startColIndex: currentColIndex,
    
    							startColAlias: cache.TempProp.colAlias,
    							startRowAlias: cache.UserView.rowAlias,
    							endRowAlias: cache.TempProp.rowAlias,
    							offsetLeft: currentColModelLeft,
    							offsetTop: 0
    						},
    						autoScroll: true,
    						autoColAlign: true,
    						isSubscribe: [{
    							publisherName: 'mainContainer',
    							behavior: 'subscribeScroll', //it's self behavior
    							action: 'transversePublish', //publisher behavior,
    							args: {
    								'direction': 'TRANSVERSE'
    							}
    						}]
    					};
    					if (cache.TempProp.colFrozen) {
    						tempRule.boxAttributes.width += userViewColModel.toJSON().left;
    						tempRule.displayPosition.offsetLeft -= userViewColModel.get('left');
    					}
    					cache.FrozenRules.main.push(tempRule);
    				}
    				if (cache.TempProp.colFrozen) {
    					tempRule = {
    						boxAttributes: {
    							height: this.scrollHeight - this.scrollbarWidth - currentRowModelTop,
    							width: currentColModelLeft - userViewColModel.toJSON().left - 1,
    							style: 'container frozen-right-border'
    						},
    						displayPosition: {
    							startColIndex: userViewColIndex,
    							endColIndex: currentColIndex,
    							startRowIndex: currentRowIndex,
    							startColAlias: cache.UserView.colAlias,
    							startRowAlias: cache.TempProp.rowAlias,
    							endColAlias: cache.TempProp.colAlias,
    							offsetLeft: 0,
    							offsetTop: currentRowModelTop
    						},
    						autoScroll: true,
    						autoRowAlign: true,
    						isSubscribe: [{
    							publisherName: 'mainContainer',
    							behavior: 'subscribeScroll', //it's self behavior
    							action: 'verticalPublish', //publisher behavior,
    							args: {
    								'direction': 'VERTICAL'
    							},
    						}]
    					};
    					if (cache.TempProp.rowFrozen) {
    						tempRule.boxAttributes.height += userViewRowModel.toJSON().top;
    						tempRule.displayPosition.offsetTop -= userViewRowModel.get('top');
    					}
    					cache.FrozenRules.main.push(tempRule);
    				}
    
    			} else {
    				currentRowModelTop = 0;
    				currentColModelLeft = 0;
    			}
    			tempRule = {
    				boxAttributes: {
    					height: this.scrollHeight - currentRowModelTop,
    					width: this.scrollWidth - currentColModelLeft,
    					style: 'scroll-container'
    				},
    				displayPosition: {
    					startColIndex: currentColIndex,
    					startRowIndex: currentRowIndex,
    					startColAlias: cache.TempProp.colAlias,
    					startRowAlias: cache.TempProp.rowAlias,
    					offsetLeft: currentColModelLeft,
    					offsetTop: currentRowModelTop,
    				},
    				autoRowAlign: true,
    				autoColAlign: true,
    				autoScroll: true,
    				eventScroll: true,
    				isPublisher: true,
    				publisherName: 'mainContainer'
    			};
    			if (cache.TempProp.rowFrozen) {
    				tempRule.boxAttributes.height += userViewRowModel.toJSON().top;
    				tempRule.displayPosition.offsetTop -= userViewRowModel.get('top');
    			}
    			if (cache.TempProp.colFrozen) {
    				tempRule.boxAttributes.width += userViewColModel.toJSON().left;
    				tempRule.displayPosition.offsetLeft -= userViewColModel.get('left');
    			}
    
    			cache.FrozenRules.main.push(tempRule);
    		},
    		
    		// initMainView: function() {
    		// 	var startRowHeadModel,
    		// 		startColHeadModel;
    		// 	if (cache.TempProp.isFrozen === true) {
    		// 		return;
    		// 	}
    		// 	startRowHeadModel = headItemRows.getModelByAlias(cache.UserView.rowAlias);
    		// 	startColHeadModel = headItemCols.getModelByAlias(cache.UserView.colAlias);
    		// 	Backbone.trigger('event:mainContainer:appointPosition', startRowHeadModel.get('top'), 'VERTICAL');
    		// 	Backbone.trigger('event:mainContainer:appointPosition', startColHeadModel.get('left'), 'TRANSVERSE');
    		// },
    		
    		calculation: function() {
    
    			
    			this.scrollWidth = this.el.offsetWidth - config.System.outerLeft;
    			
    			this.scrollHeight = this.el.offsetHeight - config.System.outerTop - config.System.outerBottom;
    			
    			this.scrollbarWidth = this.getScrollbarWidth();
    
    			cache.scrollbarWidth = this.scrollbarWidth;
    		},
    		
    		addressing: function(currrentEl, target) {
    			if (currrentEl.length && currrentEl === target) {
    				return true;
    			}
    			if (currrentEl.parents(target).length && currrentEl.parents(target) === target) {
    				return true;
    			}
    			return false;
    		},
    		reload: function() {
    			var cellList = cells.models,
    				headRowList = headItemRows.models,
    				headColList = headItemCols.models,
    				selectList = selectRegions.models,
    				siderLineColList = siderLineCols.models,
    				siderLineRowList = siderLineRows.models,
    				i, len;
    
    			cache.CellsPosition.strandX = {};
    			cache.CellsPosition.strandY = {};
    			cache.rowRegionPosi = [];
    			cache.sendQueueStep = 1;
    
    			for (i = 0, len = cellList.length; i < len; i++) {
    				cellList[0].destroy();
    			}
    			for (i = 0, len = headRowList.length; i < len; i++) {
    				headRowList[0].destroy();
    			}
    			for (i = 0, len = headColList.length; i < len; i++) {
    				headColList[0].destroy();
    			}
    			for (i = 0, len = selectList.length; i < len; i++) {
    				selectList[0].destroy();
    			}
    			for (i = 0, len = siderLineColList.length; i < len; i++) {
    				siderLineColList[0].destroy();
    			}
    			for (i = 0, len = siderLineRowList.length; i < len; i++) {
    				siderLineRowList[0].destroy();
    			}
    
    			Backbone.trigger('event:colsPanelContainer:destroy');
    			Backbone.trigger('event:rowsPanelContainer:destroy');
    			Backbone.trigger('event:mainContainer:destroy');
    
    			window.SPREADSHEET_BUILD_STATE = 'false';
    			cache.TempProp = {
    				isFrozen: false,
    				rowFrozen: false,
    				colFrozen: false
    			};
    			original.restoreExcel(this.el.id);
    			this.executiveFrozen();
    		},
    		
    		mouseInfo: function(e) {
    
    			//获取相对位置
    			this.mousePageX = e.pageX - this.$el.offset().left;
    			this.mousePageY = e.pageY - this.$el.offset().top;
    		},
    		
    		getScrollbarWidth: function() {
    			var virtualEl,
    				scrollNone,
    				scrollExist;
    			virtualEl = $('<div/>').css({
    				'width': 50,
    				'height': 50,
    				'overflow': 'hidden',
    				'position': 'absolute',
    				'top': -200,
    				'left': -200
    			}).html('<div style="height:1000px;">');
    			this.$el.append(virtualEl);
    			scrollNone = getWidth();
    			virtualEl.css('overflow-y', 'auto');
    			scrollExist = getWidth();
    			$(virtualEl).remove();
    
    			function getWidth() {
    				return parseInt($('div', virtualEl).innerWidth(), 0);
    			}
    			return (scrollNone - scrollExist);
    		},
    		destroy: function() {
    			Backbone.off('event:bodyContainer:executiveFrozen');
    			Backbone.off('event:commentContainer:show');
    			Backbone.off('event:commentContainer:remove');
    			Backbone.off('event:SidebarContainer:show');
    			Backbone.off('event:SidebarContainer:remove');
    			Backbone.trigger('event:colsPanelContainer:destroy');
    			Backbone.trigger('event:rowsPanelContainer:destroy');
    			Backbone.trigger('event:mainContainer:destroy');
    			this.sheetsView.destroy();
    			this.remove();
    		}
    	});
    	return BodyContainer;
    });
    define('views/screen',function() {
    	
    	var $ = require('lib/jquery'),
    		_ = require('lib/underscore'),
    		Backbone = require('lib/backbone'),
    		BodyContainer = require('views/bodyContainer'),
    		send = require('basic/tools/send'),
    		cache = require('basic/tools/cache'),
    		config = require('spreadsheet/config'),
    		listener = require('basic/util/listener'),
    		clipSelectOperate = require('entrance/tool/clipselectoperate'),
    		clipPasteOperate = require('entrance/tool/clippasteoperate'),
    		Screen;
    
    
    	
    	Screen = Backbone.View.extend({
    		
    		el: window,
    		
    		events: {
    			'resize': 'attributesRender',
    			'mouseup': 'realseDrag',
    			'beforeunload': 'closeWindow',
    			'mousedown': 'transAction'
    		},
    
    		
    		initialize: function(containerId) {
    			Backbone.on('call:screenContainer', this.screenContainer, this);
    			Backbone.on('event:screenContainer:destroy', this.destroy, this);
    			Backbone.on('event:screenContainer:mouseMoveHeadContainer', this.mouseMoveHeadContainer, this);
    			Backbone.on('call:screenContainer:adaptScreen', this.attributesRender, this);
    			_.bindAll(this, 'callView');
    			this.render(containerId);
    		},
    		
    		render: function(containerId) {
    			this.bodyContainer = new BodyContainer({
    				el: '#' + containerId
    			});
    			this.bodyContainer.render();
    			this.triggerCallback();
    		},
    		transAction: function(e) {
    		},
    		
    		triggerCallback: function() {
    			Backbone.trigger('call:rowsPanelContainer', this.callView('viewRowsPanelContainer'));
    			Backbone.trigger('call:colsPanelContainer', this.callView('viewColsPanelContainer'));
    			Backbone.trigger('call:mainContainer', this.callView('viewMainContainer'));
    
    			Backbone.trigger('call:cellsContainer', this.callView('viewCellsContainer'));
    			Backbone.trigger('call:colsHeadContainer', this.callView('viewColsHeadContainer'));
    			Backbone.trigger('call:rowsHeadContainer', this.callView('viewRowsHeadContainer'));
    		},
    		
    		closeWindow: function() {
    			// var data = {};
    
    			// data.excelId = window.SPREADSHEET_AUTHENTIC_KEY;
    			// data.sheetId = '1';
    			// if (cache.TempProp.isFrozen === true) {	
    			// 	data.startX= cache.UserView.colAlias;
    			// 	data.startY= cache.UserView.rowAlias;
    			// } else {
    			// 	data.startX= '1';
    			// 	data.startY= '1';
    			// }
    
    			// send.PackAjax({
    			// 	url: 'excel.htm?m=close',
    			// 	data: JSON.stringify(data)
    			// });
    		},
    		
    		screenContainer: function(receiveFunc) {
    			receiveFunc(this);
    		},
    		
    		attributesRender: function() {
    			this.bodyContainer.calculation();
    			Backbone.trigger('event:bodyContainer:executiveFrozen');
    		},
    		
    		callView: function(name) {
    			var object = this;
    			return function(callBack) {
    				object[name] = callBack;
    			};
    		},
    		
    		realseDrag: function(e) {
    			this.triggerCallback();
    			Backbone.trigger('event:cellsContainer:setMouseState', 'moveState', 'commonMoveState');
    			Backbone.trigger('event:colsHeadContainer:setMouseState', 'moveState', 'commonMoveState');
    			Backbone.trigger('event:rowsHeadContainer:setMouseState', 'moveState', 'commonMoveState');
    			//release events of cols
    			Backbone.trigger('event:colsHeadContainer:relaseSpaceEffect');
    			//release events of rows
    			Backbone.trigger('event:rowsHeadContainer:relaseSpaceEffect');
    
    			Backbone.trigger('event:colsSpaceLineContainer:destroy');
    			this.$el.off('mousemove');
    
    			Backbone.trigger('event:rowsSpaceLineContainer:destroy');
    		},
    		
    		mouseMoveHeadContainer: function(args, moveEvent) {
    			this.$el.on('mousemove', args, moveEvent);
    		},
    		destroy: function() {
    			Backbone.off('call:screenContainer');
    			Backbone.off('call:screenContainer:adaptScreen');
    			this.bodyContainer.destroy();
    			this.remove();
    		}
    	});
    	return Screen;
    });
    	define('widgets/clipboard/shearPlateContainer',function() {
    		
    		var $ = require('lib/jquery'),
    			_ = require('lib/underscore'),
    			cache = require('basic/tools/cache'),
    			Backbone = require('lib/backbone'),
    			clipSelectOperate = require('entrance/tool/clipselectoperate'),
    			clipPasteOperate = require('entrance/tool/clippasteoperate'),
    			ShearPlateContainer;
    
    		
    		ShearPlateContainer = Backbone.View.extend({
    			
    			el: "#shearPlateContainer",
    			
    			initialize: function() {
    				_.bindAll(this, 'pasteData');
    				Backbone.on('event:pasteData', this.pasteData);
    			},
    			events: {
    				'mousedown div': 'pasteAction'
    			},
    			pasteAction: function(e) {
    				var action;
    				action = $(e.currentTarget).data('toolbar');
    				switch (action) {
    					case 'paste':
    						this.pasteData();
    						break;
    					case 'copy':
    						this.copyData();
    						break;
    					case 'cut':
    						this.cutData();
    						break;
    					default:
    						break;
    				}
    			},
    			copyData: function() {
    				clipSelectOperate("copy");
    			},
    			cutData: function() {
    				clipSelectOperate("cut");
    			},
    			
    			pasteData: function(pasteText) {
    				if (cache.clipState === "null") return;
    				clipPasteOperate(pasteText);
    			},
    		});
    		return ShearPlateContainer;
    	});
    define('widgets/font/fontFamilyContainer',function() {
    	
    	var $ = require('lib/jquery'),
    		_ = require('lib/underscore'),
    		Backbone = require('lib/backbone'),
    		send = require('basic/tools/send'),
    		cells = require('collections/cells'),
    		selectRegions = require('collections/selectRegion'),
    		setFontFamily = require('entrance/tool/setfontfamily');
    
    	
    	var FontFamilyContainer = Backbone.View.extend({
    		
    		el: "#font",
    		
    		events: {
    			
    			'mousedown li': 'setFontFamily'
    		},
    		
    		setFontFamily: function(e) {
    			var displayText,
    				fontFamily,
    				$currentTarget;
    			this.$el.removeClass('active');
    			$currentTarget = $(e.currentTarget);
    			fontFamily = $currentTarget.data('family');
    			displayText = $currentTarget.text();
    			$("#fontShow").text(displayText);
    			setFontFamily('1', fontFamily);
    		}
    	});
    	return FontFamilyContainer;
    });
    define('widgets/font/fontSizeContainer',function() {
    	
    	var $ = require('lib/jquery'),
    		_ = require('lib/underscore'),
    		Backbone = require('lib/backbone'),
    		send = require('basic/tools/send'),
    		selectRegions = require('collections/selectRegion'),
    		setFontSize = require('entrance/tool/setfontsize'),
    		setCellHeight = require('entrance/cell/setcellheight');
    
    
    	
    	var FontSizeContainer = Backbone.View.extend({
    		
    		el: "#fontSize",
    		
    		events: {
    			
    			'mousedown li': 'setFontSize'
    		},
    		
    		setFontSize: function(e) {
    			var fontSize,
    				text,
    				$currentTarget;
    			$currentTarget = $(e.currentTarget);
    			this.$el.removeClass('active');
    			fontSize = $currentTarget.data('size');
    			text = $currentTarget.text();
    			$("#fontSizeShow").text(text);
    			setFontSize('1', fontSize);
    		}
    	});
    	return FontSizeContainer;
    
    });
    define('widgets/celloperation/borderContainer',function() {
    	
    	var $ = require('lib/jquery'),
    		_ = require('lib/underscore'),
    		Backbone = require('lib/backbone'),
    		send = require('basic/tools/send'),
    		cells = require('collections/cells'),
    		selectRegions = require('collections/selectRegion'),
    		setCellBorder=require('entrance/tool/setcellborder');
    
    	
    	var BorderContainer = Backbone.View.extend({
    		
    		el: '#funcBorder',
    		
    		events: {
    			
    			'mousedown li': 'transAction'
    		},
    		initialize: function() {
    		},
    		render: function() {},
    		
    		transAction: function(e) {
    			var borderPositon = $(e.currentTarget).data('border');
    			setCellBorder('1',borderPositon);
    		}
    	});
    	return BorderContainer;
    });
    define('widgets/celloperation/fillColorContainer',function() {
    	
    	var $ = require('lib/jquery'),
    		_ = require('lib/underscore'),
    		Backbone = require('lib/backbone'),
    		setFillColor = require('entrance/tool/setfillcolor'),
    		FillColorContainer;
    
    	
    	FillColorContainer = Backbone.View.extend({
    		
    		el: "#fillColor",
    		
    		events: {
    			'mousedown .color-body': 'setFillColor'
    		},
    		
    		setFillColor: function(e) {
    			this.$el.removeClass('active');
    			var color = $(e.currentTarget).css('background-color');
    			setFillColor('1', color);
    		}
    
    	});
    	return FillColorContainer;
    
    });
    define('widgets/font/fontColorContainer',function() {
    	
    	var $=require('lib/jquery'),
    		Backbone = require('lib/backbone'),
    		send = require('basic/tools/send'),
    		selectRegions = require('collections/selectRegion'),
    		setFontColor=require('entrance/tool/setfontcolor');
    
    	
    	var FontColorContainer = Backbone.View.extend({
    		
    		el: "#fontColor",
    		
    		events: {
    			
    			'mousedown .color-body': 'setFontColor'
    		},
    		
    		setFontColor: function(e) {
    			this.$el.removeClass('active');
    			var color = $(e.currentTarget).css('background-color');
    			setFontColor('1',color);
    		}
    
    	});
    	return FontColorContainer;
    });
    //attention bug, new model has large question
    
    define('widgets/align/contentAlignContainer',function() {
    	
    	var $ = require('lib/jquery'),
    		Backbone = require('lib/backbone'),
    		setAlign = require('entrance/tool/setalign');
    
    	
    	var ContentAlignContainer = Backbone.View.extend({
    		
    		el: '#contentAlignContainer',
    		
    		events: {
    			
    			'click span[data-align]': 'setAlignAction'
    		},
    		
    		setAlignAction: function(e) {
    			var alignType;
    			alignType = $(e.currentTarget).data('align');
    			setAlign('1', alignType);
    		}
    	});
    	return ContentAlignContainer;
    });
    
    define('widgets/cellformat/textFormatContainer',function() {
    	var $ = require('lib/jquery'),
    		Backbone = require('lib/backbone'),
    		config = require('spreadsheet/config'),
    		setTextType = require('entrance/tool/settexttype');
    	
    	var TextFormatContainer = Backbone.View.extend({
    		
    		el: '#contentFormat',
    		
    		events: {
    			'mousedown li': 'setContentFormat'
    		},
    		
    		setContentFormat: function(e) {
    			this.$el.removeClass('active');
    			var formatPosition = $(e.currentTarget).data('format');
    			// setTextType('1',formatPosition);
    			switch (formatPosition) {
    				case 'normal':
    					setTextType.setNormal('1');
    					break;
    				case 'text':
    					setTextType.setText('1');
    					break;
    				case 'number-0':
    					setTextType.setNum('1', false, 0);
    					break;
    				case 'number-1':
    					setTextType.setNum('1', false, 1);
    					break;
    				case 'number-2':
    					setTextType.setNum('1', false, 2);
    					break;
    				case 'number-3':
    					setTextType.setNum('1', false, 3);
    					break;
    				case 'number-4':
    					setTextType.setNum('1', false, 4);
    					break;
    				case 'date-1':
    					setTextType.setDate('1', config.dateFormatType.frist);
    					break;
    				case 'date-2':
    					setTextType.setDate('1', config.dateFormatType.fourth);
    					break;
    				case 'date-3':
    					setTextType.setDate('1', config.dateFormatType.fifth);
    					break;
    				case 'percent':
    					setTextType.setPercent('1', 2);
    					break;
    				case 'coin-1':
    					setTextType.setCurrency('1', 2, '$');
    					break;
    				case 'coin-2':
    					setTextType.setCurrency('1', 2, '¥');
    					break;
    				default:
    					setTextType.setText('1');
    					break;
    			}
    		}
    	});
    	return TextFormatContainer;
    });
    define('widgets/celloperation/mergeCellContainer',function() {
    	
    	var $ = require('lib/jquery'),
    		_ = require('lib/underscore'),
    		Backbone = require('lib/backbone'),
    		send = require('basic/tools/send'),
    		cache = require('basic/tools/cache'),
    		binary = require('basic/util/binary'),
    		selectRegions = require('collections/selectRegion'),
    		headItemCols = require('collections/headItemCol'),
    		headItemRows = require('collections/headItemRow'),
    		cells = require('collections/cells'),
    		mergeCell = require('entrance/tool/mergecell'),
    		splitCell = require('entrance/tool/splitcell');
    
    	
    	var MergeCellContainer = Backbone.View.extend({
    		
    		el: '#mergeCellContainer',
    		
    		events: {
    			'click div[data-toolbar]': 'transAction'
    				// 'click #merge': 'mergeCell',
    				// 'click #split': 'splitCell'
    		},
    		
    		initialize: function() {
    			_.bindAll(this, 'splitCell');
    		},
    		
    		transAction: function(e) {
    			var borderPositon = $(e.currentTarget).data('toolbar');
    			switch (borderPositon) {
    				case 'merge':
    					this.mergeCell(e);
    					break;
    				case 'split':
    					this.splitCell(e);
    					break;
    			}
    		},
    		
    		mergeCell: function() {
    			mergeCell('1');
    		},
    		
    		splitCell: function() {
    			splitCell('1');
    		},
    		
    		splitCreateCell: function(cacheCell) {
    
    		},
    		
    		deletePosi: function(aliasCol, aliasRow) {
    			var currentCellPosition = cache.CellsPosition,
    				currentStrandX = currentCellPosition.strandX,
    				currentStrandY = currentCellPosition.strandY;
    			if (currentStrandX[aliasCol] !== undefined && currentStrandX[aliasCol][aliasRow] !== undefined) {
    				delete currentStrandX[aliasCol][aliasRow];
    				if (!Object.getOwnPropertyNames(currentStrandX[aliasCol]).length) {
    					delete currentStrandX[aliasCol];
    				}
    			}
    			if (currentStrandY[aliasRow] !== undefined && currentStrandY[aliasRow][aliasCol] !== undefined) {
    				delete currentStrandY[aliasRow][aliasCol];
    				if (!Object.getOwnPropertyNames(currentStrandY[aliasRow]).length) {
    					delete currentStrandY[aliasRow];
    				}
    			}
    		},
    		
    		setPosi: function(indexX, indexY, index) {
    			var temp = {};
    			if (cache.CellsPosition.strandX[indexX] === undefined) {
    				temp = {};
    				temp[indexY] = index;
    				cache.CellsPosition.strandX[indexX] = temp;
    			} else {
    				//更新对象
    				cache.CellsPosition.strandX[indexX][indexY] = index;
    			}
    			if (cache.CellsPosition.strandY[indexY] === undefined) {
    				temp = {};
    				temp[indexX] = index;
    				cache.CellsPosition.strandY[indexY] = temp;
    			} else {
    				//更新对象
    				cache.CellsPosition.strandY[indexY][indexX] = index;
    			}
    		}
    	});
    	return MergeCellContainer;
    });
    define('entrance/tool/setunderline',function() {
    	
    	var Backbone = require('lib/backbone'),
    		send = require('basic/tools/send'),
    		config = require('spreadsheet/config'),
    		history = require('basic/tools/history'),
    		gridCols = require('collections/headItemCol'),
    		gridRows = require('collections/headItemRow'),
    		selects = require('collections/selectRegion'),
    		cells = require('collections/cells'),
    		cache = require('basic/tools/cache'),
    		parse = require('basic/tools/getoperregion'),
    		rowOper = require('entrance/row/rowoperation'),
    		colOper = require('entrance/col/coloperation'),
    		gridColList = gridCols.models,
    		gridRowList = gridRows.models;
    
    	var result = {
    		set: function(sheetId, underline, region) {
    			var operRegion,
    				selectCell,
    				oldModelList = [];
    
    			if (typeof sheetId === 'boolean') {
    				region = underline;
    				underline = sheetId;
    			}
    			if (cache.protectState) {
    				Backbone.trigger('event:showMsgBar:show', '保护状态，不能进行该操作');
    				return;
    			}
    			if (typeof underline !== 'boolean') {
    				region = underline;
    			}
    
    			this._destroyClipRegion();
    
    			region = parse(region);
    			operRegion = region.operRegion;
    
    			if (typeof underline === 'undefined') {
    				//暂时使用左上角单元格的值，实现初始选中点时，使用初始选中点
    				selectCell = cells.getCellByVertical(operRegion.startColIndex, operRegion.startRowIndex)[0];
    				if (selectCell && selectCell.get('content').underline) {
    					underline = 0;
    				} else {
    					underline = 1;
    				}
    			}
    
    			if (operRegion.endRowIndex === 'MAX') {
    				colOper.colPropOper(operRegion.startColIndex, operRegion.endColIndex, 'content.underline', underline);
    			} else if (operRegion.endColIndex === 'MAX') {
    				rowOper.rowPropOper(operRegion.startRowIndex, operRegion.endRowIndex,  'content.underline', underline);
    			} else {
    				cells.oprCellsByRegion(operRegion, function(cell, colSort, rowSort) {
    					var temp;
    					if ((temp = cell.get('content').underline) !== underline) {
    						oldModelList.push({
    							colSort: colSort,
    							rowSort: rowSort,
    							value: temp
    						});
    						cell.set('content.underline', underline);
    					}
    				});
    				this._history('content.underline', underline, operRegion, oldModelList);
    			}
    			this._send(region.sendRegion, underline);
    		},
    		_history: function(prop, value, region, oldList) {
    			history.addAction(history.getCellPropUpdateAction(prop, value, {
    				startColSort: gridColList[region.startColIndex].get('sort'),
    				startRowSort: gridRowList[region.startRowIndex].get('sort'),
    				endColSort: gridColList[region.endColIndex].get('sort'),
    				endRowSort: gridRowList[region.endRowIndex].get('sort')
    			}, oldList));
    		},
    		_destroyClipRegion: function() {
    			var clip = selects.getModelByType('clip');
    			if (clip) {
    				cache.clipState = 'null';
    				clip.destroy();
    			}
    		},
    		_send: function(region, underline) {
    			send.PackAjax({
    				url: config.url.cell.underline,
    				data: JSON.stringify({
    					coordinate: region,
    					underline: underline
    				})
    			});
    		}
    	};
    	return result;
    });
    define('widgets/font/contentFontContainer',function() {
    	
    	var $ = require('lib/jquery'),
    		_ = require('lib/underscore'),
    		Backbone = require('lib/backbone'),
    		send = require('basic/tools/send'),
    		cells = require('collections/cells'),
    		selectRegions = require('collections/selectRegion'),
    		setFontWeight = require('entrance/tool/setfontweight'),
    		setFontStyle = require('entrance/tool/setfontstyle'),
    		underline = require('entrance/tool/setunderline');
    
    	
    	var ContentFontContainer = Backbone.View.extend({
    		
    		el: '#contentFontContainer',
    		
    		events: {
    			
    			'click span': 'setFontAction'
    		},
    		
    		setFontAction: function(e) {
    			var tool = $(e.currentTarget).data('toolbar');
    
    			switch (tool) {
    				case 'bold':
    					this.setCellModelBold();
    					break;
    				case 'italic':
    					this.setCellModelItalic();
    					break;
    				case 'underline':
    					this.setUnderline();
    					break;
    				default:
    					return;
    			}
    		},
    		
    		setCellModelBold: function() {
    			setFontWeight('1');
    		},
    		
    		setCellModelItalic: function() {
    			setFontStyle('1');
    		},
    		setUnderline: function() {
    			underline.set();
    		}
    	});
    	return ContentFontContainer;
    });
    define('widgets/frozen/frozenContainer',function() {
    	
    	var $ = require('lib/jquery'),
    		_ = require('lib/underscore'),
    		Backbone = require('lib/backbone'),
    		send = require('basic/tools/send'),
    		cache = require('basic/tools/cache'),
    		selectRegions = require('collections/selectRegion'),
    		headItemRows = require('collections/headItemRow'),
    		headItemCols = require('collections/headItemCol'),
    		setFrozen = require('entrance/sheet/setfrozen');
    
    	
    	var frozenContainer = Backbone.View.extend({
    		
    		el: "#frozen",
    		
    		events: {
    			'mousedown li': 'transAction'
    		},
    		
    		initialize: function() {
    			Backbone.on('event:frozenContainer:changeState', this.changeState, this);
    			this.unfrozenBtn = $('li[data-frozen="unfrozen"]', this.$el);
    			this.customBtn = $('li[data-frozen="custom"]', this.$el);
    			this.changeState();
    		},
    		
    		render: function() {},
    		
    		changeState: function() {
    			if (cache.TempProp.isFrozen) {
    				this.unfrozenBtn.show();
    				this.customBtn.hide();
    			} else {
    				this.unfrozenBtn.hide();
    				this.customBtn.show();
    			}
    		},
    		
    		transAction: function(e) {
    			var type = $(e.currentTarget).data('frozen');
    			setFrozen('1',null ,type);
    			this.changeState();
    		}
    	});
    	return frozenContainer;
    });
    
    define('widgets/insert/insertoperation',function() {
    	var $ = require('lib/jquery'),
    		Backbone = require('lib/backbone'),
    		rowOperation = require('entrance/tool/addrow'),
    		colOperation = require('entrance/tool/addcol'),
    		InsertOperation;
    		
    	InsertOperation = Backbone.View.extend({
    		el: '#insert',
    		events: {
    			'mousedown li': 'action'
    		},
    		action: function(e) {
    			var operate = $(e.currentTarget).data('type');
    			if(operate === 'column'){
    				this.insertColumn();
    			}else{
    				this.insertRow();
    			}
    		},
    		insertRow: function() {
    			rowOperation.add();
    		},
    		insertColumn: function(){
    			colOperation.add();
    		}
    	});
    	return InsertOperation;
    });
    
    define('widgets/delete/deleteoperation',function() {
    	var $ = require('lib/jquery'),
    		Backbone = require('lib/backbone'),
    		rowOperation = require('entrance/tool/deleterow'),
    		colOperation = require('entrance/tool/deletecol'),
    		deleteOperation;
    		
    	deleteOperation = Backbone.View.extend({
    		el: '#delete',
    		events: {
    			'mousedown li': 'action'
    		},
    		action: function(e) {
    			var operate = $(e.currentTarget).data('type');
    			if(operate === 'column'){
    				this.deleteColumn();
    			}else{
    				this.deleteRow();
    			}
    		},
    		deleteRow: function() {
    			rowOperation.deleteRow();
    		},
    		deleteColumn: function(){
    			colOperation.deleteCol();
    		}
    	});
    	return deleteOperation;
    });
    define('widgets/celloperation/commentcontainer',function() {
    	
    	var $ = require('lib/jquery'),
    		_ = require('lib/underscore'),
    		Backbone = require('lib/backbone'),
    		commentOpr = require('entrance/tool/comment'),
    		commentContainer;
    
    	
    	commentContainer = Backbone.View.extend({
    		
    		el: "#reviewContainer",
    		
    		events: {
    			'click .fui-section': 'commentAction'
    		},
    		commentAction: function(e) {
    			var action;
    			action = $(e.currentTarget).data('toolbar');
    			switch (action) {
    				case 'addComment':
    					commentOpr.createAddCommentView();
    					break;
    				case 'editComment':
    					commentOpr.createEditComment();
    					break;
    				case 'deleteComment':
    					commentOpr.deleteComment();
    					break;
    				default:
    					break;
    			}
    		},
    	});
    	return commentContainer;
    });
    //attention bug, new model has large question
    
    define('widgets/celloperation/wordwrapcontainer',function() {
    	
    	var $ = require('lib/jquery'),
    		_ = require('lib/underscore'),
    		Backbone = require('lib/backbone'),
    		send = require('basic/tools/send'),
    		selectRegions = require('collections/selectRegion'),
    		setWordWrap = require('entrance/tool/setwordwrap');
    
    	
    	var WordWrapContainer = Backbone.View.extend({
    		
    		el: "#wordWrapContainer",
    		
    		events: {
    			
    			'click': 'wordWrap'
    		},
    		
    		wordWrap: function(e) {
    			var alignType,
    				transverse,
    				data,
    				url,
    				vertical;
    			setWordWrap('1');
    		}
    	});
    	return WordWrapContainer;
    });
    
    define('widgets/hidecol/colhidecontainer',function() {
    	var $ = require('lib/jquery'),
    		Backbone = require('lib/backbone'),
    		colHide = require('entrance/col/colhide'),
    		HideOperation;
    
    	HideOperation = Backbone.View.extend({
    		el: '#hideContainer',
    		events: {
    			'click .fui-section': 'action'
    		},
    		action: function(e) {
    			var operate = $(e.currentTarget).data('toolbar');
    			if (operate === 'hide') {
    				colHide.hide();
    			} else {
    				colHide.cancelHide();
    			}
    		}
    	});
    	return HideOperation;
    });
    
    define('widgets/celldel/regiondel',function() {
    	var $ = require('lib/jquery'),
    		Backbone = require('lib/backbone'),
    		regionDelOpr = require('entrance/tool/regiondel'),
    		regionDel;
    		
    	regionDel = Backbone.View.extend({
    		el: '#regionDelContainer',
    		events: {
    			'click': 'action'
    		},
    		action: function(e) {
    			regionDelOpr();
    		}
    	});
    	return regionDel;
    });
    	define('widgets/undoredo/undoredocontainer',function() {
    		
    		var $ = require('lib/jquery'),
    			cache = require('basic/tools/cache'),
    			Backbone = require('lib/backbone'),
    			done = require('entrance/sheet/redoundo');
    
    		
    		var undoredoContainer = Backbone.View.extend({
    			
    			el: "#undoredoContainer",
    			events: {
    				'click span[data-toolbar]': 'undoRedo'
    			},
    			undoRedo: function(e) {
    				var action;
    				action = $(e.currentTarget).data('toolbar');
    				switch (action) {
    					case 'redo':
    						done.redo();
    						break;
    					case 'undo':
    						done.undo();
    						break;
    					default:
    						break;
    				}
    			}
    		});
    		return undoredoContainer;
    	});
    
    define('widgets/protect/protectcontainer',function() {
    	var $ = require('lib/jquery'),
    		Backbone = require('lib/backbone'),
    		protect = require('entrance/tool/protect'),
    		ProtectContainer;
    
    	ProtectContainer = Backbone.View.extend({
    		el: '#protectContainer',
    		events: {
    			'click .fui-section': 'action'
    		},
    		action: function(e) {
    			var operate = $(e.currentTarget).data('toolbar');
    			if (operate === 'lock') {
    				protect.showLockContainer();
    			} else if(operate === 'protect'){
    				protect.showProtectContainer();
    			}
    		}
    	});
    	return ProtectContainer;
    });
    define('widgets/validate/validatecontainer',function() {
    	
    	var Backbone = require('lib/backbone'),
    		validate = require('entrance/tool/validate'),
    		ValidateContainer;
    
    	ValidateContainer = Backbone.View.extend({
    		el: '#validateContainer',
    		events: {
    			'click .fui-section': 'action'
    		},
    		action: function() {
    			validate.showValidateContainer();
    		}
    	});
    	return ValidateContainer;
    });
    define('extension/highlight',function() {
    	
    
    	var Backbone = require('lib/backbone'),
    		cache = require('basic/tools/cache'),
    		SelectRegionModel = require('models/selectRegion'),
    		selectRegions = require('collections/selectRegion'),
    		headItemCols = require('collections/headItemCol'),
    		headItemRows = require('collections/headItemRow'),
    		cells = require('collections/cells'),
    		CellsContainerView = require('views/cellsContainer'),
    		SelectRegionView = require('views/selectRegion'),
    		headItemColList = headItemCols.models,
    		headItemRowList = headItemRows.models,
    		highlightAction,
    		highlightRender,
    		extend,
    		initialize;
    
    	extend = function(target, options) {
    		var name;
    		for (name in options) {
    			target[name] = options[name];
    		}
    	}
    
    	highlightAction = {
    		hightlightMoveState: function() {
    			var strandCol = cache.CellsPosition.strandX,
    				cellModel,
    				selectModel,
    				relativeRowPosi,
    				relativeColPosi,
    				colIndex,
    				rowIndex,
    				colAlias,
    				rowAlias,
    				direction,
    				select,
    				left,
    				top,
    				right,
    				bottom;
    
    			select = this.getCoordinateByMouseEvent(event);
    			colIndex = select.colIndex;
    			rowIndex = select.rowIndex;
    			relativeRowPosi = select.relativeRowPosi;
    			relativeColPosi = select.relativeColPosi;
    			colAlias = headItemColList[colIndex].get('alias');
    			rowAlias = headItemRowList[rowIndex].get('alias');
    
    			selectModel = selectRegions.getModelByType('highlight');
    			cellModel = cells.getCellByVertical(colIndex, rowIndex)[0];
    
    			if (typeof cellModel !== 'undefined' && cellModel.get('highlight')) {
    				left = cellModel.get('physicsBox').left;
    				top = cellModel.get('physicsBox').top;
    				right = left + cellModel.get('physicsBox').width;
    				bottom = top + cellModel.get('physicsBox').height;
    			} else {
    				cache.highlightDirection = 'null';
    				selectModel && selectModel.set('highlightDirection', null);
    				return;
    			}
    
    			if (typeof selectModel === 'undefined') {
    				selectModel = new SelectRegionModel();
    				selectModel.set('selectType', 'highlight');
    				selectRegions.add(selectModel);
    			}
    			selectModel.set('tempPosi', {
    				initColIndex: colIndex,
    				initRowIndex: rowIndex,
    				mouseColIndex: colIndex,
    				mouseRowIndex: rowIndex
    			});
    			direction = getLightDirection();
    			selectModel.set(
    				'highlightDirection', direction
    			);
    			cache.highlightDirection = direction;
    
    			function getLightDirection() {
    				var rightDistance = right - relativeColPosi,
    					leftDistance = relativeColPosi - left,
    					topDistance = relativeRowPosi - top,
    					bottomDistance = bottom - relativeRowPosi,
    					temp = rightDistance,
    					direction = "right";
    
    				if (temp > leftDistance) {
    					temp = leftDistance;
    					direction = "left";
    				}
    				if (temp > topDistance) {
    					temp = topDistance;
    					direction = "top";
    				}
    				if (temp > bottomDistance) {
    					temp = bottomDistance;
    					direction = "bottom";
    				}
    				return direction;
    			}
    		}
    	}
    
    	highlightRender = {
    		highlight: function() {
    			var direction = this.model.get('highlightDirection');
    			this.$el.removeClass("highlight-right");
    			this.$el.removeClass("highlight-left");
    			this.$el.removeClass("highlight-top");
    			this.$el.removeClass("highlight-bottom");
    			if(direction){
    				this.$el.addClass('highlight-' + direction);
    			}	
    		}
    	}
    
    	extend(CellsContainerView.prototype, highlightAction);
    	extend(SelectRegionView.prototype, highlightRender);
    
    	initialize = SelectRegionView.prototype.initialize;
    	SelectRegionView.prototype.initialize = function(options) {
    		initialize.call(this, options);
    		if (this.model.get('selectType') === 'highlight') {
    			this.listenTo(this.model, 'change:highlightDirection', this.highlight);
    		}
    	}
    	return {
    		startHighlight: function() {
    			Backbone.trigger('event:cellsContainer:setMouseState', 'moveState', 'hightlightMoveState');
    		},
    		stopHighlight: function() {
    			if (selectRegions.getModelByType('highlight') !== undefined) {
    				selectRegions.getModelByType('highlight').destroy();
    			}
    			Backbone.trigger('event:cellsContainer:setMouseState', 'moveState', 'commonMoveState');
    		},
    		getHighlightDirection: function() {
    			return cache.highlightDirection;
    		}
    	}
    });
    
    define('spreadsheet/excelbuild',function() {
    	var original = require('basic/tools/original'),
    		listener = require('basic/util/listener'),
    		cache = require('basic/tools/cache'),
    		setFontColor = require('entrance/tool/setfontcolor'),
    		setFillColor = require('entrance/tool/setfillcolor'),
    		setFontFamily = require('entrance/tool/setfontfamily'),
    		setRowHeight = require('entrance/cell/setcellheight'),
    		setColWidth = require('entrance/cell/setcellwidth'),
    		mergeCell = require('entrance/tool/mergecell'),
    		splitCell = require('entrance/tool/splitcell'),
    		setCellContent = require('entrance/tool/setcellcontent'),
    		setCellBorder = require('entrance/tool/setcellborder'),
    		setFontSize = require('entrance/tool/setfontsize'),
    		setFontWeight = require('entrance/tool/setfontweight'),
    		setFontStyle = require('entrance/tool/setfontstyle'),
    		setFrozen = require('entrance/sheet/setfrozen'),
    		setAlign = require('entrance/tool/setalign'),
    		mouseOpr = require('entrance/selectregion/datasourceregionoperation'),
    		getPointByPosi = require('entrance/sheet/getpointbyposi'),
    		setWordWrap = require('entrance/tool/setwordwrap'),
    		getTextByCoordinate = require('entrance/cell/gettextbycoordinate'),
    		adaptScreen = require('entrance/sheet/adaptscreen'),
    		getFrozenState = require('entrance/sheet/getfrozenstate'),
    		getSelectRegion = require('entrance/sheet/getselectregion'),
    		reload = require('entrance/sheet/reload'),
    		setTextType = require('entrance/tool/settexttype'),
    		addRowModule = require('entrance/tool/addrow'),
    		addColModule = require('entrance/tool/addcol'),
    		deleteRow = require('entrance/tool/deleterow'),
    		deleteCol = require('entrance/tool/deletecol'),
    		regionDel = require('entrance/tool/regiondel'),
    		colHide = require('entrance/col/colhide'),
    		batchFillBg = require('entrance/tool/batchsetbg'),
    		validate = require('entrance/tool/validate'),
    		protect = require('entrance/tool/protect'),
    		comment = require('entrance/tool/comment');
    
    
    	var excelBuild = {
    		buildExcelOriginalData: function(domId) {
    			original.restoreExcel(domId);
    		},
    		buildExcelView: function(containerId) {
    			var Screen = require('views/screen');
    			new Screen(containerId);
    		},
    		buildExcelToolbar: function() {
    			var ShearPlateContainer = require('widgets/clipboard/shearPlateContainer'),
    				FontFamilyContainer = require('widgets/font/fontFamilyContainer'),
    				FontSizeContainer = require('widgets/font/fontSizeContainer'),
    				BorderContainer = require('widgets/celloperation/borderContainer'),
    				FillColorContainer = require('widgets/celloperation/fillColorContainer'),
    				FontColorContainer = require('widgets/font/fontColorContainer'),
    				ContentAlignContainer = require('widgets/align/contentAlignContainer'),
    				TextFormatContainer = require('widgets/cellformat/textFormatContainer'),
    				MergeCellContainer = require('widgets/celloperation/mergeCellContainer'),
    				ContentFontContainer = require('widgets/font/contentFontContainer'),
    				FrozenContainer = require('widgets/frozen/frozenContainer'),
    				InsertOperation = require('widgets/insert/insertoperation'),
    				DeleteOperation = require('widgets/delete/deleteoperation'),
    				CommentContainer = require('widgets/celloperation/commentcontainer'),
    				WordWrapContainer = require('widgets/celloperation/wordwrapcontainer'),
    				ColHide = require('widgets/hidecol/colhidecontainer'),
    				RegionDelContainer = require('widgets/celldel/regiondel'),
    				UndoredoContainer = require('widgets/undoredo/undoredocontainer'),
    				ProtectContainer = require('widgets/protect/protectcontainer'),
    				ValidateContainer = require('widgets/validate/validatecontainer');
    			new ShearPlateContainer();
    			new FontFamilyContainer();
    			new FontSizeContainer();
    			new BorderContainer();
    			new FillColorContainer();
    			new FontColorContainer();
    			new ContentAlignContainer();
    			new TextFormatContainer();
    			new MergeCellContainer();
    			new ContentFontContainer();
    			new FrozenContainer();
    			new CommentContainer();
    			new InsertOperation();
    			new DeleteOperation();
    			new WordWrapContainer();
    			new RegionDelContainer();
    			new ColHide();
    			new UndoredoContainer();
    			new ProtectContainer();
    			new ValidateContainer();
    		},
    		buildExcelPublicAPI: function(SpreadSheet) {
    			SpreadSheet.prototype.setFontColor = setFontColor;
    			SpreadSheet.prototype.setFillColor = setFillColor;
    			SpreadSheet.prototype.setFontFamily = setFontFamily;
    
    			SpreadSheet.prototype.mergeCell = mergeCell;
    			SpreadSheet.prototype.splitCell = splitCell;
    			SpreadSheet.prototype.setCellBorder = setCellBorder;
    			SpreadSheet.prototype.setCellContent = setCellContent;
    			SpreadSheet.prototype.setAlign = setAlign;
    
    			SpreadSheet.prototype.setColWidth = setColWidth;
    			SpreadSheet.prototype.setRowHeight = setRowHeight;
    
    			SpreadSheet.prototype.setFontSize = setFontSize;
    			SpreadSheet.prototype.setFontStyle = setFontStyle;
    			SpreadSheet.prototype.setFontWeight = setFontWeight;
    
    			SpreadSheet.prototype.frozen = function(sheetId, point) {
    				setFrozen(sheetId, point);
    			};
    			SpreadSheet.prototype.colFrozen = function() {
    				setFrozen('temp', null, 'col');
    			};
    			SpreadSheet.prototype.rowFrozen = function() {
    				setFrozen('temp', null, 'row');
    			};
    			SpreadSheet.prototype.unFrozen = function() {
    				setFrozen('temp', null, 'unfrozen');
    			};
    			SpreadSheet.prototype.setNormalType = setTextType.setNormal.bind(setTextType);
    			SpreadSheet.prototype.setTextType = setTextType.setText.bind(setTextType);
    			SpreadSheet.prototype.setNumType = setTextType.setNum.bind(setTextType);
    			SpreadSheet.prototype.setDateType = setTextType.setDate.bind(setTextType);
    			SpreadSheet.prototype.setPercentType = setTextType.setPercent.bind(setTextType);
    			SpreadSheet.prototype.setCoinType = setTextType.setCurrency.bind(setTextType);
    			SpreadSheet.prototype.batchFillBg = batchFillBg.set.bind(batchFillBg);
    			SpreadSheet.prototype.modifyComment = comment.modifyComment.bind(comment);
    			SpreadSheet.prototype.createAddCommentView = comment.createAddCommentView.bind(comment);
    			SpreadSheet.prototype.createEditCommentView = comment.createEditComment.bind(comment);
    			SpreadSheet.prototype.deleteComment = comment.deleteComment.bind(comment);
    
    			SpreadSheet.prototype.getPointByPosi = getPointByPosi;
    			SpreadSheet.prototype.adaptScreen = adaptScreen;
    			SpreadSheet.prototype.getTextByCoordinate = getTextByCoordinate;
    			SpreadSheet.prototype.getFrozenState = getFrozenState;
    			SpreadSheet.prototype.setWordWrap = setWordWrap;
    			SpreadSheet.prototype.getSelectRegion = getSelectRegion;
    			SpreadSheet.prototype.reload = reload;
    
    			SpreadSheet.prototype.addRow = addRowModule.add.bind(addRowModule);
    			SpreadSheet.prototype.addCol = addColModule.add.bind(addColModule);
    			SpreadSheet.prototype.deleteRow = deleteRow.deleteRow.bind(deleteRow);
    			SpreadSheet.prototype.deleteCol = deleteCol.deleteCol.bind(deleteCol);
    			SpreadSheet.prototype.regionDel = regionDel;
    
    			SpreadSheet.prototype.colHide = colHide.hide.bind(colHide);
    			SpreadSheet.prototype.colCancelHide = colHide.cancelHide.bind(colHide);
    			SpreadSheet.prototype.setValidate = validate.showValidateContainer;
    			SpreadSheet.prototype.setLock = protect.showLockContainer;
    			SpreadSheet.prototype.setProtect = protect.showProtectContainer;
    			SpreadSheet.prototype.getStep = function() {
    				return cache.sendQueueStep;
    			}
    
    		},
    		buildDataSourceOperation: function(SpreadSheet) {
    			SpreadSheet.prototype.setDataSourceState = mouseOpr.setDataSourceState;
    			SpreadSheet.prototype.setSelectState = mouseOpr.setSelectState;
    			SpreadSheet.prototype.destroyDataSoure = mouseOpr.destroyDataSoure;
    		},
    		buildExcelEventListener: function(SpreadSheet) {
    			SpreadSheet.prototype.addEventListener = listener.addEventListener;
    			SpreadSheet.prototype.removeEventListener = listener.removeEventListener;
    		},
    		buildExcelExtend: function(SpreadSheet) {
    			var highlight = require('extension/highlight');
    			SpreadSheet.prototype.startHighlight = highlight.startHighlight;
    			SpreadSheet.prototype.stopHighlight = highlight.stopHighlight;
    			SpreadSheet.prototype.getHighlightDirection = highlight.getHighlightDirection;
    		}
    	};
    	return excelBuild;
    });
    define('spreadsheet/spreadsheet',function() {
    	
    	var $ = require('lib/jquery'),
    		config = require('spreadsheet/config'),
    		cache = require('basic/tools/cache'),
    		Point = require('basic/tools/point'),
    		excelBuild = require('spreadsheet/excelbuild');
    
    	function SpreadSheet(id) {
    		if (!document.getElementById(id)) {
    			throw new Error('未找到id为' + id + '容器');
    		}
    		cache.containerId = id;
    		excelBuild.buildExcelOriginalData(id);
    		excelBuild.buildExcelView(id);
    		excelBuild.buildExcelPublicAPI(SpreadSheet);
    		excelBuild.buildDataSourceOperation(SpreadSheet);
    		excelBuild.buildExcelEventListener(SpreadSheet);
    		excelBuild.buildExcelExtend(SpreadSheet);
    
    	}
    	SpreadSheet.Point = Point;
    	return SpreadSheet;
    });
    return require('spreadsheet/spreadsheet');
});
